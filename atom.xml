<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漠·然</title>
  
  <subtitle>Maneback&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maneback.github.io/"/>
  <updated>2021-08-16T03:08:23.561Z</updated>
  <id>http://maneback.github.io/</id>
  
  <author>
    <name>Maneback</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 集合</title>
    <link href="http://maneback.github.io/2021/java-collections/"/>
    <id>http://maneback.github.io/2021/java-collections/</id>
    <published>2021-08-16T02:59:10.000Z</published>
    <updated>2021-08-16T03:08:23.561Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>集合提供了一个对象来在内部容纳若干其他的Java对象，并提供相应的访问接口。Java 的<code>java.util</code> 包主要提供了一下三种不同类型的集合：</p><ul><li><code>List</code> 有序列表的集合，可按插入顺序访问。，</li><li><code>Set</code> 确保不可以插入重复元素的集合。</li><li><code>Map</code> 通过 <code>key-value</code> 快速查找元素的集合。</li></ul><p>Java的集合设计有两个特点：一是支持泛型，可以限制插入到集合中元素的数据类型；二是实现了接口与类的分离，以上三种均为接口而非具体的实现类。并且可以通过统一的迭代器方式进行访问。</p><p><strong>我们尽量以接口而非具体的实现类来访问元素。</strong></p><p><strong>重要</strong> 以下遗留类不应该被继续使用：</p><p><code>Hashtable</code>, <code>Vector</code>, <code>Stack</code>, <code>Enumeration&lt;E&gt;</code>.</p><h3 id="list">List</h3><p>需要实现<code>equals</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; array2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; array = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//(index, elem)</span></span><br><span class="line">array.remove(<span class="number">1</span>);<span class="comment">//(elem)</span></span><br><span class="line"><span class="keyword">int</span> elem = array.get(<span class="number">1</span>)<span class="comment">//(index)</span></span><br><span class="line"><span class="keyword">int</span> n = array.size();</span><br></pre></td></tr></table></figure><h3 id="map">map</h3><ul><li><code>HashMap</code> 的 <code>key</code>必须实现<code>equals()</code> 和 <code>hashCode()</code> 方法。</li><li>有序 map 必须实现<code>Comparable</code> 接口；或者在声明时传入一个<code>Comparator</code> 接口，里面声明<code>compare</code> 函数，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无序map</span></span><br><span class="line">Map&lt;String, Integer&gt; mapper = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">mapper.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">mapper.containsKey(ch);</span><br><span class="line">mapper.get(key);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (String key : mapper.keySet());</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : mapper.entrySet());</span><br><span class="line"><span class="keyword">for</span>(String value: mapper.valueSet());</span><br><span class="line"><span class="comment">//有序map</span></span><br><span class="line">Map&lt;String, Integer&gt; order_map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="set">Set</h3><ul><li><p>只会存储 <code>key</code> 的值。</p></li><li><p>需要正确实现<code>equals()</code>和<code>hashCode()</code>方法。</p></li><li><p>有序的Set还要实现<code>Comparable</code> 接口； 或者在声明时传入一个<code>Comparator</code> 接口，里面声明<code>compare</code> 函数，</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无序Set</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"123"</span>);</span><br><span class="line">set.contains(<span class="string">"123"</span>);</span><br><span class="line">set.remove(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> n = set.size();</span><br><span class="line"><span class="comment">//有序</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="queue">Queue</h3><ul><li>实现类为 <code>LinkedList</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">int</span> n = que.size();</span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.add();</span><br><span class="line">que.remove();</span><br><span class="line">que.element();</span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offer();</span><br><span class="line">que.poll();</span><br><span class="line">que.peel();</span><br></pre></td></tr></table></figure><p>注意有两套方法，对应不同的情况。</p><h3 id="priorityqueue">PriorityQueue</h3><ul><li>放入的元素需要实现<code>Comparable</code>，或者提供一个<code>Comparator</code>对象来判断两个元素的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类与接口分离</span></span><br><span class="line">Queue&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.add();</span><br><span class="line">que.remove();</span><br><span class="line">que.element();</span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offer();</span><br><span class="line">que.poll();</span><br><span class="line">que.peek();</span><br></pre></td></tr></table></figure><h3 id="deque">Deque</h3><ul><li>deque 是用 LinkedList 实现的接口，赋予了不同的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.addLast(); <span class="comment">//addFirst</span></span><br><span class="line">que.removeLast(); <span class="comment">//removeFirst</span></span><br><span class="line">que.getLast(); <span class="comment">// getFirst</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offerLast(); <span class="comment">//offerFirst</span></span><br><span class="line">que.pollLast(); <span class="comment">//pollLast</span></span><br><span class="line">que.peekLast(); <span class="comment">//peekLast</span></span><br></pre></td></tr></table></figure><h3 id="stack">Stack</h3><ul><li>stack 是用Deque接口来模拟的，原来的stack被占用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stack.isEmpty();</span><br><span class="line">stack.pop();</span><br><span class="line">stack.push(ch);</span><br><span class="line">stack.peek()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java 集合的使用
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://maneback.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://maneback.github.io/2021/regx/"/>
    <id>http://maneback.github.io/2021/regx/</id>
    <published>2021-08-14T03:37:17.000Z</published>
    <updated>2021-08-16T03:10:50.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="正则表达式">正则表达式</h3><h4 id="限定符">1. 限定符</h4><p>限定符用来指定正则表达式的一个给定组件要出现多少次才能满足匹配，共有<code>*</code>、<code>?</code>、<code>+</code>、<code>{n}</code>、<code>{n,}</code>，<code>{n,m}</code>六种，他们的描述如下：（限定出现次数）</p><table><thead><tr class="header"><th>字符</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td>*</td><td style="text-align: left;">匹配前面的子表达式零次或多次，等价于{0,}</td></tr><tr class="even"><td>+</td><td style="text-align: left;">匹配前面的子表达式一次或多次，等价于{1,}</td></tr><tr class="odd"><td>？</td><td style="text-align: left;">匹配前面的子表达式零次或一次，等价于{0,1}</td></tr><tr class="even"><td>{n}</td><td style="text-align: left;">n是一个非负数，匹配确定的n次</td></tr><tr class="odd"><td>{n,}</td><td style="text-align: left;">至少匹配n次</td></tr><tr class="even"><td>{n,m}</td><td style="text-align: left;">最少匹配n次且最多匹配m次。注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p><strong>注意：</strong><code>*</code>和<code>+</code>都是贪婪的，他们会尽可能匹配多的文字，只有在它们后面加上一个<code>?</code>就可以实现非贪婪匹配。</p><h4 id="普通字符">2. 普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有的大小写字母、所有的数字、所有的标点和一些其他符号。</p><h4 id="非打印字符">3. 非打印字符</h4><h4 id="特殊字符">4. 特殊字符</h4><p>特殊字符是一些有特殊含义的字符。</p><table><thead><tr class="header"><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>$</td><td>匹配输入字符串的结尾位置</td></tr><tr class="even"><td>()</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</td></tr><tr class="odd"><td>*</td><td>匹配前面的子表达式零次或多次。</td></tr><tr class="even"><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr class="odd"><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪的限定符</td></tr><tr class="even"><td>.</td><td>匹配除换行符之外的任何单字符</td></tr><tr class="odd"><td>[</td><td>标记一个中括号表达式的开始</td></tr><tr class="even"><td>\</td><td>将下一个字符标记为或特殊字符、或原意字符、或向后引用、或八进制转义符。</td></tr><tr class="odd"><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，表示不接受该字符集合</td></tr><tr class="even"><td>{</td><td>标记限定符表达式的开始</td></tr><tr class="odd"><td>|</td><td>指明两项之间的一个选择</td></tr></tbody></table><p>当你想匹配表格中列举的特殊字符的话，请在该字符前面加上<code>\</code>。</p><h4 id="定位符">5. 定位符</h4><p>定位符使得能够将正则表达式固定到行首或行尾，还能创建出现在一个单词内，在一个单词开头或者结尾的表达式，</p><p>定位符用于描述字符串或单词的边界，<code>^</code>和<code>$</code>分别标记字符串的开始和结尾。<code>\b</code>描述单词的前或后边界，<code>\B</code>表示非单词边界。</p><p>定位符有：</p><table><thead><tr class="header"><th>定位符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>^</td><td>匹配输入字符串开始的位置。</td></tr><tr class="even"><td>$</td><td>匹配输入字符串结束的位置。</td></tr><tr class="odd"><td> 匹配一个单词边界，即字与空格之间的位置。</td><td></td></tr><tr class="even"><td></td><td>非单词边界匹配</td></tr></tbody></table><p><strong>注意：</strong> 不能将限定符和定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上的位置。</p><h4 id="选择">6. 选择</h4><p>用圆括号将所有的选择项括出来，相邻的选择项用|分隔，但用圆括号会使相关的匹配被缓存（<strong>什么是缓存？</strong>），因此可以放一个<code>?:</code>放在选择项前消除这种副作用。</p><h4 id="反向引用">7. 反向引用</h4><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。可以使用非捕获元字符<code>?:</code>, <code>?=</code>, <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p><h3 id="匹配规则">匹配规则</h3><h4 id="基本匹配模式">1. 基本匹配模式</h4><p>从最基本的开始。<strong>模式</strong> 是正则表达式的最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，也可以很复杂，如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="built_in">once</span></span><br><span class="line"><span class="built_in">once</span>$</span><br><span class="line">^<span class="built_in">once</span>$</span><br></pre></td></tr></table></figure><p>该模式包含一个特殊字符<code>^</code>，匹配那些以once开头的字符串。<code>$</code>匹配以该模式结尾的字符串。而当二者同时使用时，代表精准匹配一个模式。</p><p>如果一个模式不包括<code>^ $</code>， 那么它与任何包含该模式的字符串匹配，例如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure><p>与字符串</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There once was <span class="keyword">a</span> man <span class="built_in">from</span> NewYork</span><br><span class="line">Who kept all <span class="keyword">of</span> his cash <span class="keyword">in</span> <span class="keyword">a</span> bucket.</span><br></pre></td></tr></table></figure><p>都是匹配的。</p><h4 id="字符族">2. 字符族</h4><p>可以用方括号来表示字符族，如，以下元音字符族：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure><p>以及表示范围的字符族</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">a-z</span>] <span class="comment">//匹配所有的小写字母 </span></span><br><span class="line">[<span class="meta">A-Z</span>] <span class="comment">//匹配所有的大写字母 </span></span><br><span class="line">[<span class="meta">a-zA-Z</span>] <span class="comment">//匹配所有的字母 </span></span><br><span class="line">[<span class="meta">0-9</span>] <span class="comment">//匹配所有的数字 </span></span><br><span class="line">[<span class="meta">0-9\.\-</span>] <span class="comment">//匹配所有的数字，句号和减号</span></span><br></pre></td></tr></table></figure><p>这些字符族只表示一个字符。如我们要匹配又一个小写字母加一位数字组成的两位的字符串，可以用以下这个模式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">a-z</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure><p>这里的<code>^</code>表示字符串开头，但是在一组方括号中使用<code>^</code>时，表示“非”和“排除”的意思，即不能包含该字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">^0-9</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure><p>表示第一位不能为数字</p>]]></content>
    
    <summary type="html">
    
      正则表达式
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="正则表达式" scheme="http://maneback.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="http://maneback.github.io/2021/db-index/"/>
    <id>http://maneback.github.io/2021/db-index/</id>
    <published>2021-08-14T02:56:04.000Z</published>
    <updated>2021-08-16T03:00:56.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="mysql索引">MySQL索引</h1><h3 id="索引的数据结构">索引的数据结构</h3><p>MySQL的底层存储引擎支持 InnoDB 和 MyISAM 两种，而默认存储引擎 InnoDB 采用的是B+树来作为索引的存储结构。</p><p><strong>那么为什么 InnoDB 存储引擎会使用 B+ 树来存储数据</strong> ，而不是采用 <strong>B- 树</strong>、<strong>红黑树</strong> 或是 <strong>AVL 树</strong> 来存储索引？</p><h3 id="数据结构的比较">数据结构的比较</h3><p>MySQL需要把数据持久化到磁盘上，因此需要频繁地读取磁盘上的数据，因此磁盘IO的次数很大程度上决定了查询效率。</p><p>对于大规模数据的索引来讲， 红黑树和 AVL 的结构往往会导致 <strong>深度过大</strong> 而造成磁盘IO过于频繁导致效率低下。而B-树和B+树的特点是每一个层的节点数量更多，树的层数更小，这样查询的时候就能够减少磁盘IO的次数。</p><p>另外B-树的非叶子节点都存有数据域，这无疑增加了节点的大小，而减少了每一页中所能容纳的节点数量；而B+树只有叶子结点来存储数据，节点更小，磁盘IO更少。</p><p>除此之外，深入分析数据库索引和底层的存储结构能发现B-树和B+树更大也更重要的区别。</p><h3 id="数据库存储结构">数据库存储结构</h3><h4 id="b-树">B-树</h4><p>对于 InnoDB 来说，所有的数据都是以键值对（key-data）的方式存储的，主键索引和辅助索引在存储数据时会将 <code>id</code> 和 <code>index</code> 作为键，将所有列和 <code>id</code> 作为键对应的值。 这个key就是存储在B+树非叶子节点中的值。在B-树中除了键外，还会存储data值。</p><p>再提一次这句话： <strong>B-树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中。</strong></p><p>在B-树中，由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816090826.png" alt="image-20210816090826822" style="zoom:50%;"></p><p>如上：如果我要查找 【位于4到16之间的所有值】的时候，就需要：</p><ul><li>加载node1 所在的页</li><li>找到指向node2的指针，并加载所在页，遍历页面中的数据，发现还没找全；</li><li>回来加载node1所在的页，发现还没找全；</li><li>找到指向node3的指针，并加载所在也，遍历页面中的数据，完成查找。</li></ul><p>这样一来，每次都需要从根节点向下遍历所有子节点来查找。会经历多次磁盘IO。</p><h4 id="b-树-1">B+ 树</h4><p>B+ 树是数据库底层的真实数据存储结构。</p><p>而使用B+树，所有的节点都储存在叶子节点中，此外通过构建树的过程中， 还可以保证叶子节点中的数据都是有序的，所以我们还可以在叶子节点中增加一个（双向）的指针，来只想相邻节点。图中每个灰色节点都代表磁盘上存储数据的一个页。这样当出现跨页的时候，就不需要从根节点从上至下查找了，只需要根据指针找到下一页。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816092140.png" alt="image-20210816092140647" style="zoom:50%;"></p><h4 id="聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</h4><p><strong>聚簇索引</strong></p><p>在数据库中，我们可能会根据需要建立多个不同用途的索引，每个索引都是组成像上述B+树的结构，但是实际上在硬盘中只会存储一个数据文件。像上述图中这样把索引与数据建在一起的索引称为<strong>聚簇索引</strong>。</p><p><strong>聚簇索引默认建立在数据表的主键上。</strong></p><p><strong>非聚簇索引</strong></p><p>当再建立新的索引时，就不需要存储data文件了，而是只需要存储索引，这种索引与数据分离的就成为 <strong>非聚簇索引</strong> 。这时候每个叶子结点存储的不是data而是指向聚簇索引的key值，通过key值再反过来查找聚簇索引。也就是需要二次查找。</p><p><strong>覆盖索引</strong></p><p>当一个语句检索的列只包含建立非聚簇索引的列及主键，这样非聚簇索引中就包含了我们需要的全部数据项，不用再去二次查找聚簇索引了。</p><h2 id="问题">问题</h2><ol type="1"><li>为什么主键通常建议使用自增id</li></ol><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，就需要不断地调整数据的物理地址、分页。</p><ol start="2" type="1"><li>默认聚簇索引</li></ol><p>聚簇索引<strong>默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。</p><ol start="3" type="1"><li>聚簇索引的劣势</li></ol><p><strong>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候</strong>。如果使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键。</p><ol start="3" type="1"><li>索引的优缺点</li></ol><ul><li>优点：加快查询速度</li><li>降低增删改速度，存储索引需要占用额外的空间。</li><li>每当数据库中有记录插入或删除时，索引都需要更新。如果有记录更新，任何搜索码属性受影响的索引也必须更新。</li></ul><h2 id="索引失效的情况">索引失效的情况</h2><p>在一定条件下，索引可能会失效，即无法通过索引来加速查询过程。</p><ul><li>where 子句中进行 NULL 判断</li><li>where 子句中使用 <code>!=, &lt;&gt;, not</code> 这样的判断</li><li>避免在 where 子句中使用 or， 如果其中一个字段没有索引的话，将放弃使用索引</li><li>避免在 where 子句中使用 <code>in</code></li><li>避免在 where 子句中<code>=</code>的左边使用表达式操作或者函数操作</li><li>避免在 where 子句中使用 ‘like’ 模糊查询</li><li>联合索引的最左原则，如联合索引为<code>&lt;a,b,c&gt;</code>, 则对 <code>a</code> 会使用联合索引，而<code>b,c</code> 则不会用到联合索引。</li></ul><h2 id="数据库存储引擎的对比">数据库存储引擎的对比</h2><ol type="1"><li><strong>事务支持</strong>： InnoDB 支持事务，MyISAM 不支持事务。</li><li><strong>外键支持</strong>： InnoDB 支持外键，而 MyISAM 不支持。</li><li><strong>索引支持</strong>： InnoDB 是聚集索引，MyISAM 是非聚集索引。</li><li><strong>锁支持</strong>： InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。</li><li><strong>恢复</strong>： 系统崩溃后，MyISAM恢复起来更困难。</li><li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li><li>innoDB所有的表在磁盘上保存在一个文件中；myISAM存储成三个文件。</li></ol><h4 id="如何选择">如何选择</h4><ol type="1"><li>如果要支持事务，选择 InnoDB。</li><li>如果大多是只是读查询，可以考虑MyISAM。如果既有读写也挺频繁，请使用InnoDB。</li></ol>]]></content>
    
    <summary type="html">
    
      介绍数据库的索引结构
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="database" scheme="http://maneback.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务管理与锁</title>
    <link href="http://maneback.github.io/2021/db-lock/"/>
    <id>http://maneback.github.io/2021/db-lock/</id>
    <published>2021-08-12T02:57:18.000Z</published>
    <updated>2021-08-16T03:09:01.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数据库的事务与锁">数据库的事务与锁</h2><h3 id="事务及其性质">事务及其性质</h3><p>事务必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。</p><ol type="1"><li>原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；</li><li></li><li>一致性指的是事务的执行结果必须是使数据库从一个一致性状态变成另一个一致性状态，一致性和原子性是密切相关的；</li><li>隔离性指的是一个事务执行不能被其他事务干扰；</li><li>持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</li></ol><h4 id="事务隔离级别">事务隔离级别</h4><p>数据库的隔离级别可以分为：<strong>读未提交、读提交、可重复读和串行化</strong>。</p><p>在学习这里的时候，总感觉说得满头雾水的，怎么也不能理解，因为它又联系着三个现象： <strong>脏读、不可重复读、幻读</strong>。</p><p>当时很难理解隔离级别与现象之间的关系，现象可以理解为多个事务并发时候如不哦不加控制而导致的<strong>问题</strong>。隔离级别是为了避免其中的某种或某几种问题而设置的一种<strong>执行要求</strong> 或<strong>执行流程</strong>。</p><p>先来看现象：</p><p>我们假设有两个事务 A 和 B 在进行读写操作。</p><ul><li><p>脏读： B读到了A未提交的修改数据</p><p>A修改未提交—B读—A回滚 （A写的时候B读），这时候B读到的就是错误的数据。</p></li><li><p>不可重复读： 在两次读之间插入了另一个事务的修改操作，并提交，导致两次读取不一致。</p><p>（A读的时候B写）</p></li><li><p>幻读：在两次读取之间，出现了 INSERT 操作。</p><p>A读—–B插入—–A读。两次读取不一致。</p></li></ul><p>不可重复读与幻读之间的区别在于，A 两次读之间的差别，是由于 UPDATE 操作还是由 INSERT 操作引起的。</p><p>那么为了避免这些问题的发送，数据库设计了不同的事务隔离级别。</p><ul><li><p><strong>读未提交</strong>：一个事务可以读取另一个未提交事务的数据</p><p>这种情况下不会带来任何的隔离，三种情况都可能发生。</p></li><li><p><strong>读提交</strong>：一个事务要等另一个事务提交后才能读取数据（<strong>避免脏读</strong>）（给修改加锁禁止读）</p><p>B无法读到A未提交的修改，避免了脏读。</p></li><li><p><strong>可重复读</strong>：读取事务开始后，不允许修改（<strong>避免不可重复读</strong>）（读加锁禁止修改）</p><p>A在读取的时候，B只能读，不能改，可以保证A读取的过程的一致性。</p><p>但是只能锁住表中已有的行，而不能阻止其他事务的插入，无法避免幻读。</p></li><li><p><strong>串行化</strong>：每个事务完全串行化进行。（<strong>避免幻读</strong>）</p></li></ul><p>事务隔离级别和可能存在的问题如下：</p><table><thead><tr class="header"><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr class="odd"><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>读已提交</td><td></td><td>√</td><td>√</td></tr><tr class="odd"><td>可重复读</td><td></td><td></td><td>√</td></tr><tr class="even"><td>串行化</td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="锁">锁</h3><p>数据库锁出现的原因是为了处理并发问题。数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制。</p><p>数据库的锁根据不同的分类角度可以由不同的分类：</p><ul><li>从使用角度： 乐观锁与悲观锁</li><li>从数据库机制上：共享锁与排它锁</li><li>从锁的粒度上： 行级锁和表级锁</li></ul><h5 id="悲观锁与乐观锁">悲观锁与乐观锁</h5><ul><li>悲观锁：假定会发生并发冲突，在最整个数据处理过程中都将数据处于锁定的状态，</li><li>乐观锁：假设不会发生并发冲突，只有在提交时检查是否违反数据的完整性。</li></ul><h5 id="排它锁与共享锁">排它锁与共享锁</h5><ul><li>排它锁：也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。</li><li>共享锁：也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。</li></ul><h5 id="二阶段锁">二阶段锁</h5><p>每个事务分两个阶段提出加锁和解锁申请。最初处于加锁阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，并且不能再发出加锁请求。<strong>二阶段封锁并不会保证不发生死锁</strong>（如果请求锁的数据顺序不同）。</p><p>引入2PL是为了保证事务的隔离性，<strong>保证并发调度的准确性</strong>，多个事务在并发的情况下依然是串行的。</p><hr><h3 id="mvcc版本控制">MVCC版本控制</h3><p><strong>多版本并发控制（MVCC）</strong> 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。简单来说，<strong>MVCC</strong> 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。 是乐观锁的一种实现方式。</p><p>MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的创建版本号，一个保存了行的删除版本号。每开启一个新的事务，系统版本号都会自动递增，作为事务的版本号。</p><ul><li><p>MVCC读写不冲突不加锁，写写之间互相冲突需要加锁串联执行。（乐观锁）</p></li><li><p>select</p><p>只会查找版本号小于等于当前事务版本的数据行。这样保证事务读取的是之前已经存在的或是事务自身插入的。</p></li><li><p>insert</p><p>每插入新的一行，都保存当前的系统版本号作为行的版本号。</p></li><li><p>delete</p><p>为删除的每一行保存当前系统版本号作为行删除版本号。</p></li><li><p>update</p><p>插入一条新的记录，保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行作为删除版本号。</p></li></ul><h5 id="mvcc-解决了哪些问题">MVCC 解决了哪些问题</h5><ol type="1"><li>读写阻塞问题：MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率：读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li></ol><h5 id="快照读与当前度">快照读与当前度</h5><p><strong>快照读</strong>（SnapShot Read） 是一种一致性不加锁的读，是InnoDB并发如此之高的核心原因之一。</p><blockquote><p>这里的<strong>一致性</strong>是指，事务读取到的数据，要么是<strong>事务开始前就已经存在的数据</strong>，要么是<strong>事务自身插入或者修改过的数据</strong>。</p></blockquote><p>不加锁的简单的 SELECT 都属于<strong>快照读</strong>。</p><p>与 <strong>快照读</strong> 相对应的则是 <strong>当前读</strong>，<strong>当前读</strong>就是读取最新数据，而不是历史版本的数据。加锁的 SELECT 就属于当前读，例如：</p>]]></content>
    
    <summary type="html">
    
      介绍数据库的事务管理，锁以及MVCC
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="database" scheme="http://maneback.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>排序算法汇总</title>
    <link href="http://maneback.github.io/2021/sortings/"/>
    <id>http://maneback.github.io/2021/sortings/</id>
    <published>2021-07-22T02:01:30.000Z</published>
    <updated>2021-08-14T03:35:22.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比总结常见的排序算法：</p><p>选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序</p><a id="more"></a><h4 id="排序算法">排序算法</h4><p>均默认为升序排列。</p><h5 id="选择排序">选择排序</h5><p>每次遍历数组，找到未排序中的最小元素，然后放到已排序的末尾位置，直到所有的元素均排序完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        print(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="冒泡排序">冒泡排序</h5><p>每次比较两个相邻元素，较大的元素每次移动一个位置，不断地冒泡到数组末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):</span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>]&gt;nums[j]:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="插入排序">插入排序</h5><p>每次选择一个数，在前面已排序好的序列中寻找该数字应该所在的位置，并向后移动部分已排序数字，将新数字插入到相应位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        idx = c</span><br><span class="line">        n = nums[c]</span><br><span class="line">        <span class="keyword">while</span> idx&gt;<span class="number">0</span> <span class="keyword">and</span> nums[idx<span class="number">-1</span>]&gt;n:</span><br><span class="line">            nums[idx] = nums[idx<span class="number">-1</span>]</span><br><span class="line">            idx-=<span class="number">1</span></span><br><span class="line">        nums[idx] = n</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="希尔排序">希尔排序</h5><p>希尔排序是对插入排序的改进版。在插入排序中， 数字每一次只能移动一个位置，而希尔排序是增加移动间隔，使较小的数字能更加快速地移动到队列头部。</p><p>具体算法描述如下：</p><ul><li><p>选择一个增量序列 <span class="math inline">\(g_1 &gt; g_2&gt;\cdots&gt; g_k\)</span> 且 <span class="math inline">\(g_k=1\)</span>。</p></li><li><p>对于每一个增量<span class="math inline">\(g\)</span>, 进行一次排序。</p></li><li><p>在每次排序中，按照间隔进行一次插入排序。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap=n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            i = c</span><br><span class="line">            <span class="keyword">while</span> i-gap&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i-gap]&gt;gap:</span><br><span class="line">                nums[i-gap], nums[i] = nums[i], nums[i-gap]</span><br><span class="line">                print(nums)</span><br><span class="line"></span><br><span class="line">                i-=gap</span><br><span class="line">        gap = gap//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="归并排序">归并排序</h5><p>归并排序是一种分治思想，先将数组分为子序列，缩小问题规模，让每个子序列各自有序，然后再将有序的子序列合并成一个完整数组。这样每一次的问题规模都变为原问题的 1/2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">            <span class="keyword">if</span> left[l]&lt;right[r]:</span><br><span class="line">                res.append(left[l])</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[r])</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">        res += left[l:]</span><br><span class="line">        res += right[r:]</span><br><span class="line">        print( res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = n//<span class="number">2</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><h5 id="快排">快排</h5><p>快排是选取一个哨兵位置，将小于哨兵的数据全部放到左边，将大于哨兵的数据全放到右边，然后再用相同的思想对左右两边继续排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        <span class="comment"># print(left, right)</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;=right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;nums[pivot]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=nums[pivot]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        quick(left, j<span class="number">-1</span>)</span><br><span class="line">        quick(j+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h5 id="计数排序">计数排序</h5><p>计数排序是开辟额外的空间来存储每个值的出现次数，然后再根据计数填充数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    _min = min(nums)</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    tmp_arr = [<span class="number">0</span>]*(_max-_min+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_arr[nums-_min]+=<span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> tmp_arr[j]==<span class="number">0</span>:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        nums[i] = j+_min</span><br><span class="line">        tmp_arr[j] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="堆排序">堆排序</h5><p>堆排序是使用了堆这个数据结构来进行的排序算法。把一维的数组想象成一个二叉树（堆）结构。</p><p>过程如下：</p><ol type="1"><li>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；</li><li>交换堆顶和最后一个元素，重新调整堆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, startops, endops)</span>:</span></span><br><span class="line">        pos = startops</span><br><span class="line">        childops = pos*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> childops&lt;endops:</span><br><span class="line">            rightops = childops+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightops&lt;endops <span class="keyword">and</span> nums[rightops]&gt;nums[childops]:</span><br><span class="line">                childops = rightops</span><br><span class="line">            <span class="keyword">if</span> nums[childops]&gt;nums[pos]:</span><br><span class="line">                nums[pos], nums[childops] = nums[childops], nums[pos]</span><br><span class="line">                adjust_heap(nums, childops, endops)</span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 从后往前即低向上</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n//<span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i,n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="基数排序">基数排序</h5><p>基数排序是针对数字每一位进行排序，从最低位开始排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    max_digit = len(str(_max))</span><br><span class="line">    buckList = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    div, mod = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckList[num%mod//div].append(num)</span><br><span class="line">        div *= <span class="number">10</span></span><br><span class="line">        mod *= <span class="number">10</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        print(buckList)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> buckList[j]:</span><br><span class="line">                nums[idx] = item</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            buckList[j] = []</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="对比">对比</h5><p>下面对排序算法做一个总结和对比。</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814104124.png" alt="image-20210814104124495"><figcaption aria-hidden="true">image-20210814104124495</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对比总结常见的排序算法：&lt;/p&gt;
&lt;p&gt;选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="排序算法" scheme="http://maneback.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://maneback.github.io/2021/beibao/"/>
    <id>http://maneback.github.io/2021/beibao/</id>
    <published>2021-06-15T11:22:56.000Z</published>
    <updated>2021-08-16T03:11:01.490Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="问题描述">问题描述</h3><p>对于背包问题，是求在具有容量（质量体积个数）约束的情况下，求所有商品满足约束的<strong>可行性解、最优解或解的个数</strong>。</p><h4 id="一般化描述">一般化描述</h4><p>本文关注于 0-1 背包问题，即：每个物品只有一个。</p><blockquote><p>物品总数 <span class="math inline">\(n\)</span></p><p>背包容量 <span class="math inline">\(W\)</span></p><p>物品质量 <span class="math inline">\(w_i\)</span></p><p>物品价值 <span class="math inline">\(p_i\)</span></p></blockquote><p>总质量约束为 <span class="math inline">\(W\)</span></p><p>物品的质量/成本为 <span class="math inline">\(w_i\)</span></p><p>物品的价值为 <span class="math inline">\(p_i\)</span></p><p>一般来讲，背包问题可以用动态规划问题来求解。对于背包问题有三类，即：求是否有可行解、最优解的值（价值最大化最小化）、求可行解的总个数。这三类问题对应了三种动态规划递推式。</p><p>好多问题都可以转化成背包问题来求解。</p><p>对于每一类问题，在这里我们用到动态规划数组 <code>dp[i][j]</code> 表示前 <span class="math inline">\(i\)</span> 商品放入容量为 <span class="math inline">\(j\)</span> 的背包时的解。</p><h3 id="问题分类">问题分类</h3><h4 id="最大价值">最大价值</h4><p>其转移方程如下： <span class="math display">\[f[i][j] = \cases{f[i-1][j]\\f[i-1][j-w_i]+p_i}\]</span> 初始化时，<code>dp[0][0]=0</code>。</p><p>第一种情况表示不放置第 <span class="math inline">\(i\)</span> 件商品，第二种情况表示放置，所以要给它腾出 <span class="math inline">\(w_i\)</span> 大小的空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(weights, profit, W)</span>:</span></span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>]* (W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(profit[i<span class="number">-1</span>], W+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i<span class="number">-1</span>]]+profit[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br></pre></td></tr></table></figure><p>在这里，我们看到，数组 <code>dp</code> 只会用到前面一行来更新，因此我们可以用一个一维的滚动数组来替代二维数组降低空间复杂度。同时在遍历容量时，会用到上一行中小于当前容量的数据，并不会用到大于当前容量的数据。因此要对一维数组对容量进行倒序遍历。</p><h4 id="可行解数量">可行解数量</h4><p>例题： <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494 目标和</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><blockquote><p>解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3</p></blockquote></blockquote><p>数组总和为 <code>sum</code>， 设添加 <code>+</code> 的数字和为 <code>positive</code>, 添加 <code>-</code> 的数字和为<code>negative</code>，则有一下方程组成立 <span class="math display">\[\cases{positve+negative = sum\\positive-negative = target}\]</span> 解方程组可得： <span class="math display">\[negative = \frac{sum-target}{2}\]</span> 即从数组中找到若干个数字和为 <code>negative</code>，求解的个数。</p><p>数字大小即为成本。</p><p><code>dp[i]</code> 表示和为 <code>i</code> 的解的个数。</p><p>在每一个数字开始循环时，<code>dp[i]</code>表示的既是上一轮的解的个数，又是当前轮不包含当前数组的情况下的解的个数。因此再加上包含当前数字的情况的解的个数，即为本轮的解。</p><p>初始化为<code>dp[0] = 1</code> 其他为0， 表示和为 0 有一种解，即什么都不选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> (s-target)%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">or</span> target&gt;s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] += dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        num = nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有赋值，下一行可能被用到，所以要从 0  开始遍历。</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j-num]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="是否存在可行解">是否存在可行解</h4><blockquote><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><blockquote><p>输入：[1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote></blockquote><p>同样，在每一个数组开始循环前，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPatrition</span><span class="params">(nums)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">   V = s//<span class="number">2</span></span><br><span class="line">    dp = [<span class="keyword">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = dp[v]|dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = s//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="keyword">False</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有被赋值，而前面的可能会被下一行用到，所以要从 0 开始赋值。把上一行的复制下来</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=nums[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i][j] | dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      背包问题
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="背包问题" scheme="http://maneback.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://maneback.github.io/2021/slidingwindow/"/>
    <id>http://maneback.github.io/2021/slidingwindow/</id>
    <published>2021-06-14T13:29:42.000Z</published>
    <updated>2021-08-16T03:11:24.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="滑动窗口">滑动窗口</h4><p>滑动窗口可以用来解决一系列的数组问题，如最长无重复子数组（子串）、窗口最大值、满足某种条件的最长数组/最短数组。</p><p>感觉滑动窗口可以分为几类：</p><ol type="1"><li>定长窗口</li><li>寻找最长窗口</li><li>寻找最短窗口</li></ol><p>其主要的区别就在于：如何添加元素、合适进行窗口的合理性判断（即判断是否满足条件）以及更新答案。</p><p>对于定长窗口来讲，只要一直保持窗口的长度，每次增加一个元素并删除一个元素即可。</p><p>对于最长窗口来讲，每次删除一个最左元素，然后一直扩展右边界，直到不满足条件（窗口内仍满足条件），再更新答案。</p><p>对于最短窗口来讲，每次一直扩展右边界，直到不满足条件，然后再一直删除左元素，在循环中更新答案。（因为是寻找最短窗口，且在缩短左边界，因此这种情况下最后一次更新答案一定是最小值。）</p><h4 id="存在重复元素ii">存在重复元素II</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Leetcode-219</a></p><ul><li>题目描述</li></ul><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引<code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code>和<code>j</code> 的差的 绝对值 至多为 <code>k</code>。</p><ul><li>分析</li></ul><p>最初我是用一个dict 保存每个数字出现的次数，每次用滑动窗口添加元素删除元素，但是后来边界样例给我惊了，那就是当<code>k</code>的大小等于数组的长度的时候，是没有办法判断的。所以不能这样搞。</p><p>后来直接用字典记录每个数字最后出现的位置，再用位置去相减判断距离就好了。</p><ul><li>错误代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span> </span><br><span class="line">        windows = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> windows[nums[i]]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                windows[nums[i-k]]-=<span class="number">1</span></span><br><span class="line">                windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><ul><li>正确代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>       </span><br><span class="line">        dit = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> dit <span class="keyword">and</span> idx-dit[n]&lt;=k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dit[n] = idx</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h4 id="爱生气的书店老板">爱生气的书店老板</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">Leetcode-1052</a></p><ul><li>题目描述</li></ul><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210810140952.png" alt="image-20210810140952301"><figcaption aria-hidden="true">image-20210810140952301</figcaption></figure><ul><li>分析</li></ul><p>当已知有 <code>grumpy</code> 数组时候，对于不生气的情况，无论怎么怎么控制情绪，这部分满意的顾客总数是不会改变的，所以我们只需要考虑，老板控制了脾气之后，最大能 improve 多少挽回多少新的顾客。如果把 <code>grumpy</code> 与 <code>customer</code> 数组做 <code>element-wise</code> 乘积的话，就可以知道能够挽回的顾客数量，再进行 <code>X</code> 长度的子数组和取最大就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(customers)</span><br><span class="line">        level = sum([c*(<span class="number">1</span>-g) <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy)])</span><br><span class="line"></span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X):</span><br><span class="line">            inc+= customers[i]*grumpy[i]</span><br><span class="line">        max_inc = inc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X, n):</span><br><span class="line">            inc = inc+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X]</span><br><span class="line">            max_inc = max(inc, max_inc)</span><br><span class="line">        <span class="keyword">return</span> level + max_inc</span><br></pre></td></tr></table></figure><h4 id="无重复字符的最长子串">无重复字符的最长子串</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><ul><li>分析</li></ul><p><strong>依次枚举子串起始位置的左边界</strong>，记录以该位置开始子串的最长长度，每一次剔除一个最左字符串， 不断地扩展右边界。直到不满足条件位置，这时判断是否需要更新答案。</p><p><strong>窗口内永远是满足条件的子串，而非剔除直到不满足。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ccc = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">                ccc.remove(s[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk+<span class="number">1</span>&lt;n <span class="keyword">and</span> s[rk+<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ccc:</span><br><span class="line">                ccc.add(s[rk+<span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            ans = max(ans, rk+<span class="number">1</span>-i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="滑动窗口最大值">滑动窗口最大值</h4><ul><li>题目描述</li></ul><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><ul><li>分析</li></ul><p>只要用 滑动窗口 + 单调队列 即可解决，每次边界移动一个位置，向结果数组中添加一个元素。</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># init </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">        res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> que[<span class="number">0</span>]==nums[i-k]:</span><br><span class="line">                que.popleft()</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">            res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组">长度最小的子数组</h4><ul><li>题目描述</li></ul><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><ul><li>分析</li></ul><p>返回最小长度，依旧是扩充右边界，判断是否满足，缩减左边界</p><p>因为是最小长度，所以在缩减左边界时候更新答案</p><p>注意当退出内层 <code>while</code> 循环时，其实已经不满足和 <code>&gt;= target</code> 的条件了，所以要在 <code>while</code> 循环内部更新答案。窗口是在不断减小的，所以最后一次更新一定是最小的，不会影响结果的正确性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)==target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        wind_sum = <span class="number">0</span></span><br><span class="line">        res = n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;n:</span><br><span class="line">            wind_sum += nums[right]</span><br><span class="line">            <span class="keyword">while</span> wind_sum&gt;=target:</span><br><span class="line">                res = min(res, right-left+<span class="number">1</span>)</span><br><span class="line">                wind_sum-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==n+<span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      滑动窗口
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="滑动窗口" scheme="http://maneback.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 定时任务</title>
    <link href="http://maneback.github.io/2021/crontab/"/>
    <id>http://maneback.github.io/2021/crontab/</id>
    <published>2021-05-22T07:29:33.000Z</published>
    <updated>2021-08-14T03:55:24.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>介绍 Linux 定时任务命令 <code>crontab</code> 的使用</p><a id="more"></a><h1 id="linux-crontab">linux crontab</h1><p>linux crontab 是用来定期执行程序的命令。系统会默认启动此任务调度命令。</p><p>crond命令会每分钟定期检查是否有需要执行的工作，如果有的话，便执行该工作。</p><h5 id="语法">1.语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-e | -l | -r&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li><code>-e</code> 执行文字编辑器设定日程表</li><li><code>-r</code>删除目前的日程表</li><li><code>-l</code>列出目前的日程表</li></ul></li></ul><h5 id="时间格式">2. 时间格式</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f1</span> <span class="built_in">f2</span> <span class="built_in">f3</span> <span class="built_in">f4</span> <span class="built_in">f5</span> program</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>f1表示分钟，f2表示小时，f3表示一个月份中的第几天，f4表示月份，f5表示一个星期中的星期几。</li><li>某一项为*表示每分钟或每小时等都要执行程序</li><li>某一项为<code>a-b</code>时表示在a-b这段时间执行。</li><li>某一项为<code>*/n</code>时表示每隔n个单位执行。</li><li>某一项为<code>a,b,c</code>时表示取值为a，b，c时执行。</li></ul></li></ul><h5 id="实例">3. 实例</h5><p>说一千道一万都不如来几个例子来得实在。</p><ul><li><p>每月每天每小时的第0分钟<code>0 * * * * ls</code></p></li><li><p>在12月份，每天早上6点到12点，每隔3小时，每小时第10分钟执行<code>10 6-12/3 * 12 * ls</code></p></li><li><p>每周一到周五下午5:00执行<code>0 17 * * 1-5 ls</code></p></li><li><p>每月每天每偶数小时的20分执行<code>20 0-23/2 * * * ls</code></p></li></ul><p>这样，就可以把需要定期执行的操作写成一个脚本，然后交给crontab来执行了，这样真的方便。真的是，懒惰是第一生产力。我才发明这个的人肯定是一个很懒的人。让电脑帮助人来定期执行一些任务，不会忘记，不会出错，严格执行。这不正是机器比人优越的地方吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 Linux 定时任务命令 &lt;code&gt;crontab&lt;/code&gt; 的使用&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://maneback.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- 情侣牵手</title>
    <link href="http://maneback.github.io/2021/couple-holding/"/>
    <id>http://maneback.github.io/2021/couple-holding/</id>
    <published>2021-02-24T02:51:51.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 <a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">Leetcode-765</a></p><a id="more"></a><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105405.png" alt="image-20210224105405609"><figcaption aria-hidden="true">image-20210224105405609</figcaption></figure><h4 id="解题思路">解题思路</h4><p>对于一堆坐错位置的情侣的集合，只要按照首位相连环路交换位置即可，此种交换位置的方法一定是最少的，次数为情侣数量-1。</p><p>因此下一步的目标即寻找互相独立的情侣的集合，以及每个集合的情侣数量。</p><p>可以用并查集的方法来解决。编号为<code>n, n+1</code> 的两个人组成情侣编号为 <code>n/2</code>，以此编号来作为节点执行并查集算法</p><p>然后利用 map 记录每个并查集集合的大小 <span class="math inline">\(size_i\)</span>，再返回 <span class="math inline">\(\sum{size_i-1}\)</span></p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105550.png" alt="image-20210224105550507"><figcaption aria-hidden="true">image-20210224105550507</figcaption></figure><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSwapCouple</span><span class="params">(row)</span>:</span></span><br><span class="line">    n = len(couple)//<span class="number">2</span></span><br><span class="line">    father = [i <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> father[x] ==x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">       f = find(father[x])</span><br><span class="line">        father[x] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        fx = find(x)</span><br><span class="line">        fy = find(y)</span><br><span class="line">        father[fx] = fy</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a, b = row[<span class="number">2</span>*n]//<span class="number">2</span>, row[<span class="number">2</span>*n+<span class="number">1</span>]//<span class="number">2</span></span><br><span class="line">        union(a, b)</span><br><span class="line">    dit = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            f = find(i)</span><br><span class="line">            dit[f]+=<span class="number">1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> dit.values():</span><br><span class="line">            ret+=(v<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 &lt;a href=&quot;https://leetcode-cn.com/problems/couples-holding-hands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-765&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="并查集" scheme="http://maneback.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>单调栈基础</title>
    <link href="http://maneback.github.io/2021/monotonic-stack/"/>
    <id>http://maneback.github.io/2021/monotonic-stack/</id>
    <published>2021-02-24T02:46:14.000Z</published>
    <updated>2021-08-14T03:25:34.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>与单调队列类似，对于单调栈来讲，我们不仅要满足栈的后入先出顺序，还要满足栈内元素的单调性，来存储当前栈内元素的对应最大值或最小值。</p><p>每次入栈时，先将栈顶所有小于当前值的元素移出，直到当前栈顶元素大于当前值，或者栈为空</p><p>例题：</p><p>每日温度</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814112531.png" alt="image-20210814111129834"><figcaption aria-hidden="true">image-20210814111129834</figcaption></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[<span class="number">-1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文介绍单调栈的基本原理和用法
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://maneback.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调队列基础</title>
    <link href="http://maneback.github.io/2021/monotonic-queue/"/>
    <id>http://maneback.github.io/2021/monotonic-queue/</id>
    <published>2021-02-24T02:30:35.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单调队列是一个特殊的队列，除满足队列先进先出的特点外，队列内的元素根据需要，还满足单调递增或单调递减。</p><p>以单调递增队列为例：当我们想队尾添加元素<code>x</code>时，为了保持单调性，要把当前队尾所有小于<code>x</code> 的元素从队列中移出，直到队列为空，或是找到了比<code>x</code> 大的元素。这样，单调队列头部始终保存的是当前队列内的最大值。</p><p>当我们在队列内移除元素时，若当前移除的元素与单调队列头部元素相等，说明此时此最大值在队列内已不存在，此元素也应被移除以维护队列内的最大值。</p><h4 id="例题">例题</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指offer - 59-II</a></p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224104022.png"></p><h4 id="代码示例">代码示例</h4><p>在这里，我们用一个数组（双向队列）<code>self.que</code> 保存所有的队列元素，<code>self.max_</code> 保存遇到的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.que = collections.deque()</span><br><span class="line">        self.max_= collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.max_:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.max_[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.que.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.max_ <span class="keyword">and</span> self.max_[<span class="number">-1</span>]&lt;value:</span><br><span class="line">            self.max_.pop()</span><br><span class="line">        self.max_.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.que:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = self.que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.max_[<span class="number">0</span>] == self.que[<span class="number">0</span>]:</span><br><span class="line">            self.max_.popleft()</span><br><span class="line">        self.que.popleft()</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      介绍单调队列的基本原理与用法
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调队列" scheme="http://maneback.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 区间合并</title>
    <link href="http://maneback.github.io/2021/merge-intervals/"/>
    <id>http://maneback.github.io/2021/merge-intervals/</id>
    <published>2021-02-24T02:06:25.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接： <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">Leetcode-56</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100900.png"></p><h4 id="思路">思路</h4><p>如果我们按照区间起始位置将所有区间排序，那么可合并的区间在排序后的数组中是连续的。如下图：相同颜色的区间可以被合并。</p><p>这样的话只一次遍历区间，并判断每个区间能不能与前一个区间合并。</p><p>判断一个区间能不能与前面的区间合并：只需要比较当前区间的起始与前一个区间（可能是已经合并过的区间）的结束位置的大小。</p><p>若当前区间在前一个区间结束前开始，则可以合并。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100018.png"></p><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(intervals)</span>:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="comment"># cannot be merged</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> inter[<span class="number">0</span>]&gt;merged[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 此区间成为一个新的区间</span></span><br><span class="line">            merged.append(inter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可以合并，取两个区间结束点较大的一个</span></span><br><span class="line">            merged[<span class="number">-1</span>][<span class="number">1</span>] = max(merged[<span class="number">-1</span>][<span class="number">1</span>], inter[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-56&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- unique binary search trees II</title>
    <link href="http://maneback.github.io/2021/longest-turbulent-subarray/"/>
    <id>http://maneback.github.io/2021/longest-turbulent-subarray/</id>
    <published>2021-02-09T03:02:50.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 ： <a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">Leetcode-978</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210209110647.png"></p><h4 id="解题思路">解题思路</h4><p>最长湍流子数组，形象地描述就是数组中的一个子数组，连续数字大小交替变化，我们把这种交替变化用 <strong>上升 下降</strong> 表示，如果<code>arr[-1]&lt;arr[-2]</code> 则称下降序列，如果 <code>arr[-1]&gt;arr[-2]</code> 则称上升序列，即用最后一个变化方向代表整个序列的变化方向。</p><p>考虑动态规划的算法，找到如何描述状态以及状态转移方程。用 <code>dp[i][0]</code> 表示以 <code>num[i]</code> 结尾的上升序列的长度；用<code>dp[i][1]</code> 表示以<code>num[i]</code> 结尾的下降序列的长度。<strong>考虑到上升序列去掉最后一个数字之后成为下降序列，下降序列去掉最后一个数字之后成为上升序列。</strong></p><p>然后我们考虑当前状态 <code>dp[i][0], dp[i][1]</code> 与下一个数组<code>num[i+1]</code> 之间的大小关系：</p><ul><li>如果 <code>num[i+1]&gt;num[i]</code> 则可以把<code>num[i+1]</code>添加到下降序列最后， 成为上升序列；而下降序列长度为1（因为连续两个下降方向）。</li><li>如果 <code>num[i+1]&lt;num[i]</code> 则可以把<code>num[i+1]</code>添加到上升序列最后， 成为下降序列；而上升序列长度为1（因为连续两个上升方向）。</li><li>如果<code>num[i+1]=num[i]</code> 则上升序列和下降序列的长度均变为 1。</li></ul><p>然后从两个数组中找到最长的那个子数组。</p><p>有了状态表示和状态转移方程，就可以写代码解题了。</p><h4 id="示例代码">示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxTurbulenceSize</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (arr[i]&gt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">0</span>])</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 ： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-turbulent-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-978&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>VScode 快捷键</title>
    <link href="http://maneback.github.io/2021/vscodeshortcut/"/>
    <id>http://maneback.github.io/2021/vscodeshortcut/</id>
    <published>2021-01-17T13:15:35.000Z</published>
    <updated>2021-01-17T13:18:53.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol type="1"><li>多行编辑<ul><li>鼠标+ <code>Alt+Shift</code> 按键选择，此方式只能选择连续竖列的对应位置不可随意插入光标位置，且不可间隔列</li><li><code>Shift+Ctrl</code> 数列选择, 可以在多个地方插入光标。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      记录常用的 VScode 快捷键
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="VScode" scheme="http://maneback.github.io/tags/VScode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 必要的插件</title>
    <link href="http://maneback.github.io/2021/installed-plugin/"/>
    <id>http://maneback.github.io/2021/installed-plugin/</id>
    <published>2021-01-05T09:53:18.000Z</published>
    <updated>2021-01-18T11:54:00.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="基础环境及必要插件">基础环境及必要插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save  ##wenti</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save ##</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><h4 id="在hexo-博客中插入图片">在hexo 博客中插入图片。</h4><p>先安装插件 <code>hexo-asset-image</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli --save</span><br><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>第一种最简单的方法是使用图床，但是之前折腾过一段时间使用 PicGO +github 图床，但是稳定，后放弃。改用 hexo 自带的资源文件夹。</p><p>第二种方法是启用 assert 资源文件夹，但是这个东西很不智能。当你在 markdown 文档引用图片（不管是相对路径还是绝对路径）都能在文档中显示，但是渲染成 HTML 文件时，就会路径出错了。要用这个新的插件 <code>hexo-asset-image</code> 。</p><h4 id="在-hexo-博客中正常显示-latex-公式">在 hexo 博客中正常显示 latex 公式</h4><p>hexo 竟然对 latex 公式的支持这么不智能。唉，绝了。</p><p>更换 renderer。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall hexo-renderer-marked</span><br><span class="line"><span class="built_in">npm</span> install hexo-renderer-pandoc</span><br></pre></td></tr></table></figure><p>安装完 <code>hexo-render-pandoc</code> ，它在运行 <code>hexo s</code> 命令时会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR][hexo-renderer-pandoc] pandoc exited with code 9: pandoc: Unknown extension: smart</span><br></pre></td></tr></table></figure><p>这时需要把 <code>node_modules\hexo-renderer-pandoc\index.js</code> 文件中的这个东西</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [ <span class="string">'-f'</span>, <span class="string">'markdown-smart'</span>+extensions, <span class="string">'-t'</span>, <span class="string">'html-smart'</span>, math]</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [ <span class="string">'-f'</span>, <span class="string">'markdown'</span>+extensions, <span class="string">'-t'</span>, <span class="string">'html'</span>, math]</span><br></pre></td></tr></table></figure><p>参考来源 <a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/36#issuecomment-555134526" target="_blank" rel="noopener">hexo-renderer-pandoc issues36</a></p>]]></content>
    
    <summary type="html">
    
      配置环境要用到的插件。
    
    </summary>
    
      <category term="Blog" scheme="http://maneback.github.io/categories/Blog/"/>
    
    
      <category term="blog" scheme="http://maneback.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="http://maneback.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- unique binary search trees II</title>
    <link href="http://maneback.github.io/2020/unique-binary-search-trees-ii/"/>
    <id>http://maneback.github.io/2020/unique-binary-search-trees-ii/</id>
    <published>2020-06-16T03:39:50.000Z</published>
    <updated>2021-08-14T03:44:59.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="题目描述">题目描述</h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p><p>0&lt;=n&lt;=8</p><h4 id="解题思路">解题思路</h4><p>对于一个二叉搜索树中的任一个节点来讲，其左子树的所有节点的值都小于该节点，其右子树的所有节点的值都大于该节点。</p><p>对于一个递归的问题，我们只考虑每一步应该做什么，顺序是什么，应该返回什么。</p><p>在每一步中，我们只考虑构建一棵子树，然后把子树返回给上一节点。</p><p>假设某一步中我们以一个区间<code>[start, end]</code> 来构造二叉搜索树，那么对于任意的 <code>i, start&lt;=i&lt;=end</code>， 可以以<code>i</code>为根节点来开始构造二叉搜索树，它的左子树则是以区间<code>[start, i-1]</code>构造的二叉搜索树，它的右子树是以区间<code>[i+1, end]</code> 构造的二叉搜索树，就这样递归地构造即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        node = Treenode(start, i)</span><br><span class="line">        lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">        rc = dfs(i+<span class="number">1</span>, end)</span><br></pre></td></tr></table></figure><p>但是对于区间 <code>[start, i-1]</code> 和<code>[i+1, end]</code>构造的左右子树，可能不止为1， 然而其可以任意地组合，这样，我们用一个数组保存以<code>[start， end]</code>构造的所有子树，然后再将其返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start&gt;end:</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">None</span>, ]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        node = Treenode(start, i)</span><br><span class="line">        lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">        rc = dfs(i+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lc:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rc:</span><br><span class="line">                node.left = l</span><br><span class="line">                node.right = r</span><br><span class="line">                res.append(node)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这样，我们就完成了代码的书写。</p><h4 id="解题代码">解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">None</span>, ]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">            node = Treenode(start, i)</span><br><span class="line">            lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">            rc = dfs(i+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> lc:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> rc:</span><br><span class="line">                    node.left = l</span><br><span class="line">                    node.right = r</span><br><span class="line">                    res.append(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">   <span class="keyword">return</span> dfs(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      LeetCode-95
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="tree" scheme="http://maneback.github.io/tags/tree/"/>
    
      <category term="动态规划" scheme="http://maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- binary tree maximum path sum</title>
    <link href="http://maneback.github.io/2020/binary-tree-maximum-path-sum/"/>
    <id>http://maneback.github.io/2020/binary-tree-maximum-path-sum/</id>
    <published>2020-06-15T13:04:57.000Z</published>
    <updated>2021-03-17T11:03:01.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>题目链接</strong>： <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><h4 id="题目描述">题目描述</h4><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><h4 id="解题思路">解题思路</h4><p>首先，这是一道非常标准的树形结构搜索的问题，对于树结构相关的问题，都可以用深度优先搜索或广度优先搜索的方法来解决，此题也不例外。只要考虑好在每个节点上做什么操作、在 child 节点上做什么操作，以及是先序、中序还是后续就行了。</p><p>关于这个题，很明显是后序。因为你需要找到当前 node 节点的子节点的路径长，才能确定通过当前 node 节点的路径长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">       <span class="comment"># pass</span></span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br><span class="line">    <span class="comment"># do sth to node</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">#path.</span></span><br></pre></td></tr></table></figure><p>对于这个问题，其路径可以不经过 root 节点，那么对于最长路径中的任意一个节点 n，可选的操作有四种：①从 n 的父节点连接 n 到 n 的左子树；②从 n 的父节点连接 n 到 n 的右子树；③从 n 的左子树连接到 n 连接到 n 的右子树；④最大路径从 n 点结束，包括最上的点和最下的点两种情况。</p><p>我们用全局变量 <code>path</code> 表示当前的全局最优解。</p><p>对于前两种情况，到目前为止我们只求得了或者说是遍历过了最长路径的部分，因此这一部分要把经过该节点的子路径的长度返回给父节点继续计算。其中除了情况一和二之外，还有一种就是情况四中的最大路径最下从当前节点结束：即它的所有子树的最大路径都是负值。因此我们要针对这三种情况计算局部最优值。</p><p>对于情况三，在得到了左右子树的最大路径值后，都能直接计算出该情况的解，因此此时直接将其与全局最优解比较。此外还可能其其中一个子树的最大子路径值为负数，且父节点的最大子路径值也为负数，即最大路径最上从当前节点结束，都要和全局最优解比较。</p><p>具体代码如下：</p><h4 id="解题代码">解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.path = <span class="number">-1000000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">           dl = dfs(node.left)</span><br><span class="line">            dr = node.right</span><br><span class="line">            <span class="comment"># local max</span></span><br><span class="line">            local_max = max(node.val, node.val+dl, node.val+dr)</span><br><span class="line">            self.path = max(node.val+dl+dr, local_max, self.path)</span><br><span class="line">            <span class="keyword">return</span> local_max</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.path</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      LeetCode-124
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="tree" scheme="http://maneback.github.io/tags/tree/"/>
    
      <category term="BFS&amp;DFS" scheme="http://maneback.github.io/tags/BFS-DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- subsets</title>
    <link href="http://maneback.github.io/2020/subset/"/>
    <id>http://maneback.github.io/2020/subset/</id>
    <published>2020-06-09T00:38:42.000Z</published>
    <updated>2021-01-04T13:36:59.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>原题链接：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p><a id="more"></a><h5 id="题目描述">题目描述：</h5><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><h5 id="示例">示例：</h5><blockquote><p>输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]</p></blockquote><h5 id="解法">解法：</h5><p>本题是非常经典的回溯法解决的题目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subset</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(first=<span class="number">0</span>, curr=[])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(curr)==k:</span><br><span class="line">            output.append(curr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">            curr.append(nums[i])</span><br><span class="line">            backtrack(i+<span class="number">1</span>, curr)</span><br><span class="line">            curr.pop()</span><br><span class="line">    output = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">        backtrack()</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode-cn.com/problems/subsets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/subsets/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="backtrack" scheme="http://maneback.github.io/tags/backtrack/"/>
    
  </entry>
  
  <entry>
    <title>论文解读|点云深度学习方法--PointNet</title>
    <link href="http://maneback.github.io/2020/pointnet/"/>
    <id>http://maneback.github.io/2020/pointnet/</id>
    <published>2020-05-19T10:49:03.000Z</published>
    <updated>2021-03-17T11:03:01.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation [CVPR 2017]</p><a id="more"></a><blockquote><p>论文解读系列第①篇</p></blockquote><p>今天带来的是 CVPR 2017 的一篇文章 PointNet。这片文章可以说是深度学习直接处理原始点云数据 (raw point cloud) 的开篇之作。目前在 Google Scholar 上面查到的引用量已经超过了 2000 次。</p><h2 id="一背景">一、背景</h2><p>先来看一看点云与深度学习结合的问题。近年来，深度学习方法取得了广泛的关注和应用，在图像、语音、文字等领域都取得了很好的应用成果。而点云是一种新型的 3D 空间的数据表示格式。它一般以一个四维向量 (x, y, z, i) 表示一个点。其中， (x, y, z) 是空间中的三维坐标，而 i 表示的是该点的反射强度。</p><p>当 2D 图像输入到深度学习的网络中时，它是规则的数据，每个像素值的位置都可以以一个二维坐标来表示，且它在空间上是连续的表示，即相邻像素就是在图像中相邻的。而点云的表示方法有所不同。它是无序且非结构化的表示，只是一个由点的坐标构成的集合，而相邻点之间并没有这种空间的相邻关系。这就会造成如下面这样的结果：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102056.png"></p><p>如上图：一副点云由若干的点构成，但是同一副点云图像其中点的排列顺序可能会不同，当以两者分别输入卷积网络中时，无论对于分类任务还是对于目标检测任务来讲，会带来不同的结果。然而实际上二者表示的是同一个物体或内容。这显然不是我们想要的结果。</p><p>卷积网络需要结构化的输入，而点云的输入是非结构化的，这样就会导致卷积网络并不适用于点云数据，基于此，人们想出了两种预处理方式，来使点云成为结构化的输入。</p><ul><li><p>第一种方法是 multi-view 投影的方法。即以点云在多个视角的投影作为输入，用原来的 2D 图像的卷积网络来处理。</p></li><li><p>第二种方法是 voxelization 的方法，即把空间划分成离散的体素 (3D voxel)， 然后每个点按照坐标位置决定落到那个体素单元中。这样，就可以把原来无序的点云输入规则化。</p></li></ul><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102059.png"></p><p>但是这种预处理的方式肯定会造成一定的信息损失。</p><p>基于此问题，本文的作者就提出了 PointNet 神经网络来处理点云数据。设计了一种直接处理点云来提取特征的新型网络，很好地考虑了对于输入点<strong>排列顺序</strong>的不变性。以及网络对于输入点集小的扰动和数据破坏（丢失）也具有很好的鲁棒性。</p><h2 id="二网络结构">二、网络结构</h2><p>首先来总结一下点云数据的三个特征以及由此带来的问题：</p><ul><li><strong>Unordered</strong> ：点云在采集和存储是都是无序的，因此要求网络必须对一副点云所有可能的输入保持结果不变。</li><li><strong>Interaction among points</strong> ：点云中每个点都与其周围的若干点表示了一定的空间结果，但是在存储来讲，并不能表示出这种结构。</li><li><strong>Invariance under transformation</strong> ：点云表示了一定的三维结构，这要求网络的处理结果对于点云的旋转、转换等必须保持结果不变性。</li></ul><p>针对以上的问题，本文采取的方法是：在初始阶段，对点云中每个点都<strong>单独</strong>进行<strong>相同</strong>的处理，然后再应用一个对称函数(MaxPooling)来解决点集的无序性问题。</p><p><strong>PointNet 的网络结构如下：</strong></p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102102.png"></p><p>网络的输入即为一个 nx3 的向量，表示 n 个点的三维坐标。可以用于分类任务与分割任务。对于分类任务，输出结果为 k 个分类类别的得分；对于分割任务，输出结果为 n 个点逐个的所属分割部分的得分。</p><p>最重要的三个部分已在图中圈出：</p><ul><li>两个小型的 T-Net 网络用于学习一个坐标变换矩阵，并应于该坐标变换矩阵增强输入数据，使得网络对于输入的旋转等操作具有一定的不变性。</li><li>MaxPooling 操作，以对称函数解决点云输入的不变性。</li><li>Aggregation 操作，将全局特征拼接到每个点的特征后面，用于分类任务。</li></ul><p>首先，对于 nx3 的输入数据，先经过一个两层的 MLP ，提取得到每个点的 64 维特征，此外输入数据与特征数据分别经过 input transform 和 feature transform 操作进行增强。这样我们就得到了一个 nx64 的特征，每个点的特征以一个 64 维的向量表示。在此之后，再经过一个三层的 MLP 将 64 维的特征升到 1024 维。 然后经过 maxpooling 操作提取得到一个全局的 1024 维特征。然后输入到分类网络中用以分类。</p><p>对于如何解决无序性问题，使得模型能够不受输入的排列顺序的影响。那么作者提出了三种可能的解决方法：(1)是将输入按一个规范顺序排序。这个很显然是不可行的。(2)是将输入作为一个连续的序列来训练一个RNN，并通过所有可能的排序来增加训练数据。一方面，有研究表明在RNN中顺序确实是有影响的，不能被忽略；另一方面，当point clouds 数据集很大的时候，对所有的N!个排列都处理一次也是不现实的。(3)是采用对称函数。</p><p>下面来介绍一下对称函数。所谓对称函数，通俗来讲就是参数的输入顺序不会影响函数的结果。如加法、乘法等，都是非常常见且明显的对称函数，可以任意改变参数的顺序。对于 maxpooling 操作来讲，它当然也是对称函数，无论输入的 n 个点的排列顺序如何，在对 nx1024 维的特征应用 maxpooling 操作时，得到的结果永远都是一样的。</p><p>这样借用 maxpooling 函数的对称性，我们就可以无视输入的无序性。先对每个点单独地进行相同的操作，然后再应用对称函数提取全局特征就好了。形式上来讲，可以表示为： <span class="math display">\[f(x_1, x_2,...x_n)=g(h(x_1), h(x_2),...h(x_n))\]</span> 函数 <span class="math inline">\(f\)</span> 是作用在点集上的函数，函数 <span class="math inline">\(h\)</span> 是作用在单个点上的函数，而函数 <span class="math inline">\(g\)</span> 是一个作用在经过处理的点 <span class="math inline">\(h(x)\)</span> 上的对称函数，这样我们就可以用函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 来得到关于点集的操作 <span class="math inline">\(f\)</span> 。而相关的理论证明，将会在第四部分给出。</p><p>对于分割任务来讲，既要考虑全局的特征，又要考虑全局特征，所以做法便是将 1024 维的全局特征聚合到每一个 64 为的点特征之后，这样得到的特征就既包含了全局的信息，也包含了点的局部信息了，从而用于分割任务。</p><h2 id="三结果">三、结果</h2><p>在论文中，作者给出了 PointNet 网络在分类、部分分割与场景语义分割三项任务上的结果。</p><h3 id="分类">3.1 分类</h3><p>在 ModelNet40 数据集上分类的准确率如下：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102105.png"></p><p>在这项任务中，与 multi-view 与 voxel 的方法进行了对比。</p><h3 id="部分分割">3.2 部分分割</h3><p>所谓部分分割，就是对每个点生成一个类别标记：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102111.png"></p><p>在 ModelNet40 部分分割结果如下，评价指标为 IoU:</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102115.png"></p><h3 id="场景语义分割">3.3 场景语义分割</h3><p>场景语义分割任务与部分分割任务类似，也是为每个点分配一个类别标记，判断每个点属于哪个物体。数据集为 Stanford 3D semantic parsing data Set.</p><p>在这一项任务中，输入不在是三维向量，而是九维，包括 (三维坐标，RGB值，归一化后的三维坐标)。得到的结果如下：</p><h2 id="四理论分析">四、理论分析</h2><p>在这一章节中，给出一些理论上的分析。</p><h3 id="近似逼近性">4.1 近似逼近性</h3><p>首先，给出为什么可以用 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 来近似逼近函数 <span class="math inline">\(f\)</span>。</p><p>对于定义在集合上的连续函数 <span class="math inline">\(f\)</span> , 有如下的性质：</p><p><span class="math display">\[\begin{align}&amp;\chi = \{S:S\subseteq[0,1]^m and\; |S|=n \}\\&amp;f:\chi \to \mathbb{R},\mbox{ 是一个连续的集合函数。}\\&amp;\mbox{Hausdorff distance  } d_H(.,.) \mbox{ 定义元素之间的距离。}\\&amp; \forall\, \theta&gt;0, \exist  \,\delta&gt;0, for\;any\;S_1,S_2\in\chi:\\&amp;if\;\;d_H(S_1,S_2)&lt;\delta, then\;|f(S_1)-f(S_2)|&lt;\theta\end{align}\]</span></p><p>由于连续函数 <span class="math inline">\(f\)</span> 有了这个性质，那么我们就可以定义一个对称函数 <span class="math inline">\(g\)</span> ，是一个<span class="math inline">\(\gamma\)</span> 和 max的复合函数。使得函数 <span class="math inline">\(g\)</span> 作用于 <span class="math inline">\(h(x)\)</span> 之上的函数值与 <span class="math inline">\(f(S)\)</span> 之间的数值足够小。</p><p>换句话说，我们可以用这样一个作用于每一元素的函数 <span class="math inline">\(h\)</span> 以及一个对称函数 <span class="math inline">\(MAX\)</span> 来近似集合函数 <span class="math inline">\(f\)</span> 。</p><p><span class="math display">\[\begin{align}&amp;\forall \theta&gt;0,\;\exist \mbox{ 一个连续函数 }\;h\\&amp;\mbox{ 和一个对称函数 }\;g(x_1,...,x_n)=\gamma\circ MAX:\\&amp;\mbox{such that for any }\; S\in \chi :\\&amp;\bigg|f(S)-\gamma\bigg(MAX_{x_i\in S}\{h(x_i)\}\bigg)\bigg|&lt;\theta\\&amp; (x_1,...,x_n \mbox{ 是 }S\mbox{ 中的元素。})\end{align}\]</span></p><h3 id="稳定性分析">4.2 稳定性分析</h3><p>第二是全局特征维度的维度K对结果的影响，以及整个网络的鲁棒性分析。</p><p>首先令 <span class="math inline">\(u\)</span> 是由一个点集经过 <span class="math inline">\(h\)</span> 计算每个点，再进行最大池化，得到一个 k 维向量的函数，那么 <span class="math inline">\(f\)</span> 可以表示为 <span class="math inline">\(\gamma\)</span> 和 <span class="math inline">\(u\)</span> 的复合函数。</p><p>那么，对于任意一个点集 S，都存在另外两个点集 C 和 N ，使得在任意一个不小于 C 且不大于N 的点集 T，<span class="math inline">\(f(S) = f(T)\)</span>。即对于一个集合 <span class="math inline">\(S\)</span>, <span class="math inline">\(f(S)\)</span> 的函数值，只受到这个集合 <span class="math inline">\(C\)</span> 的影响，更多的点对于函数的结果并不起到作用。</p><p>b)说明C中点的个数不大于K。这个K就是特征的维度。因为我们在用 <span class="math inline">\(u\)</span> 做最大池化操作时，对于 K 维中的每一个，只会选择来自一个点的特征作为该位的最大值，也就是说 MAXPOOLING 操作只会选择 K 个起作用的点。</p><p>因此，maxpooling 时候的特征维度K会影响C，进而影响分类的准确率。</p><p>$$ <span class="math display">\[\begin{align}&amp; 令\; u: \chi\to\mathbb{R}^K\\&amp;u=MAX_{X_i\in S}\{h(x_i)\}\;\;即u由一组点生成一个K维的向量。\\&amp;f=\gamma\circ u,则有：\\&amp;(a)\;\forall S,\; \exist \mathcal{C}_s \,\mathcal{N}_S\subseteq\chi,\,f(S)=f(T)\;if\;\mathcal{C}_s\subseteq T\subseteq \mathcal{N}_S\\&amp;(b)\; |\mathcal{C}_S|\leq K\end{align}\]</span> $$</p><p><span class="math display">\[\begin{align}&amp;(a)式说明\;f(S)\;的函数值由一组关键点\mathcal{C}_S 决定\\&amp;且添加的噪声点只要不超过\mathcal{N}_S,对函数值不会产生影响。\\&amp;(b)式说明关键点的个数 |\mathcal{C}_S|存在上界,\\&amp;不大于K，即最大池化时特征的维数。\end{align}\]</span></p><p><span class="math display">\[称 \mathcal{C}_S 为\; critical\; point\; set,K\;为\;bottleneck\; dimension\]</span></p><p>上述证明说明了此网络对于输入中一些微小的扰动与离群点具有很好的鲁棒性，并不会很大程度上影响结果。</p><p>下面给出了一些点云输入的 $_S $ 和 <span class="math inline">\(\mathcal{C}_N\)</span> 集合可视化例子。可以看出经过这个网络提取出的 <span class="math inline">\(\mathcal{C}_S\)</span> 集合，大体上描绘了这个物体的大致轮廓。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102120.png"></p><p>下图是 maxpooling 的维度 K 对准确率的影响。横坐标是 K 设置的数值，纵坐标是分类的准确率。每条线是每个输入中点的数量。可以看到随着 K 的增加，准确率有所上升，但是当 K 到达 1000 左右时基本上就不再变了，所以本文中 K 的取值就是选择 1024 ，以达到效率与精确度的最好权衡。</p><h3 id="设计分析">4.3 设计分析</h3><p>在之前，提到过有三种方法解决无序性问题：排序、RNN、对称函数，现在给出这三种设计方法的效果对比：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102123.png"></p><p>可以看到对称函数操作的准确性最高，而在所考虑的三种对称函数中，maxpooling 的准确性又是其中最高的。</p><p>此外，我们提到过 T-Net 对齐网络的作用，在这里给出它的实际效果，可以看出它可以在一定程度上提高分类的准确率。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102125.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation [CVPR 2017]&lt;/p&gt;
    
    </summary>
    
      <category term="论文解读" scheme="http://maneback.github.io/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="点云" scheme="http://maneback.github.io/tags/%E7%82%B9%E4%BA%91/"/>
    
      <category term="深度学习" scheme="http://maneback.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="学习" scheme="http://maneback.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于微信的一件小事</title>
    <link href="http://maneback.github.io/2020/wechat-account/"/>
    <id>http://maneback.github.io/2020/wechat-account/</id>
    <published>2020-05-06T02:12:58.000Z</published>
    <updated>2021-03-17T11:03:01.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>首发于个人公众号<strong>不愿意透露姓名的松哥</strong>， <a href="https://mp.weixin.qq.com/s/wYHRxYCJoi1L6r0mJqV0uQ" target="_blank" rel="noopener">文章链接</a>， 文章略有修改。</p><p>我开始飘了，都开始写公众号文章了，都开始思考微信公众号的产品逻辑了，都开始分析评论公众号的种种优缺点了。</p></blockquote><p><strong>零</strong></p><p>最近，突然发现微信里面开始有了一些“小动作”。</p><p>比如文章底部开始有相关推荐，比如看一看里面开始带话题，比如信息流中开始有公众号推荐。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102151.jpg"></p><p><strong>一</strong></p><p>稍微思考一下微信的使用时间，基本上可以分为以下两部分：聊天刷朋友圈+公众号文章阅读。只要你的好友也还在用微信，你就不得不保证前者的使用时长。而后者呢，则是由公众号文章的质量决定的。</p><p>再看一看近来（其实也不太近了）微信其他的一些更新：公众号改为信息流的形式，增加浮窗的个数，越来越强化看一看的推荐，（还在测试中的？）付费阅读？以及上述的几个小细节。这些功能都是针对后者的优化，也就是为公众号服务的，而不是针对普通用户。</p><p>获取讯息是多数人的重要需求。如果公众号的这些创作者不再在微信中创作，就有可能去微博、去知乎、去B站等等，而普通用户这方面在微信花费的时间也会流失。</p><p>微信公众号只是平台，而不生产内容。给内容创作者以更好的体验和有效的激励（更多真实的关注和阅读量）、创造更好的生态与创作环境，留下好的创作者，留下好的内容，用户使用时长自然也会增长。而人的时间和精力也是有限的，在微信上“浪费”的时间更多了，留给其他应用的时间也就更少了。</p><p><strong>二</strong></p><p>微信公众号确实产生了许多高质量的文章，也有很多优质的账号。但是与其他的内容平台还是有许多的不足。比如公众号中禁止插入外部链接（真很难理解这么大的一个互联网公司的这种做法），公众号文章那（几乎等于）没有的分享功能，更不要说公众号这（近乎）残废的留言互动功能。</p><p>公众号系统是以<strong>账号</strong>为中心的，而之外的知乎和微博等，则更多的偏向以内容为中心，比如热榜、热搜的存在等等，这种形式的内容传播，是可以覆盖到其所有用户的。此外，在微博上，内容可以在用户之间任意地转发传播以及曝光；在知乎上，用户更关注的是问题与问题之下的回答与讨论，也就是内容本身，有时用户对于内容的产出者并不是关注太多。</p><p>而对于公众号来讲，其内容的传播链条很短，更何况也无法被常用的搜索引擎爬取（有几个人知道在哪里可以搜索公众号的文章呢？）。几乎没有办法借助微信官方的推荐等等，来增加自己的关注量。即使现在微信官方去出面，去强化看一看功能，增加优质内容的推荐曝光，但是这种也同样是基于微信好友关系，那么势必会影响其传播范围。与微博、知乎官方所使用的推荐算法的覆盖范围差远了。</p><p>因此在那之前，对于公众号自媒体来讲，增加关注量是一件很困难的事情，他们要在微博、知乎、博客等各种平台留下自己的账号、利用自己在其他地方的影响力来给自己增加关注。用户也只能在其他应用、或是好友分享的某一篇文章、或是公众号主们之间的互推来关注到一个高价值的公众号。</p><p>但是也不得不承认，优质公众号的用户粘性极高，你看到的内容完全是你自己的选择。公众号有更多“个人品牌”的属性在里面。对一个公众号产生了认同感，才会去持续关注，追热点蹭热度很难带来持久的关注增长。也正是因为公众号系统以<strong>账号</strong>为中心，其也特别适合那种专一于特定主题，目标群体明确的账号。点点关注不迷路。</p><p><strong>最后</strong></p><p>在知乎上，关于微信一些设计与功能的提问与讨论也有很多。但是该用微信的人还是在用，毕竟在这个领域完全没有拿得出手的竞争者。微信的用户数量实在是太庞大了，用户实际的使用场景实在是太多了，它在功能上有很多被人们吐槽的地方。</p><p>但是你要明白：微信它本身只是一个即时通讯类的软件，而不是一个什么都包了的软件。你所觉得的一些功能残缺，可能这并不是它当初所设想的使用场景。微信的日活超过十亿，有人用它聊天，有人用它办公，有人用它卖货，也有人用它发广告等等等等。</p><p>只要你想明白了这件事情，你就会明白它为什么对某些用户需求无动于衷。同时要考虑它做出某些改进的原因。</p><p>另外最近在微博上面也看到了这样一段话：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102158.jpg"></p><p>虽然主语讲的是微博，但是对微信来说也是同理。</p>]]></content>
    
    <summary type="html">
    
      我的第一篇微信公众号文章
    
    </summary>
    
      <category term="公众号文章" scheme="http://maneback.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="微信公众号" scheme="http://maneback.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
</feed>
