<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漠·然</title>
  
  <subtitle>Maneback&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maneback.github.io/"/>
  <updated>2021-08-16T09:01:30.357Z</updated>
  <id>http://maneback.github.io/</id>
  
  <author>
    <name>Maneback</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>select/poll/epoll的区别</title>
    <link href="http://maneback.github.io/2021/select-poll-epoll/"/>
    <id>http://maneback.github.io/2021/select-poll-epoll/</id>
    <published>2021-08-16T08:59:52.000Z</published>
    <updated>2021-08-16T09:01:30.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制来监视多个描述符，一旦某个描述符就绪（读或写），就能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>。在高并发服务器中，轮询I/O是最耗时间的操作之一。</p><h2 id="select">1. select</h2><p>select 的本质是通过设置或检查存放fd 标志位的数据结构进行下一步的操作，select的调用复杂度是线性的，每次以O(n)的时间遍历一遍所有的对象。它的缺点如下：</p><ul><li>对 socket 的扫描都是线性的，即每一个都要轮询一遍，效率低。当IO事件发生时，却不知道是哪个流或是哪几个流，只会无差异地轮询所有留，找出能进行读或写操作的流来。监视的流越多，需要的处理时间越长。</li><li>除了慢之外，单个进程所能监视的fd数量也会受到限制，单个进程所能打开的最大连接数量由<code>FD_SETSIZE</code> 宏定义。32位机器中默认1024个，64位机器中默认2048个。</li><li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ul><h2 id="poll">2.poll</h2><p>poll 本质上和select没有区别，也是通过轮询的方式来进行处理，只是用的存储结构不同。它是基于链表来存储的，所以与select相比没有最大连接数量的限制。但是它仍然需要把大量的fd数组复制于用户态和内核地址空间之间，而不论这些文件描述符是否就绪。开销随着fd的数量增加而线性增大。</p><h2 id="epoll">3.epoll</h2><p><strong>epoll可以理解为event poll</strong>，epoll会把哪个流发生了怎样的I/O事件通知我们。</p><p>epoll提供了三个函数，<code>epoll_create</code>,<code>epoll_ctl</code>和<code>epoll_wait</code>，<code>epoll_create</code>是创建一个epoll句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p><p>epoll 有两种触发机制： EPOLLLT 和 EPOLLET ，LT是默认的模式，ET是高速模式。</p><ul><li>LT模式下，只要这个fd还有数据可读，每次 <code>epoll_wait</code>都会返回它的事件，提醒用户程序去操作.</li><li>在ET模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。</li></ul><p>epoll使用“事件”的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似<code>callback</code>的回调机制来激活该fd，<code>epoll_wait</code>便可以收到通知。因此，epoll的这种机制，能够高效的处理更多的并发连接，而且性能不会随着连接数增加而下降。</p><p>优点：</p><ul><li>没有最大并发连接的限制。</li><li>不需要进行轮询，效率提升，也不会随着fd数量的增加而降低效率。只有活跃的fd才会调用<code>callback</code>函数。</li><li>内存拷贝，利用<code>mmap()</code> 文件映射内存加速与内核空间的消息传递，减少复制开销</li></ul><h2 id="总结">4.总结</h2><ol type="1"><li>支持最大连接数：<ul><li>select：由 <code>FS_SETSIZE</code> 宏定义，在32位的机器上，大小就是1024，同理64位机器上FD_SETSIZE为2048。</li><li>poll：poll采用链表存储，没有最大连接数量的限制。</li><li>epoll： 虽然连接数有上限，但是很大。</li></ul></li><li>fd增加后带来的IO 效率问题<ul><li>select/poll：因每次调用都要轮询所有的fd，因此效率会线性下降。</li><li>select：是根据每个fd上的回调函数实现的，只有活跃的fd才会调用callback。但是当所有socket都活跃的情况下，可能会有性能问题。</li></ul></li><li>消息传递机制<ul><li>select/poll：内核需要将消息传递到用户空间，需要内核拷贝动作。</li><li>epoll：通过内核和用户空间共享内存来实现。</li></ul></li></ol><p><strong>参考链接</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/272891398" target="_blank" rel="noopener">一文搞懂select、poll和epoll区别</a></li><li><a href="https://www.cnblogs.com/Anker/" target="_blank" rel="noopener">Dale工作学习笔记</a></li></ul>]]></content>
    
    <summary type="html">
    
      select/poll/epoll的区别
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://maneback.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://maneback.github.io/2021/java-reflection/"/>
    <id>http://maneback.github.io/2021/java-reflection/</id>
    <published>2021-08-16T03:25:11.000Z</published>
    <updated>2021-08-16T08:56:02.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="为什么需要反射机制">为什么需要反射机制</h3><p>Java反射机制是：在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有<strong>属性和方法</strong>；对于任意一个对象，都能够<strong>调用它的任意一个方法</strong>。这种动态获取的信息以及动态调用对象的方法的功能称为反射机制。</p><p>所以如果能够在运行时拿到Class对象，就可以生成java对象并进行调用。</p><p>反射赋予了jvm动态编译的能力。动态编译可以最大限度的体现Java的灵活性（多态）。否则类的元信息只能通过静态编译的形式实现（在编译期确定类型，绑定对象），而不能实现动态编译（在运行期确定类型，绑定对象）。也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译，在Java中就需要反射机制。</p><ul><li>情景一： 有的类无法使用 new 一个对象的方式来实例化。</li><li>情景二：有的类可以在用到时再动态加载到jvm中，这样可以减少jvm的启动时间，同时更重要的是可以动态的加载需要的对象（多态）。</li><li>情景三：避免将程序写死到代码中。</li></ul><p>反射的缺点：</p><ul><li>性能开销：由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。</li><li>破坏封装性： 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li>内部曝光： 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。</li></ul><h3 id="代码实现">代码实现</h3><p>首先构造一个类 Person 来实现反射，这个类是我们要通过反射来调用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gao.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">func3</span><span class="params">(<span class="keyword">int</span> x, String y)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"protected func3"</span>);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取class-对象">1. 获取class 对象</h4><p>应用反射的第一步是要拿到该类的静态属性<code>class</code> 然后通过拿到类的方法和属性。</p><p>共有三种方法获取：通过实例的方法、通过类的静态属性、通过字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        Class&lt;? extends Person&gt; c_by_obj = person.getClass(); <span class="comment">//方法1</span></span><br><span class="line">        Class&lt;Person&gt; c_by_class = Person.class; <span class="comment">// 方法2</span></span><br><span class="line">        Class&lt;?&gt; c_by_name = Class.forName(<span class="string">"com.gao.reflect.Person"</span>);<span class="comment">//方法3</span></span><br><span class="line">        System.out.println(c_by_class==c_by_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取构造函数并创建对象">2. 获取构造函数并创建对象</h4><p>之后我们都将通过字节码文件，来获取 class 对象。</p><p>可以由两种划分：</p><ul><li>私有构造函数/公有构造函数</li><li>单个构造函数/构造函数集合</li></ul><p>在获取单个带参构造函数的时候，需要指定参数个数和数据类型对应的字节码文件对象（Class）。</p><p>对于私有方法还可以通过<code>.setAccessible(true)</code> 来访问。</p><p>通过反射调用构造函数，是把实例对象和参数交给<strong>函数对象</strong>的<code>invoke</code> 来做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取构造方法</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"com.gao.pojo.reflect.Person"</span>);</span><br><span class="line">        <span class="comment">//返回包含构造对象数组（公共的）</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons =  cls.getConstructors();</span><br><span class="line">        <span class="comment">//返回包含构造对象数组（所有的）</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons_all =  cls.getDeclaredConstructors();</span><br><span class="line">        System.out.println(cons_all);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回指定的公共构造函数</span></span><br><span class="line">        <span class="comment">// 参数：表示要获取的构造方法的参数个数和数据类型对应的字节码文件对象（Class）</span></span><br><span class="line">        Constructor&lt;?&gt; con1 = cls.getConstructor(); <span class="comment">// 无参构造函数</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Object p = (Person) con1.newInstance(); <span class="comment">//Person p = new Person();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 带参构造方法    private Person(String name, int age, String address)</span></span><br><span class="line">        Constructor&lt;?&gt; con2 = cls.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        Object obj =  con2.newInstance(<span class="string">"name"</span>, <span class="number">30</span>, <span class="string">"xian"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//私有构造方法不能被在外部访问</span></span><br><span class="line">        <span class="comment">//暴力反射：</span></span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; con3 = cls.getDeclaredConstructor(String.class);</span><br><span class="line">        con3.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 暴力反射访问私有构造方法</span></span><br><span class="line">        Object ob = con3.newInstance(<span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取属性并赋值">3. 获取属性并赋值</h4><p>属性可以直接通过名字直接访问。</p><p>通过反射给属性赋值，是把对象和属性值交给 属性域的 <code>set</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mport java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类对象</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"com.gao.pojo.reflect.Person"</span>);</span><br><span class="line"></span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        Field[] all_fields = cls.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单个的属性</span></span><br><span class="line">        Field address_field = cls.getField(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; con = cls.getConstructor();</span><br><span class="line">        Object obj =  con.newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给成员变量的属性赋值</span></span><br><span class="line">        address_field.set(obj, <span class="string">"xian"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问成员方法">4. 访问成员方法</h4><p>同构造方法一样，也是通过 <code>invoke</code> 的函数来调用反射得到的成员方法。</p><p>对于有返回值的方法，<code>invoke</code> 会返回函数调用的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类对象</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"com.gao.pojo.reflect.Person"</span>);</span><br><span class="line">        Constructor&lt;?&gt; con = cls.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">        Method[] methods = cls.getMethods(); <span class="comment">// 所有公共方法和继承的方法</span></span><br><span class="line">        Method[] methods1 = cls.getDeclaredMethods(); <span class="comment">// 私有方法（不包括继承的方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参数的方法</span></span><br><span class="line"></span><br><span class="line">        Method func1 = cls.getMethod(<span class="string">"func1"</span>);</span><br><span class="line">        func1.invoke(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参的方法</span></span><br><span class="line">        Method fun2 = cls.getDeclaredMethod(<span class="string">"func2"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        fun2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        fun2.invoke(obj, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//带返回</span></span><br><span class="line">        <span class="comment">//参数 是参数类型</span></span><br><span class="line">        Method fun3 = cls.getMethod(<span class="string">"func3"</span>, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        fun3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = fun3.invoke(obj, <span class="number">30</span>, <span class="string">"tianjin"</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="越过泛型检查">5. 越过泛型检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//越过泛型检查</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class cls = list.getClass();</span><br><span class="line">        Method mthd = cls.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        mthd.invoke(list, <span class="string">"world"</span>);</span><br><span class="line">        System.out.println(list );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong>：</p><p><a href="https://blog.csdn.net/tongdanping/article/details/103252352" target="_blank" rel="noopener">为什么需要Java反射</a></p>]]></content>
    
    <summary type="html">
    
      介绍Java的反射知识
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://maneback.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合</title>
    <link href="http://maneback.github.io/2021/java-collections/"/>
    <id>http://maneback.github.io/2021/java-collections/</id>
    <published>2021-08-16T02:59:10.000Z</published>
    <updated>2021-08-16T08:57:01.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>集合提供了一个对象来在内部容纳若干其他的 Java 对象，并提供相应的访问接口。Java 的<code>java.util</code> 包主要提供了一下三种不同类型的集合：</p><ul><li><code>List</code> 有序列表的集合，可按插入顺序访问。，</li><li><code>Set</code> 确保不可以插入重复元素的集合。</li><li><code>Map</code> 通过 <code>key-value</code> 快速查找元素的集合。</li></ul><p>Java的集合设计有两个特点：一是支持泛型，可以限制插入到集合中元素的数据类型；二是实现了接口与类的分离，以上三种均为接口而非具体的实现类。并且可以通过统一的迭代器方式进行访问。</p><p><strong>我们尽量以接口而非具体的实现类来访问元素。</strong></p><p><strong>重要</strong> 以下遗留类不应该被继续使用：</p><p><code>Hashtable</code>, <code>Vector</code>, <code>Stack</code>, <code>Enumeration&lt;E&gt;</code>.</p><h3 id="list">List</h3><p>需要实现<code>equals</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; array2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; array = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//(index, elem)</span></span><br><span class="line">array.remove(<span class="number">1</span>);<span class="comment">//(elem)</span></span><br><span class="line"><span class="keyword">int</span> elem = array.get(<span class="number">1</span>)<span class="comment">//(index)</span></span><br><span class="line"><span class="keyword">int</span> n = array.size();</span><br></pre></td></tr></table></figure><h3 id="map">map</h3><ul><li><code>HashMap</code> 的 <code>key</code>必须实现<code>equals()</code> 和 <code>hashCode()</code> 方法。</li><li>有序 map 必须实现<code>Comparable</code> 接口；或者在声明时传入一个<code>Comparator</code> 接口，里面声明<code>compare</code> 函数，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无序map</span></span><br><span class="line">Map&lt;String, Integer&gt; mapper = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">mapper.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">mapper.containsKey(ch);</span><br><span class="line">mapper.get(key);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (String key : mapper.keySet());</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : mapper.entrySet());</span><br><span class="line"><span class="keyword">for</span>(String value: mapper.valueSet());</span><br><span class="line"><span class="comment">//有序map</span></span><br><span class="line">Map&lt;String, Integer&gt; order_map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="set">Set</h3><ul><li><p>只会存储 <code>key</code> 的值。</p></li><li><p>需要正确实现<code>equals()</code>和<code>hashCode()</code>方法。</p></li><li><p>有序的Set还要实现<code>Comparable</code> 接口； 或者在声明时传入一个<code>Comparator</code> 接口，里面声明<code>compare</code> 函数，</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无序Set</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"123"</span>);</span><br><span class="line">set.contains(<span class="string">"123"</span>);</span><br><span class="line">set.remove(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> n = set.size();</span><br><span class="line"><span class="comment">//有序</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="queue">Queue</h3><ul><li>实现类为 <code>LinkedList</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">int</span> n = que.size();</span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.add();</span><br><span class="line">que.remove();</span><br><span class="line">que.element();</span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offer();</span><br><span class="line">que.poll();</span><br><span class="line">que.peel();</span><br></pre></td></tr></table></figure><p>注意有两套方法，对应不同的情况。</p><h3 id="priorityqueue">PriorityQueue</h3><ul><li>放入的元素需要实现<code>Comparable</code>，或者提供一个<code>Comparator</code>对象来判断两个元素的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类与接口分离</span></span><br><span class="line">Queue&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.add();</span><br><span class="line">que.remove();</span><br><span class="line">que.element();</span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offer();</span><br><span class="line">que.poll();</span><br><span class="line">que.peek();</span><br></pre></td></tr></table></figure><h3 id="deque">Deque</h3><ul><li>deque 是用 LinkedList 实现的接口，赋予了不同的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.addLast(); <span class="comment">//addFirst</span></span><br><span class="line">que.removeLast(); <span class="comment">//removeFirst</span></span><br><span class="line">que.getLast(); <span class="comment">// getFirst</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offerLast(); <span class="comment">//offerFirst</span></span><br><span class="line">que.pollLast(); <span class="comment">//pollLast</span></span><br><span class="line">que.peekLast(); <span class="comment">//peekLast</span></span><br></pre></td></tr></table></figure><h3 id="stack">Stack</h3><ul><li>stack 是用Deque接口来模拟的，原来的stack被占用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stack.isEmpty();</span><br><span class="line">stack.pop();</span><br><span class="line">stack.push(ch);</span><br><span class="line">stack.peek()</span><br></pre></td></tr></table></figure><h4 id="继承关系">继承关系</h4><p>橙色为类，蓝色为接口。</p><p><code>List</code>， <code>Queue</code>， <code>Set</code>类</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816132257.png" alt="image-20210816132257321" style="zoom:80%;"></p><hr><p><code>Map</code> 类</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816164347.png" alt="image-20210816164347532" style="zoom:80%;"></p><p><strong>参考链接</strong></p><ul><li><a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java 集合的使用方式
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://maneback.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://maneback.github.io/2021/regx/"/>
    <id>http://maneback.github.io/2021/regx/</id>
    <published>2021-08-14T03:37:17.000Z</published>
    <updated>2021-08-16T09:03:05.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="正则表达式">正则表达式</h3><h4 id="限定符">1. 限定符</h4><p>限定符用来指定正则表达式的一个给定组件要出现多少次才能满足匹配，共有<code>*</code>、<code>?</code>、<code>+</code>、<code>{n}</code>、<code>{n,}</code>，<code>{n,m}</code>六种，他们的描述如下：（限定出现次数）</p><table><thead><tr class="header"><th>字符</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td>*</td><td style="text-align: left;">匹配前面的子表达式零次或多次，等价于{0,}</td></tr><tr class="even"><td>+</td><td style="text-align: left;">匹配前面的子表达式一次或多次，等价于{1,}</td></tr><tr class="odd"><td>？</td><td style="text-align: left;">匹配前面的子表达式零次或一次，等价于{0,1}</td></tr><tr class="even"><td>{n}</td><td style="text-align: left;">n是一个非负数，匹配确定的n次</td></tr><tr class="odd"><td>{n,}</td><td style="text-align: left;">至少匹配n次</td></tr><tr class="even"><td>{n,m}</td><td style="text-align: left;">最少匹配n次且最多匹配m次。注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p><strong>注意：</strong><code>*</code>和<code>+</code>都是贪婪的，他们会尽可能匹配多的文字，只有在它们后面加上一个<code>?</code>就可以实现非贪婪匹配。</p><h4 id="普通字符">2. 普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有的大小写字母、所有的数字、所有的标点和一些其他符号。</p><h4 id="非打印字符">3. 非打印字符</h4><h4 id="特殊字符">4. 特殊字符</h4><p>特殊字符是一些有特殊含义的字符。</p><table><thead><tr class="header"><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>$</td><td>匹配输入字符串的结尾位置</td></tr><tr class="even"><td>()</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</td></tr><tr class="odd"><td>*</td><td>匹配前面的子表达式零次或多次。</td></tr><tr class="even"><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr class="odd"><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪的限定符</td></tr><tr class="even"><td>.</td><td>匹配除换行符之外的任何单字符</td></tr><tr class="odd"><td>[</td><td>标记一个中括号表达式的开始</td></tr><tr class="even"><td>\</td><td>将下一个字符标记为或特殊字符、或原意字符、或向后引用、或八进制转义符。</td></tr><tr class="odd"><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，表示不接受该字符集合</td></tr><tr class="even"><td>{</td><td>标记限定符表达式的开始</td></tr><tr class="odd"><td>|</td><td>指明两项之间的一个选择</td></tr></tbody></table><p>当你想匹配表格中列举的特殊字符的话，请在该字符前面加上<code>\</code>。</p><h4 id="定位符">5. 定位符</h4><p>定位符使得能够将正则表达式固定到行首或行尾，还能创建出现在一个单词内，在一个单词开头或者结尾的表达式，</p><p>定位符用于描述字符串或单词的边界，<code>^</code>和<code>$</code>分别标记字符串的开始和结尾。<code>\b</code>描述单词的前或后边界，<code>\B</code>表示非单词边界。</p><p>定位符有：</p><table><thead><tr class="header"><th>定位符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>^</td><td>匹配输入字符串开始的位置。</td></tr><tr class="even"><td>$</td><td>匹配输入字符串结束的位置。</td></tr><tr class="odd"><td> 匹配一个单词边界，即字与空格之间的位置。</td><td></td></tr><tr class="even"><td></td><td>非单词边界匹配</td></tr></tbody></table><p><strong>注意：</strong> 不能将限定符和定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上的位置。</p><h4 id="选择">6. 选择</h4><p>用圆括号将所有的选择项括出来，相邻的选择项用|分隔，但用圆括号会使相关的匹配被缓存（<strong>什么是缓存？</strong>），因此可以放一个<code>?:</code>放在选择项前消除这种副作用。</p><h4 id="反向引用">7. 反向引用</h4><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。可以使用非捕获元字符<code>?:</code>, <code>?=</code>, <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p><h3 id="匹配规则">匹配规则</h3><h4 id="基本匹配模式">1. 基本匹配模式</h4><p>从最基本的开始。<strong>模式</strong> 是正则表达式的最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，也可以很复杂，如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="built_in">once</span></span><br><span class="line"><span class="built_in">once</span>$</span><br><span class="line">^<span class="built_in">once</span>$</span><br></pre></td></tr></table></figure><p>该模式包含一个特殊字符<code>^</code>，匹配那些以once开头的字符串。<code>$</code>匹配以该模式结尾的字符串。而当二者同时使用时，代表精准匹配一个模式。</p><p>如果一个模式不包括<code>^ $</code>， 那么它与任何包含该模式的字符串匹配，例如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure><p>与字符串</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There once was <span class="keyword">a</span> man <span class="built_in">from</span> NewYork</span><br><span class="line">Who kept all <span class="keyword">of</span> his cash <span class="keyword">in</span> <span class="keyword">a</span> bucket.</span><br></pre></td></tr></table></figure><p>都是匹配的。</p><h4 id="字符族">2. 字符族</h4><p>可以用方括号来表示字符族，如，以下元音字符族：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure><p>以及表示范围的字符族</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">a-z</span>] <span class="comment">//匹配所有的小写字母 </span></span><br><span class="line">[<span class="meta">A-Z</span>] <span class="comment">//匹配所有的大写字母 </span></span><br><span class="line">[<span class="meta">a-zA-Z</span>] <span class="comment">//匹配所有的字母 </span></span><br><span class="line">[<span class="meta">0-9</span>] <span class="comment">//匹配所有的数字 </span></span><br><span class="line">[<span class="meta">0-9\.\-</span>] <span class="comment">//匹配所有的数字，句号和减号</span></span><br></pre></td></tr></table></figure><p>这些字符族只表示一个字符。如我们要匹配又一个小写字母加一位数字组成的两位的字符串，可以用以下这个模式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">a-z</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure><p>这里的<code>^</code>表示字符串开头，但是在一组方括号中使用<code>^</code>时，表示“非”和“排除”的意思，即不能包含该字符如： <code>^[^0-9][0-9]$表示第一位不能为数字</code></p>]]></content>
    
    <summary type="html">
    
      正则表达式
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="正则表达式" scheme="http://maneback.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="http://maneback.github.io/2021/db-index/"/>
    <id>http://maneback.github.io/2021/db-index/</id>
    <published>2021-08-14T02:56:04.000Z</published>
    <updated>2021-08-16T08:59:13.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="mysql索引">MySQL索引</h1><h3 id="索引的数据结构">索引的数据结构</h3><p>MySQL的底层存储引擎支持 InnoDB 和 MyISAM 两种，而默认存储引擎 InnoDB 采用的是B+树来作为索引的存储结构。</p><p><strong>那么为什么 InnoDB 存储引擎会使用 B+ 树来存储数据</strong> ，而不是采用 <strong>B- 树</strong>、<strong>红黑树</strong> 或是 <strong>AVL 树</strong> 来存储索引？</p><h3 id="数据结构的比较">数据结构的比较</h3><p>MySQL需要把数据持久化到磁盘上，因此需要频繁地读取磁盘上的数据，因此磁盘IO的次数很大程度上决定了查询效率。</p><p>对于大规模数据的索引来讲， 红黑树和 AVL 的结构往往会导致 <strong>深度过大</strong> 而造成磁盘IO过于频繁导致效率低下。而B-树和B+树的特点是每一个层的节点数量更多，树的层数更小，这样查询的时候就能够减少磁盘IO的次数。</p><p>另外B-树的非叶子节点都存有数据域，这无疑增加了节点的大小，而减少了每一页中所能容纳的节点数量；而B+树只有叶子结点来存储数据，节点更小，磁盘IO更少。</p><p>除此之外，深入分析数据库索引和底层的存储结构能发现B-树和B+树更大也更重要的区别。</p><h3 id="数据库存储结构">数据库存储结构</h3><h4 id="b-树">B-树</h4><p>对于 InnoDB 来说，所有的数据都是以键值对（key-data）的方式存储的，主键索引和辅助索引在存储数据时会将 <code>id</code> 和 <code>index</code> 作为键，将所有列和 <code>id</code> 作为键对应的值。 这个key就是存储在B+树非叶子节点中的值。在B-树中除了键外，还会存储data值。</p><p>再提一次这句话： <strong>B-树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中。</strong></p><p>在B-树中，由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816090826.png" alt="image-20210816090826822" style="zoom:50%;"></p><p>如上：如果我要查找 【位于4到16之间的所有值】的时候，就需要：</p><ul><li>加载node1 所在的页</li><li>找到指向node2的指针，并加载所在页，遍历页面中的数据，发现还没找全；</li><li>回来加载node1所在的页，发现还没找全；</li><li>找到指向node3的指针，并加载所在也，遍历页面中的数据，完成查找。</li></ul><p>这样一来，每次都需要从根节点向下遍历所有子节点来查找。会经历多次磁盘IO。</p><h4 id="b-树-1">B+ 树</h4><p>B+ 树是数据库底层的真实数据存储结构。</p><p>而使用B+树，所有的节点都储存在叶子节点中，此外通过构建树的过程中， 还可以保证叶子节点中的数据都是有序的，所以我们还可以在叶子节点中增加一个（双向）的指针，来只想相邻节点。图中每个灰色节点都代表磁盘上存储数据的一个页。这样当出现跨页的时候，就不需要从根节点从上至下查找了，只需要根据指针找到下一页。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816092140.png" alt="image-20210816092140647" style="zoom:50%;"></p><h4 id="聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</h4><p><strong>聚簇索引</strong></p><p>在数据库中，我们可能会根据需要建立多个不同用途的索引，每个索引都是组成像上述B+树的结构，但是实际上在硬盘中只会存储一个数据文件。像上述图中这样把索引与数据建在一起的索引称为<strong>聚簇索引</strong>。</p><p><strong>聚簇索引默认建立在数据表的主键上。</strong></p><p><strong>非聚簇索引</strong></p><p>当再建立新的索引时，就不需要存储data文件了，而是只需要存储索引，这种索引与数据分离的就成为 <strong>非聚簇索引</strong> 。这时候每个叶子结点存储的不是data而是指向聚簇索引的key值，通过key值再反过来查找聚簇索引。也就是需要二次查找。</p><p><strong>覆盖索引</strong></p><p>当一个语句检索的列只包含建立非聚簇索引的列及主键，这样非聚簇索引中就包含了我们需要的全部数据项，不用再去二次查找聚簇索引了。</p><h2 id="问题">问题</h2><ol type="1"><li>为什么主键通常建议使用自增id</li></ol><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，就需要不断地调整数据的物理地址、分页。</p><ol start="2" type="1"><li>默认聚簇索引</li></ol><p>聚簇索引<strong>默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。</p><ol start="3" type="1"><li>聚簇索引的劣势</li></ol><p><strong>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候</strong>。如果使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键。</p><ol start="3" type="1"><li>索引的优缺点</li></ol><ul><li>优点：加快查询速度</li><li>降低增删改速度，存储索引需要占用额外的空间。</li><li>每当数据库中有记录插入或删除时，索引都需要更新。如果有记录更新，任何搜索码属性受影响的索引也必须更新。</li></ul><h2 id="索引失效的情况">索引失效的情况</h2><p>在一定条件下，索引可能会失效，即无法通过索引来加速查询过程。</p><ul><li>where 子句中进行 NULL 判断</li><li>where 子句中使用 <code>!=, &lt;&gt;, not</code> 这样的判断</li><li>避免在 where 子句中使用 or， 如果其中一个字段没有索引的话，将放弃使用索引</li><li>避免在 where 子句中使用 <code>in</code></li><li>避免在 where 子句中<code>=</code>的左边使用表达式操作或者函数操作</li><li>避免在 where 子句中使用 ‘like’ 模糊查询</li><li>联合索引的最左原则，如联合索引为<code>&lt;a,b,c&gt;</code>, 则对 <code>a</code> 会使用联合索引，而<code>b,c</code> 则不会用到联合索引。</li></ul><h2 id="数据库存储引擎的对比">数据库存储引擎的对比</h2><ol type="1"><li><strong>事务支持</strong>： InnoDB 支持事务，MyISAM 不支持事务。</li><li><strong>外键支持</strong>： InnoDB 支持外键，而 MyISAM 不支持。</li><li><strong>索引支持</strong>： InnoDB 是聚集索引，MyISAM 是非聚集索引。</li><li><strong>锁支持</strong>： InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。</li><li><strong>恢复</strong>： 系统崩溃后，MyISAM恢复起来更困难。</li><li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li><li>innoDB所有的表在磁盘上保存在一个文件中；myISAM存储成三个文件。</li></ol><h4 id="如何选择">如何选择</h4><ol type="1"><li>如果要支持事务，选择 InnoDB。</li><li>如果大多是只是读查询，可以考虑MyISAM。如果既有读写也挺频繁，请使用InnoDB。</li></ol><p><strong>参考链接</strong></p><ul><li><a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/" target="_blank" rel="noopener">为什么 MySQL 使用 B+ 树</a></li><li><a href="https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html" target="_blank" rel="noopener">菜鸟教程</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      介绍数据库的索引结构
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="database" scheme="http://maneback.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务管理与锁</title>
    <link href="http://maneback.github.io/2021/db-lock/"/>
    <id>http://maneback.github.io/2021/db-lock/</id>
    <published>2021-08-12T02:57:18.000Z</published>
    <updated>2021-08-16T03:09:01.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数据库的事务与锁">数据库的事务与锁</h2><h3 id="事务及其性质">事务及其性质</h3><p>事务必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。</p><ol type="1"><li>原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；</li><li></li><li>一致性指的是事务的执行结果必须是使数据库从一个一致性状态变成另一个一致性状态，一致性和原子性是密切相关的；</li><li>隔离性指的是一个事务执行不能被其他事务干扰；</li><li>持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</li></ol><h4 id="事务隔离级别">事务隔离级别</h4><p>数据库的隔离级别可以分为：<strong>读未提交、读提交、可重复读和串行化</strong>。</p><p>在学习这里的时候，总感觉说得满头雾水的，怎么也不能理解，因为它又联系着三个现象： <strong>脏读、不可重复读、幻读</strong>。</p><p>当时很难理解隔离级别与现象之间的关系，现象可以理解为多个事务并发时候如不哦不加控制而导致的<strong>问题</strong>。隔离级别是为了避免其中的某种或某几种问题而设置的一种<strong>执行要求</strong> 或<strong>执行流程</strong>。</p><p>先来看现象：</p><p>我们假设有两个事务 A 和 B 在进行读写操作。</p><ul><li><p>脏读： B读到了A未提交的修改数据</p><p>A修改未提交—B读—A回滚 （A写的时候B读），这时候B读到的就是错误的数据。</p></li><li><p>不可重复读： 在两次读之间插入了另一个事务的修改操作，并提交，导致两次读取不一致。</p><p>（A读的时候B写）</p></li><li><p>幻读：在两次读取之间，出现了 INSERT 操作。</p><p>A读—–B插入—–A读。两次读取不一致。</p></li></ul><p>不可重复读与幻读之间的区别在于，A 两次读之间的差别，是由于 UPDATE 操作还是由 INSERT 操作引起的。</p><p>那么为了避免这些问题的发送，数据库设计了不同的事务隔离级别。</p><ul><li><p><strong>读未提交</strong>：一个事务可以读取另一个未提交事务的数据</p><p>这种情况下不会带来任何的隔离，三种情况都可能发生。</p></li><li><p><strong>读提交</strong>：一个事务要等另一个事务提交后才能读取数据（<strong>避免脏读</strong>）（给修改加锁禁止读）</p><p>B无法读到A未提交的修改，避免了脏读。</p></li><li><p><strong>可重复读</strong>：读取事务开始后，不允许修改（<strong>避免不可重复读</strong>）（读加锁禁止修改）</p><p>A在读取的时候，B只能读，不能改，可以保证A读取的过程的一致性。</p><p>但是只能锁住表中已有的行，而不能阻止其他事务的插入，无法避免幻读。</p></li><li><p><strong>串行化</strong>：每个事务完全串行化进行。（<strong>避免幻读</strong>）</p></li></ul><p>事务隔离级别和可能存在的问题如下：</p><table><thead><tr class="header"><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr class="odd"><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>读已提交</td><td></td><td>√</td><td>√</td></tr><tr class="odd"><td>可重复读</td><td></td><td></td><td>√</td></tr><tr class="even"><td>串行化</td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="锁">锁</h3><p>数据库锁出现的原因是为了处理并发问题。数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制。</p><p>数据库的锁根据不同的分类角度可以由不同的分类：</p><ul><li>从使用角度： 乐观锁与悲观锁</li><li>从数据库机制上：共享锁与排它锁</li><li>从锁的粒度上： 行级锁和表级锁</li></ul><h5 id="悲观锁与乐观锁">悲观锁与乐观锁</h5><ul><li>悲观锁：假定会发生并发冲突，在最整个数据处理过程中都将数据处于锁定的状态，</li><li>乐观锁：假设不会发生并发冲突，只有在提交时检查是否违反数据的完整性。</li></ul><h5 id="排它锁与共享锁">排它锁与共享锁</h5><ul><li>排它锁：也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。</li><li>共享锁：也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。</li></ul><h5 id="二阶段锁">二阶段锁</h5><p>每个事务分两个阶段提出加锁和解锁申请。最初处于加锁阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，并且不能再发出加锁请求。<strong>二阶段封锁并不会保证不发生死锁</strong>（如果请求锁的数据顺序不同）。</p><p>引入2PL是为了保证事务的隔离性，<strong>保证并发调度的准确性</strong>，多个事务在并发的情况下依然是串行的。</p><hr><h3 id="mvcc版本控制">MVCC版本控制</h3><p><strong>多版本并发控制（MVCC）</strong> 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。简单来说，<strong>MVCC</strong> 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。 是乐观锁的一种实现方式。</p><p>MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的创建版本号，一个保存了行的删除版本号。每开启一个新的事务，系统版本号都会自动递增，作为事务的版本号。</p><ul><li><p>MVCC读写不冲突不加锁，写写之间互相冲突需要加锁串联执行。（乐观锁）</p></li><li><p>select</p><p>只会查找版本号小于等于当前事务版本的数据行。这样保证事务读取的是之前已经存在的或是事务自身插入的。</p></li><li><p>insert</p><p>每插入新的一行，都保存当前的系统版本号作为行的版本号。</p></li><li><p>delete</p><p>为删除的每一行保存当前系统版本号作为行删除版本号。</p></li><li><p>update</p><p>插入一条新的记录，保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行作为删除版本号。</p></li></ul><h5 id="mvcc-解决了哪些问题">MVCC 解决了哪些问题</h5><ol type="1"><li>读写阻塞问题：MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率：读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li></ol><h5 id="快照读与当前度">快照读与当前度</h5><p><strong>快照读</strong>（SnapShot Read） 是一种一致性不加锁的读，是InnoDB并发如此之高的核心原因之一。</p><blockquote><p>这里的<strong>一致性</strong>是指，事务读取到的数据，要么是<strong>事务开始前就已经存在的数据</strong>，要么是<strong>事务自身插入或者修改过的数据</strong>。</p></blockquote><p>不加锁的简单的 SELECT 都属于<strong>快照读</strong>。</p><p>与 <strong>快照读</strong> 相对应的则是 <strong>当前读</strong>，<strong>当前读</strong>就是读取最新数据，而不是历史版本的数据。加锁的 SELECT 就属于当前读，例如：</p>]]></content>
    
    <summary type="html">
    
      介绍数据库的事务管理，锁以及MVCC
    
    </summary>
    
      <category term="基础知识" scheme="http://maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="database" scheme="http://maneback.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>排序算法汇总</title>
    <link href="http://maneback.github.io/2021/sortings/"/>
    <id>http://maneback.github.io/2021/sortings/</id>
    <published>2021-07-22T02:01:30.000Z</published>
    <updated>2021-08-16T08:58:06.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比总结常见的排序算法：</p><p>选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序</p><a id="more"></a><h4 id="排序算法">排序算法</h4><p>均默认为升序排列。</p><h5 id="选择排序">选择排序</h5><p>每次遍历数组，找到未排序中的最小元素，然后放到已排序的末尾位置，直到所有的元素均排序完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        print(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="冒泡排序">冒泡排序</h5><p>每次比较两个相邻元素，较大的元素每次移动一个位置，不断地冒泡到数组末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):</span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>]&gt;nums[j]:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="插入排序">插入排序</h5><p>每次选择一个数，在前面已排序好的序列中寻找该数字应该所在的位置，并向后移动部分已排序数字，将新数字插入到相应位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        idx = c</span><br><span class="line">        n = nums[c]</span><br><span class="line">        <span class="keyword">while</span> idx&gt;<span class="number">0</span> <span class="keyword">and</span> nums[idx<span class="number">-1</span>]&gt;n:</span><br><span class="line">            nums[idx] = nums[idx<span class="number">-1</span>]</span><br><span class="line">            idx-=<span class="number">1</span></span><br><span class="line">        nums[idx] = n</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="希尔排序">希尔排序</h5><p>希尔排序是对插入排序的改进版。在插入排序中， 数字每一次只能移动一个位置，而希尔排序是增加移动间隔，使较小的数字能更加快速地移动到队列头部。</p><p>具体算法描述如下：</p><ul><li><p>选择一个增量序列 <span class="math inline">\(g_1 &gt; g_2&gt;\cdots&gt; g_k\)</span> 且 <span class="math inline">\(g_k=1\)</span>。</p></li><li><p>对于每一个增量<span class="math inline">\(g\)</span>, 进行一次排序。</p></li><li><p>在每次排序中，按照间隔进行一次插入排序。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap=n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            i = c</span><br><span class="line">            <span class="keyword">while</span> i-gap&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i-gap]&gt;gap:</span><br><span class="line">                nums[i-gap], nums[i] = nums[i], nums[i-gap]</span><br><span class="line">                print(nums)</span><br><span class="line"></span><br><span class="line">                i-=gap</span><br><span class="line">        gap = gap//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="归并排序">归并排序</h5><p>归并排序是一种分治思想，先将数组分为子序列，缩小问题规模，让每个子序列各自有序，然后再将有序的子序列合并成一个完整数组。这样每一次的问题规模都变为原问题的 1/2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">            <span class="keyword">if</span> left[l]&lt;right[r]:</span><br><span class="line">                res.append(left[l])</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[r])</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">        res += left[l:]</span><br><span class="line">        res += right[r:]</span><br><span class="line">        print( res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = n//<span class="number">2</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><h5 id="快排">快排</h5><p>快排是选取一个哨兵位置，将小于哨兵的数据全部放到左边，将大于哨兵的数据全放到右边，然后再用相同的思想对左右两边继续排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        <span class="comment"># print(left, right)</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;=right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;nums[pivot]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=nums[pivot]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        quick(left, j<span class="number">-1</span>)</span><br><span class="line">        quick(j+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h5 id="计数排序">计数排序</h5><p>计数排序是开辟额外的空间来存储每个值的出现次数，然后再根据计数填充数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    _min = min(nums)</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    tmp_arr = [<span class="number">0</span>]*(_max-_min+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_arr[nums-_min]+=<span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> tmp_arr[j]==<span class="number">0</span>:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        nums[i] = j+_min</span><br><span class="line">        tmp_arr[j] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="堆排序">堆排序</h5><p>堆排序是使用了堆这个数据结构来进行的排序算法。把一维的数组想象成一个二叉树（堆）结构。</p><p>过程如下：</p><ol type="1"><li>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；</li><li>交换堆顶和最后一个元素，重新调整堆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, startops, endops)</span>:</span></span><br><span class="line">        pos = startops</span><br><span class="line">        childops = pos*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> childops&lt;endops:</span><br><span class="line">            rightops = childops+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightops&lt;endops <span class="keyword">and</span> nums[rightops]&gt;nums[childops]:</span><br><span class="line">                childops = rightops</span><br><span class="line">            <span class="keyword">if</span> nums[childops]&gt;nums[pos]:</span><br><span class="line">                nums[pos], nums[childops] = nums[childops], nums[pos]</span><br><span class="line">                adjust_heap(nums, childops, endops)</span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 从后往前即低向上</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n//<span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i,n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="基数排序">基数排序</h5><p>基数排序是针对数字每一位进行排序，从最低位开始排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    max_digit = len(str(_max))</span><br><span class="line">    buckList = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    div, mod = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckList[num%mod//div].append(num)</span><br><span class="line">        div *= <span class="number">10</span></span><br><span class="line">        mod *= <span class="number">10</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        print(buckList)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> buckList[j]:</span><br><span class="line">                nums[idx] = item</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            buckList[j] = []</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="对比">对比</h5><p>下面对排序算法做一个总结和对比。</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814104124.png" alt="image-20210814104124495"><figcaption aria-hidden="true">image-20210814104124495</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对比总结常见的排序算法：&lt;/p&gt;
&lt;p&gt;选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="排序算法" scheme="http://maneback.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://maneback.github.io/2021/beibao/"/>
    <id>http://maneback.github.io/2021/beibao/</id>
    <published>2021-06-15T11:22:56.000Z</published>
    <updated>2021-08-16T08:57:34.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="问题描述">问题描述</h3><p>对于背包问题，是求在具有容量（质量体积个数）约束的情况下，求所有商品满足约束的<strong>可行性解、最优解或解的个数</strong>。</p><h4 id="一般化描述">一般化描述</h4><p>本文关注于 0-1 背包问题，即：每个物品只有一个。</p><blockquote><p>物品总数 <span class="math inline">\(n\)</span></p><p>背包容量 <span class="math inline">\(W\)</span></p><p>物品质量 <span class="math inline">\(w_i\)</span></p><p>物品价值 <span class="math inline">\(p_i\)</span></p></blockquote><p>总质量约束为 <span class="math inline">\(W\)</span></p><p>物品的质量/成本为 <span class="math inline">\(w_i\)</span></p><p>物品的价值为 <span class="math inline">\(p_i\)</span></p><p>一般来讲，背包问题可以用动态规划问题来求解。对于背包问题有三类，即：求是否有可行解、最优解的值（价值最大化最小化）、求可行解的总个数。这三类问题对应了三种动态规划递推式。</p><p>好多问题都可以转化成背包问题来求解。</p><p>对于每一类问题，在这里我们用到动态规划数组 <code>dp[i][j]</code> 表示前 <span class="math inline">\(i\)</span> 商品放入容量为 <span class="math inline">\(j\)</span> 的背包时的解。</p><h3 id="问题分类">问题分类</h3><h4 id="最大价值">最大价值</h4><p>其转移方程如下： <span class="math display">\[f[i][j] = \cases{f[i-1][j]\\f[i-1][j-w_i]+p_i}\]</span> 初始化时，<code>dp[0][0]=0</code>。</p><p>第一种情况表示不放置第 <span class="math inline">\(i\)</span> 件商品，第二种情况表示放置，所以要给它腾出 <span class="math inline">\(w_i\)</span> 大小的空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(weights, profit, W)</span>:</span></span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>]* (W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(profit[i<span class="number">-1</span>], W+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i<span class="number">-1</span>]]+profit[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br></pre></td></tr></table></figure><p>在这里，我们看到，数组 <code>dp</code> 只会用到前面一行来更新，因此我们可以用一个一维的滚动数组来替代二维数组降低空间复杂度。同时在遍历容量时，会用到上一行中小于当前容量的数据，并不会用到大于当前容量的数据。因此要对一维数组对容量进行倒序遍历。</p><h4 id="可行解数量">可行解数量</h4><p>例题： <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494 目标和</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><blockquote><p>解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3</p></blockquote></blockquote><p>数组总和为 <code>sum</code>， 设添加 <code>+</code> 的数字和为 <code>positive</code>, 添加 <code>-</code> 的数字和为<code>negative</code>，则有一下方程组成立 <span class="math display">\[\cases{positve+negative = sum\\positive-negative = target}\]</span> 解方程组可得： <span class="math display">\[negative = \frac{sum-target}{2}\]</span> 即从数组中找到若干个数字和为 <code>negative</code>，求解的个数。</p><p>数字大小即为成本。</p><p><code>dp[i]</code> 表示和为 <code>i</code> 的解的个数。</p><p>在每一个数字开始循环时，<code>dp[i]</code>表示的既是上一轮的解的个数，又是当前轮不包含当前数组的情况下的解的个数。因此再加上包含当前数字的情况的解的个数，即为本轮的解。</p><p>初始化为<code>dp[0] = 1</code> 其他为0， 表示和为 0 有一种解，即什么都不选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> (s-target)%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">or</span> target&gt;s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] += dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        num = nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有赋值，下一行可能被用到，所以要从 0  开始遍历。</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j-num]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="是否存在可行解">是否存在可行解</h4><blockquote><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><blockquote><p>输入：[1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote></blockquote><p>同样，在每一个数组开始循环前，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPatrition</span><span class="params">(nums)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">   V = s//<span class="number">2</span></span><br><span class="line">    dp = [<span class="keyword">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = dp[v]|dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = s//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="keyword">False</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有被赋值，而前面的可能会被下一行用到，所以要从 0 开始赋值。把上一行的复制下来</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=nums[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i][j] | dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong></p><ul><li>背包九讲</li></ul>]]></content>
    
    <summary type="html">
    
      背包问题
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="背包问题" scheme="http://maneback.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://maneback.github.io/2021/slidingwindow/"/>
    <id>http://maneback.github.io/2021/slidingwindow/</id>
    <published>2021-06-14T13:29:42.000Z</published>
    <updated>2021-08-16T03:11:24.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="滑动窗口">滑动窗口</h4><p>滑动窗口可以用来解决一系列的数组问题，如最长无重复子数组（子串）、窗口最大值、满足某种条件的最长数组/最短数组。</p><p>感觉滑动窗口可以分为几类：</p><ol type="1"><li>定长窗口</li><li>寻找最长窗口</li><li>寻找最短窗口</li></ol><p>其主要的区别就在于：如何添加元素、合适进行窗口的合理性判断（即判断是否满足条件）以及更新答案。</p><p>对于定长窗口来讲，只要一直保持窗口的长度，每次增加一个元素并删除一个元素即可。</p><p>对于最长窗口来讲，每次删除一个最左元素，然后一直扩展右边界，直到不满足条件（窗口内仍满足条件），再更新答案。</p><p>对于最短窗口来讲，每次一直扩展右边界，直到不满足条件，然后再一直删除左元素，在循环中更新答案。（因为是寻找最短窗口，且在缩短左边界，因此这种情况下最后一次更新答案一定是最小值。）</p><h4 id="存在重复元素ii">存在重复元素II</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Leetcode-219</a></p><ul><li>题目描述</li></ul><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引<code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code>和<code>j</code> 的差的 绝对值 至多为 <code>k</code>。</p><ul><li>分析</li></ul><p>最初我是用一个dict 保存每个数字出现的次数，每次用滑动窗口添加元素删除元素，但是后来边界样例给我惊了，那就是当<code>k</code>的大小等于数组的长度的时候，是没有办法判断的。所以不能这样搞。</p><p>后来直接用字典记录每个数字最后出现的位置，再用位置去相减判断距离就好了。</p><ul><li>错误代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span> </span><br><span class="line">        windows = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> windows[nums[i]]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                windows[nums[i-k]]-=<span class="number">1</span></span><br><span class="line">                windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><ul><li>正确代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>       </span><br><span class="line">        dit = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> dit <span class="keyword">and</span> idx-dit[n]&lt;=k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dit[n] = idx</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h4 id="爱生气的书店老板">爱生气的书店老板</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">Leetcode-1052</a></p><ul><li>题目描述</li></ul><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210810140952.png" alt="image-20210810140952301"><figcaption aria-hidden="true">image-20210810140952301</figcaption></figure><ul><li>分析</li></ul><p>当已知有 <code>grumpy</code> 数组时候，对于不生气的情况，无论怎么怎么控制情绪，这部分满意的顾客总数是不会改变的，所以我们只需要考虑，老板控制了脾气之后，最大能 improve 多少挽回多少新的顾客。如果把 <code>grumpy</code> 与 <code>customer</code> 数组做 <code>element-wise</code> 乘积的话，就可以知道能够挽回的顾客数量，再进行 <code>X</code> 长度的子数组和取最大就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(customers)</span><br><span class="line">        level = sum([c*(<span class="number">1</span>-g) <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy)])</span><br><span class="line"></span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X):</span><br><span class="line">            inc+= customers[i]*grumpy[i]</span><br><span class="line">        max_inc = inc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X, n):</span><br><span class="line">            inc = inc+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X]</span><br><span class="line">            max_inc = max(inc, max_inc)</span><br><span class="line">        <span class="keyword">return</span> level + max_inc</span><br></pre></td></tr></table></figure><h4 id="无重复字符的最长子串">无重复字符的最长子串</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><ul><li>分析</li></ul><p><strong>依次枚举子串起始位置的左边界</strong>，记录以该位置开始子串的最长长度，每一次剔除一个最左字符串， 不断地扩展右边界。直到不满足条件位置，这时判断是否需要更新答案。</p><p><strong>窗口内永远是满足条件的子串，而非剔除直到不满足。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ccc = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">                ccc.remove(s[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk+<span class="number">1</span>&lt;n <span class="keyword">and</span> s[rk+<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ccc:</span><br><span class="line">                ccc.add(s[rk+<span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            ans = max(ans, rk+<span class="number">1</span>-i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="滑动窗口最大值">滑动窗口最大值</h4><ul><li>题目描述</li></ul><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><ul><li>分析</li></ul><p>只要用 滑动窗口 + 单调队列 即可解决，每次边界移动一个位置，向结果数组中添加一个元素。</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># init </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">        res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> que[<span class="number">0</span>]==nums[i-k]:</span><br><span class="line">                que.popleft()</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">            res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组">长度最小的子数组</h4><ul><li>题目描述</li></ul><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><ul><li>分析</li></ul><p>返回最小长度，依旧是扩充右边界，判断是否满足，缩减左边界</p><p>因为是最小长度，所以在缩减左边界时候更新答案</p><p>注意当退出内层 <code>while</code> 循环时，其实已经不满足和 <code>&gt;= target</code> 的条件了，所以要在 <code>while</code> 循环内部更新答案。窗口是在不断减小的，所以最后一次更新一定是最小的，不会影响结果的正确性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)==target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        wind_sum = <span class="number">0</span></span><br><span class="line">        res = n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;n:</span><br><span class="line">            wind_sum += nums[right]</span><br><span class="line">            <span class="keyword">while</span> wind_sum&gt;=target:</span><br><span class="line">                res = min(res, right-left+<span class="number">1</span>)</span><br><span class="line">                wind_sum-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==n+<span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      滑动窗口
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="滑动窗口" scheme="http://maneback.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 定时任务</title>
    <link href="http://maneback.github.io/2021/crontab/"/>
    <id>http://maneback.github.io/2021/crontab/</id>
    <published>2021-05-22T07:29:33.000Z</published>
    <updated>2021-08-14T03:55:24.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>介绍 Linux 定时任务命令 <code>crontab</code> 的使用</p><a id="more"></a><h1 id="linux-crontab">linux crontab</h1><p>linux crontab 是用来定期执行程序的命令。系统会默认启动此任务调度命令。</p><p>crond命令会每分钟定期检查是否有需要执行的工作，如果有的话，便执行该工作。</p><h5 id="语法">1.语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-e | -l | -r&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li><code>-e</code> 执行文字编辑器设定日程表</li><li><code>-r</code>删除目前的日程表</li><li><code>-l</code>列出目前的日程表</li></ul></li></ul><h5 id="时间格式">2. 时间格式</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f1</span> <span class="built_in">f2</span> <span class="built_in">f3</span> <span class="built_in">f4</span> <span class="built_in">f5</span> program</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>f1表示分钟，f2表示小时，f3表示一个月份中的第几天，f4表示月份，f5表示一个星期中的星期几。</li><li>某一项为*表示每分钟或每小时等都要执行程序</li><li>某一项为<code>a-b</code>时表示在a-b这段时间执行。</li><li>某一项为<code>*/n</code>时表示每隔n个单位执行。</li><li>某一项为<code>a,b,c</code>时表示取值为a，b，c时执行。</li></ul></li></ul><h5 id="实例">3. 实例</h5><p>说一千道一万都不如来几个例子来得实在。</p><ul><li><p>每月每天每小时的第0分钟<code>0 * * * * ls</code></p></li><li><p>在12月份，每天早上6点到12点，每隔3小时，每小时第10分钟执行<code>10 6-12/3 * 12 * ls</code></p></li><li><p>每周一到周五下午5:00执行<code>0 17 * * 1-5 ls</code></p></li><li><p>每月每天每偶数小时的20分执行<code>20 0-23/2 * * * ls</code></p></li></ul><p>这样，就可以把需要定期执行的操作写成一个脚本，然后交给crontab来执行了，这样真的方便。真的是，懒惰是第一生产力。我才发明这个的人肯定是一个很懒的人。让电脑帮助人来定期执行一些任务，不会忘记，不会出错，严格执行。这不正是机器比人优越的地方吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 Linux 定时任务命令 &lt;code&gt;crontab&lt;/code&gt; 的使用&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://maneback.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- 情侣牵手</title>
    <link href="http://maneback.github.io/2021/couple-holding/"/>
    <id>http://maneback.github.io/2021/couple-holding/</id>
    <published>2021-02-24T02:51:51.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 <a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">Leetcode-765</a></p><a id="more"></a><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105405.png" alt="image-20210224105405609"><figcaption aria-hidden="true">image-20210224105405609</figcaption></figure><h4 id="解题思路">解题思路</h4><p>对于一堆坐错位置的情侣的集合，只要按照首位相连环路交换位置即可，此种交换位置的方法一定是最少的，次数为情侣数量-1。</p><p>因此下一步的目标即寻找互相独立的情侣的集合，以及每个集合的情侣数量。</p><p>可以用并查集的方法来解决。编号为<code>n, n+1</code> 的两个人组成情侣编号为 <code>n/2</code>，以此编号来作为节点执行并查集算法</p><p>然后利用 map 记录每个并查集集合的大小 <span class="math inline">\(size_i\)</span>，再返回 <span class="math inline">\(\sum{size_i-1}\)</span></p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105550.png" alt="image-20210224105550507"><figcaption aria-hidden="true">image-20210224105550507</figcaption></figure><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSwapCouple</span><span class="params">(row)</span>:</span></span><br><span class="line">    n = len(couple)//<span class="number">2</span></span><br><span class="line">    father = [i <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> father[x] ==x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">       f = find(father[x])</span><br><span class="line">        father[x] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        fx = find(x)</span><br><span class="line">        fy = find(y)</span><br><span class="line">        father[fx] = fy</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a, b = row[<span class="number">2</span>*n]//<span class="number">2</span>, row[<span class="number">2</span>*n+<span class="number">1</span>]//<span class="number">2</span></span><br><span class="line">        union(a, b)</span><br><span class="line">    dit = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            f = find(i)</span><br><span class="line">            dit[f]+=<span class="number">1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> dit.values():</span><br><span class="line">            ret+=(v<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 &lt;a href=&quot;https://leetcode-cn.com/problems/couples-holding-hands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-765&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="并查集" scheme="http://maneback.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>单调栈基础</title>
    <link href="http://maneback.github.io/2021/monotonic-stack/"/>
    <id>http://maneback.github.io/2021/monotonic-stack/</id>
    <published>2021-02-24T02:46:14.000Z</published>
    <updated>2021-08-14T03:25:34.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>与单调队列类似，对于单调栈来讲，我们不仅要满足栈的后入先出顺序，还要满足栈内元素的单调性，来存储当前栈内元素的对应最大值或最小值。</p><p>每次入栈时，先将栈顶所有小于当前值的元素移出，直到当前栈顶元素大于当前值，或者栈为空</p><p>例题：</p><p>每日温度</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814112531.png" alt="image-20210814111129834"><figcaption aria-hidden="true">image-20210814111129834</figcaption></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[<span class="number">-1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文介绍单调栈的基本原理和用法
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://maneback.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调队列基础</title>
    <link href="http://maneback.github.io/2021/monotonic-queue/"/>
    <id>http://maneback.github.io/2021/monotonic-queue/</id>
    <published>2021-02-24T02:30:35.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单调队列是一个特殊的队列，除满足队列先进先出的特点外，队列内的元素根据需要，还满足单调递增或单调递减。</p><p>以单调递增队列为例：当我们想队尾添加元素<code>x</code>时，为了保持单调性，要把当前队尾所有小于<code>x</code> 的元素从队列中移出，直到队列为空，或是找到了比<code>x</code> 大的元素。这样，单调队列头部始终保存的是当前队列内的最大值。</p><p>当我们在队列内移除元素时，若当前移除的元素与单调队列头部元素相等，说明此时此最大值在队列内已不存在，此元素也应被移除以维护队列内的最大值。</p><h4 id="例题">例题</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指offer - 59-II</a></p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224104022.png"></p><h4 id="代码示例">代码示例</h4><p>在这里，我们用一个数组（双向队列）<code>self.que</code> 保存所有的队列元素，<code>self.max_</code> 保存遇到的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.que = collections.deque()</span><br><span class="line">        self.max_= collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.max_:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.max_[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.que.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.max_ <span class="keyword">and</span> self.max_[<span class="number">-1</span>]&lt;value:</span><br><span class="line">            self.max_.pop()</span><br><span class="line">        self.max_.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.que:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = self.que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.max_[<span class="number">0</span>] == self.que[<span class="number">0</span>]:</span><br><span class="line">            self.max_.popleft()</span><br><span class="line">        self.que.popleft()</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      介绍单调队列的基本原理与用法
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调队列" scheme="http://maneback.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 区间合并</title>
    <link href="http://maneback.github.io/2021/merge-intervals/"/>
    <id>http://maneback.github.io/2021/merge-intervals/</id>
    <published>2021-02-24T02:06:25.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接： <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">Leetcode-56</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100900.png"></p><h4 id="思路">思路</h4><p>如果我们按照区间起始位置将所有区间排序，那么可合并的区间在排序后的数组中是连续的。如下图：相同颜色的区间可以被合并。</p><p>这样的话只一次遍历区间，并判断每个区间能不能与前一个区间合并。</p><p>判断一个区间能不能与前面的区间合并：只需要比较当前区间的起始与前一个区间（可能是已经合并过的区间）的结束位置的大小。</p><p>若当前区间在前一个区间结束前开始，则可以合并。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100018.png"></p><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(intervals)</span>:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="comment"># cannot be merged</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> inter[<span class="number">0</span>]&gt;merged[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 此区间成为一个新的区间</span></span><br><span class="line">            merged.append(inter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可以合并，取两个区间结束点较大的一个</span></span><br><span class="line">            merged[<span class="number">-1</span>][<span class="number">1</span>] = max(merged[<span class="number">-1</span>][<span class="number">1</span>], inter[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-56&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- unique binary search trees II</title>
    <link href="http://maneback.github.io/2021/longest-turbulent-subarray/"/>
    <id>http://maneback.github.io/2021/longest-turbulent-subarray/</id>
    <published>2021-02-09T03:02:50.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 ： <a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">Leetcode-978</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210209110647.png"></p><h4 id="解题思路">解题思路</h4><p>最长湍流子数组，形象地描述就是数组中的一个子数组，连续数字大小交替变化，我们把这种交替变化用 <strong>上升 下降</strong> 表示，如果<code>arr[-1]&lt;arr[-2]</code> 则称下降序列，如果 <code>arr[-1]&gt;arr[-2]</code> 则称上升序列，即用最后一个变化方向代表整个序列的变化方向。</p><p>考虑动态规划的算法，找到如何描述状态以及状态转移方程。用 <code>dp[i][0]</code> 表示以 <code>num[i]</code> 结尾的上升序列的长度；用<code>dp[i][1]</code> 表示以<code>num[i]</code> 结尾的下降序列的长度。<strong>考虑到上升序列去掉最后一个数字之后成为下降序列，下降序列去掉最后一个数字之后成为上升序列。</strong></p><p>然后我们考虑当前状态 <code>dp[i][0], dp[i][1]</code> 与下一个数组<code>num[i+1]</code> 之间的大小关系：</p><ul><li>如果 <code>num[i+1]&gt;num[i]</code> 则可以把<code>num[i+1]</code>添加到下降序列最后， 成为上升序列；而下降序列长度为1（因为连续两个下降方向）。</li><li>如果 <code>num[i+1]&lt;num[i]</code> 则可以把<code>num[i+1]</code>添加到上升序列最后， 成为下降序列；而上升序列长度为1（因为连续两个上升方向）。</li><li>如果<code>num[i+1]=num[i]</code> 则上升序列和下降序列的长度均变为 1。</li></ul><p>然后从两个数组中找到最长的那个子数组。</p><p>有了状态表示和状态转移方程，就可以写代码解题了。</p><h4 id="示例代码">示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxTurbulenceSize</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (arr[i]&gt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">0</span>])</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 ： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-turbulent-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-978&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>VScode 快捷键</title>
    <link href="http://maneback.github.io/2021/vscodeshortcut/"/>
    <id>http://maneback.github.io/2021/vscodeshortcut/</id>
    <published>2021-01-17T13:15:35.000Z</published>
    <updated>2021-01-17T13:18:53.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol type="1"><li>多行编辑<ul><li>鼠标+ <code>Alt+Shift</code> 按键选择，此方式只能选择连续竖列的对应位置不可随意插入光标位置，且不可间隔列</li><li><code>Shift+Ctrl</code> 数列选择, 可以在多个地方插入光标。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      记录常用的 VScode 快捷键
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="VScode" scheme="http://maneback.github.io/tags/VScode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 必要的插件</title>
    <link href="http://maneback.github.io/2021/installed-plugin/"/>
    <id>http://maneback.github.io/2021/installed-plugin/</id>
    <published>2021-01-05T09:53:18.000Z</published>
    <updated>2021-01-18T11:54:00.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="基础环境及必要插件">基础环境及必要插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save  ##wenti</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save ##</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><h4 id="在hexo-博客中插入图片">在hexo 博客中插入图片。</h4><p>先安装插件 <code>hexo-asset-image</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli --save</span><br><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>第一种最简单的方法是使用图床，但是之前折腾过一段时间使用 PicGO +github 图床，但是稳定，后放弃。改用 hexo 自带的资源文件夹。</p><p>第二种方法是启用 assert 资源文件夹，但是这个东西很不智能。当你在 markdown 文档引用图片（不管是相对路径还是绝对路径）都能在文档中显示，但是渲染成 HTML 文件时，就会路径出错了。要用这个新的插件 <code>hexo-asset-image</code> 。</p><h4 id="在-hexo-博客中正常显示-latex-公式">在 hexo 博客中正常显示 latex 公式</h4><p>hexo 竟然对 latex 公式的支持这么不智能。唉，绝了。</p><p>更换 renderer。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall hexo-renderer-marked</span><br><span class="line"><span class="built_in">npm</span> install hexo-renderer-pandoc</span><br></pre></td></tr></table></figure><p>安装完 <code>hexo-render-pandoc</code> ，它在运行 <code>hexo s</code> 命令时会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR][hexo-renderer-pandoc] pandoc exited with code 9: pandoc: Unknown extension: smart</span><br></pre></td></tr></table></figure><p>这时需要把 <code>node_modules\hexo-renderer-pandoc\index.js</code> 文件中的这个东西</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [ <span class="string">'-f'</span>, <span class="string">'markdown-smart'</span>+extensions, <span class="string">'-t'</span>, <span class="string">'html-smart'</span>, math]</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [ <span class="string">'-f'</span>, <span class="string">'markdown'</span>+extensions, <span class="string">'-t'</span>, <span class="string">'html'</span>, math]</span><br></pre></td></tr></table></figure><p>参考来源 <a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/36#issuecomment-555134526" target="_blank" rel="noopener">hexo-renderer-pandoc issues36</a></p>]]></content>
    
    <summary type="html">
    
      配置环境要用到的插件。
    
    </summary>
    
      <category term="Blog" scheme="http://maneback.github.io/categories/Blog/"/>
    
    
      <category term="blog" scheme="http://maneback.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="http://maneback.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- unique binary search trees II</title>
    <link href="http://maneback.github.io/2020/unique-binary-search-trees-ii/"/>
    <id>http://maneback.github.io/2020/unique-binary-search-trees-ii/</id>
    <published>2020-06-16T03:39:50.000Z</published>
    <updated>2021-08-14T03:44:59.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="题目描述">题目描述</h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p><p>0&lt;=n&lt;=8</p><h4 id="解题思路">解题思路</h4><p>对于一个二叉搜索树中的任一个节点来讲，其左子树的所有节点的值都小于该节点，其右子树的所有节点的值都大于该节点。</p><p>对于一个递归的问题，我们只考虑每一步应该做什么，顺序是什么，应该返回什么。</p><p>在每一步中，我们只考虑构建一棵子树，然后把子树返回给上一节点。</p><p>假设某一步中我们以一个区间<code>[start, end]</code> 来构造二叉搜索树，那么对于任意的 <code>i, start&lt;=i&lt;=end</code>， 可以以<code>i</code>为根节点来开始构造二叉搜索树，它的左子树则是以区间<code>[start, i-1]</code>构造的二叉搜索树，它的右子树是以区间<code>[i+1, end]</code> 构造的二叉搜索树，就这样递归地构造即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        node = Treenode(start, i)</span><br><span class="line">        lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">        rc = dfs(i+<span class="number">1</span>, end)</span><br></pre></td></tr></table></figure><p>但是对于区间 <code>[start, i-1]</code> 和<code>[i+1, end]</code>构造的左右子树，可能不止为1， 然而其可以任意地组合，这样，我们用一个数组保存以<code>[start， end]</code>构造的所有子树，然后再将其返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start&gt;end:</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">None</span>, ]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        node = Treenode(start, i)</span><br><span class="line">        lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">        rc = dfs(i+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lc:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rc:</span><br><span class="line">                node.left = l</span><br><span class="line">                node.right = r</span><br><span class="line">                res.append(node)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这样，我们就完成了代码的书写。</p><h4 id="解题代码">解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">None</span>, ]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">            node = Treenode(start, i)</span><br><span class="line">            lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">            rc = dfs(i+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> lc:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> rc:</span><br><span class="line">                    node.left = l</span><br><span class="line">                    node.right = r</span><br><span class="line">                    res.append(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">   <span class="keyword">return</span> dfs(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      LeetCode-95
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="tree" scheme="http://maneback.github.io/tags/tree/"/>
    
      <category term="动态规划" scheme="http://maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- binary tree maximum path sum</title>
    <link href="http://maneback.github.io/2020/binary-tree-maximum-path-sum/"/>
    <id>http://maneback.github.io/2020/binary-tree-maximum-path-sum/</id>
    <published>2020-06-15T13:04:57.000Z</published>
    <updated>2021-03-17T11:03:01.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>题目链接</strong>： <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><h4 id="题目描述">题目描述</h4><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><h4 id="解题思路">解题思路</h4><p>首先，这是一道非常标准的树形结构搜索的问题，对于树结构相关的问题，都可以用深度优先搜索或广度优先搜索的方法来解决，此题也不例外。只要考虑好在每个节点上做什么操作、在 child 节点上做什么操作，以及是先序、中序还是后续就行了。</p><p>关于这个题，很明显是后序。因为你需要找到当前 node 节点的子节点的路径长，才能确定通过当前 node 节点的路径长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">       <span class="comment"># pass</span></span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br><span class="line">    <span class="comment"># do sth to node</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">#path.</span></span><br></pre></td></tr></table></figure><p>对于这个问题，其路径可以不经过 root 节点，那么对于最长路径中的任意一个节点 n，可选的操作有四种：①从 n 的父节点连接 n 到 n 的左子树；②从 n 的父节点连接 n 到 n 的右子树；③从 n 的左子树连接到 n 连接到 n 的右子树；④最大路径从 n 点结束，包括最上的点和最下的点两种情况。</p><p>我们用全局变量 <code>path</code> 表示当前的全局最优解。</p><p>对于前两种情况，到目前为止我们只求得了或者说是遍历过了最长路径的部分，因此这一部分要把经过该节点的子路径的长度返回给父节点继续计算。其中除了情况一和二之外，还有一种就是情况四中的最大路径最下从当前节点结束：即它的所有子树的最大路径都是负值。因此我们要针对这三种情况计算局部最优值。</p><p>对于情况三，在得到了左右子树的最大路径值后，都能直接计算出该情况的解，因此此时直接将其与全局最优解比较。此外还可能其其中一个子树的最大子路径值为负数，且父节点的最大子路径值也为负数，即最大路径最上从当前节点结束，都要和全局最优解比较。</p><p>具体代码如下：</p><h4 id="解题代码">解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.path = <span class="number">-1000000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">           dl = dfs(node.left)</span><br><span class="line">            dr = node.right</span><br><span class="line">            <span class="comment"># local max</span></span><br><span class="line">            local_max = max(node.val, node.val+dl, node.val+dr)</span><br><span class="line">            self.path = max(node.val+dl+dr, local_max, self.path)</span><br><span class="line">            <span class="keyword">return</span> local_max</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.path</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      LeetCode-124
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="tree" scheme="http://maneback.github.io/tags/tree/"/>
    
      <category term="BFS&amp;DFS" scheme="http://maneback.github.io/tags/BFS-DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- subsets</title>
    <link href="http://maneback.github.io/2020/subset/"/>
    <id>http://maneback.github.io/2020/subset/</id>
    <published>2020-06-09T00:38:42.000Z</published>
    <updated>2021-01-04T13:36:59.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>原题链接：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p><a id="more"></a><h5 id="题目描述">题目描述：</h5><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><h5 id="示例">示例：</h5><blockquote><p>输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]</p></blockquote><h5 id="解法">解法：</h5><p>本题是非常经典的回溯法解决的题目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subset</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(first=<span class="number">0</span>, curr=[])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(curr)==k:</span><br><span class="line">            output.append(curr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">            curr.append(nums[i])</span><br><span class="line">            backtrack(i+<span class="number">1</span>, curr)</span><br><span class="line">            curr.pop()</span><br><span class="line">    output = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">        backtrack()</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode-cn.com/problems/subsets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/subsets/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="backtrack" scheme="http://maneback.github.io/tags/backtrack/"/>
    
  </entry>
  
</feed>
