<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漠·然</title>
  
  <subtitle>Maneback&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/maneback/maneback.github.io/"/>
  <updated>2021-09-09T06:02:36.418Z</updated>
  <id>https://github.com/maneback/maneback.github.io/</id>
  
  <author>
    <name>Maneback</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/tree/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/tree/</id>
    <published>2021-09-09T05:31:55.000Z</published>
    <updated>2021-09-09T06:02:36.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>不同的二叉搜索树</p><p>有序链表转二叉树</p><p>二叉树展开成链表</p><p>填充每个节点的下一个右侧节点指针</p><p>具有所有最深节点的最小子树</p><p>二叉树的最近公共祖先</p><h4 id="不同的二叉搜索树">不同的二叉搜索树</h4><p>题目链接：</p><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">LeetCode-96</a></p><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">LeetCode-95</a></p><h5 id="题目描述">题目描述</h5><blockquote><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p></blockquote><h5 id="分析">分析</h5><p>这两个题基本上雷同，所以就放在一起了。</p><p>树嘛，由树一定要想到递归操作。对于任意一个整数<code>1&lt;=i&lt;=n</code>， 把它作为根节点都能来构造二叉搜索树，并递归地用<code>[1, i-1]</code>和 <code>[i+1, n]</code>来构造左右子树。当数组中只有一个数字或零个数字时，则说明到了叶子结点，停止构造，再返回给父节点。这是一个自底向上的过程，只有拿到了子树，才能构造当前节点，所以是一个后序遍历的过程。</p><p>对于数组<code>[l,r]</code>总结一下递归中每一步的操作：</p><ol type="1"><li>如果数组中只含有零个或一个元素，则直接返回一个空节点/叶子节点。</li><li>对于任一一个数字<code>l&lt;=i&lt;=r</code>， 以<code>i</code>为根节点，用<code>[l, i-1]</code>和 <code>[i+1, r]</code>来构造左右子树。</li><li>分别返回左右子树的数量<code>ls</code>和 <code>rs</code>（列表<code>left_childs</code>和<code>right_childs</code>）。</li><li>该节点的子树数量为<code>ls*rs</code>。 （以每一个左右子树对，构造一个二叉树）。</li><li>返回树的数量（返回树的数组）。</li></ol><h5 id="代码">代码</h5><ul><li>构造树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; trees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">        trees.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> trees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> root=l; root&lt;=r; root++)&#123;</span><br><span class="line">        List&lt;TreeNode&gt; left_child = generateTrees(l, root-<span class="number">1</span>);</span><br><span class="line">        List&lt;TreeNode&gt; right_child = generateTrees(root+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(TreeNode left: left_child)&#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode right: right_child)&#123;</span><br><span class="line">                TreeNode node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">                node.left = left;</span><br><span class="line">                node.right = right;</span><br><span class="line">                trees.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> root=l; root&lt;=r; root++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = generateTrees(l, root-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> right = generateTrees(root+<span class="number">1</span>, r);</span><br><span class="line">        </span><br><span class="line">        res += left * right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序链表转二叉树">有序链表转二叉树</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">LeetCode-109</a></p><h5 id="题目描述-1">题目描述</h5><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个<strong>高度平衡二叉树</strong>是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p></blockquote><h5 id="分析-1">分析</h5><p>第一种方法，我们可以先遍历一遍链表，然后把链表中的值存在一个数组中，再用数组来构建一个平衡二叉搜索树。这种方法比较简单，而且需要开辟额外的空间，所以不再赘述。</p><p>第二种方法，可以采用递归。对于子链表<code>[left, right]</code>，每次使用快慢指针找到中点来构建。</p><p>第二种方法的时间复杂度主要在于反复地寻找中位数节点。由于二叉树的中序遍历结构就是链表本身，所以我们可以将分治过程与中序遍历结合起来：</p><p>具体做法就是，在构造过程中，不用先找出链表中的中位数节点，只需要找到它的序号，并预先构造一个占位节点。用一个外部指针去遍历链表，每构造一个节点，该指针都向后移动一个位置。当中序遍历构造完左子树之后，再填充节点的正确的值。</p><h5 id="代码-1">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    ListNode globalHead;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        globalHead = head;</span><br><span class="line">        <span class="keyword">int</span> length = listLength(head);</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.left = buildTree(left, mid-<span class="number">1</span>);</span><br><span class="line">        root.val = globalHead.val;</span><br><span class="line">        globalHead = globalHead.next;</span><br><span class="line">        root.right = buildTree(mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">listLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树展开成链表">二叉树展开成链表</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">LeetCode-114</a></p><h5 id="题目描述-2">题目描述</h5><blockquote><p>给你二叉树的根结点 <code>root</code>，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 <code>TreeNode</code>，其中 right 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code>。 展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</p></blockquote><h5 id="分析-2">分析</h5><p>第一种简单做法，是先用一次先序遍历，把节点都保存在都保存在一个列表中，再给它们的左右子树赋值。</p><p>第二种做法是，遍历每一个节点。对于一个节点，如果它的左子树为空，则说明当前节点不需要操作，直接去操作它的右节点。</p><p>如果左子树非空，则需要以下三个步骤：</p><p>①找到先序遍历时左子树的最后一个节点 <code>pre</code>。（<code>curr</code><strong>左子树中的最右节点</strong>）</p><p>②然后把 <code>curr</code> 的右子树连接到<code>pre</code> 的右子树。</p><p>③把<code>curr</code>的左子树连接给 <code>curr</code> 的右子树。</p><h5 id="代码-2">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到前驱节点</span></span><br><span class="line">            TreeNode pre = cur.left;</span><br><span class="line">            <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.right = cur.right;</span><br><span class="line">            cur.right = cur.left;</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="填充每个节点的下一个右侧节点指针-ii">填充每个节点的下一个右侧节点指针 II</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">LeetCode-117</a></p><h5 id="题目描述-3">题目描述</h5><blockquote><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">&gt; int</span> val;</span><br><span class="line">&gt; <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">&gt; <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">&gt; <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>你只能使用常量级额外空间。</strong></p></blockquote><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210905143101.png" alt="image-20210905143101119"><figcaption aria-hidden="true">image-20210905143101119</figcaption></figure><h5 id="分析-3">分析</h5><p>如果不限制空间的话，那么使用层次遍历就可以解决了。无法使用额外空间的话，其实对于每一层的节点，可以用 <code>next</code> 指针来代替队列的作用。</p><h5 id="代码-3">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    Node last=<span class="keyword">null</span>;</span><br><span class="line">    Node nextLevelStart = <span class="keyword">null</span>;<span class="comment">// 下一层的起始节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span>(start!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">            nextLevelStart = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node p = start; p.next!=<span class="keyword">null</span>; p=p.next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextLevelStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextLevelStart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextLevelStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具有所有最深节点的最小子树">具有所有最深节点的最小子树</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank" rel="noopener">LeetCode-865</a></p><h5 id="题目描述-4">题目描述：</h5><blockquote><p>给定一个根为 <code>root</code>的二叉树，每个节点的深度是 该节点到根的最短距离 。</p><p>如果一个节点在 <strong>整个树</strong> 的任意节点之间具有最大的深度，则该节点是 <strong>最深的</strong> 。</p><p>一个节点的 <strong>子树</strong> 是该节点加上它的所有后代的集合。</p><p>返回能满足 <strong>以该节点为根的子树中包含所有最深的节点</strong> 这一条件的具有最大深度的节点。</p></blockquote><h5 id="分析-4">分析</h5><p>首先考虑计算每个节点的深度，很容易采用后续遍历的方式，自底向下地来计算。</p><p>那么再进一步考虑：能不能在计算深度的<strong>同时</strong>采用一次遍历也返回具有最大深度的节点呢？</p><p>这时候就要采用<strong>递归</strong>和<strong>局部</strong>的思想：</p><ul><li>如果左右子树深度相同，那么该节点就是最小子树的根节点，返回该节点以及该节点的深度。</li><li>如果左子树更深，那么最小子树的根节点就在左子树中，且就是递归中左子树返回的节点。</li><li>如果右子树更深，那么最小子树的根节点就在右子树中，且就是递归中右子树返回的节点。</li></ul><p>由于递归要返回两部分内容，我们就需要使用另外一个类，或数据结构来表示返回的结果。一个域是节点类型，表示最小子树的根节点，另一个域是整数类型，表示子树的深度。</p><h5 id="代码-4">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subdfs(root).node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Res <span class="title">subdfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Res(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        Res L = subdfs(node.left);</span><br><span class="line">        Res R = subdfs(node.right);</span><br><span class="line">        <span class="keyword">if</span>(L.height&gt;R.height) <span class="keyword">return</span> <span class="keyword">new</span> Res(L.node, L.height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(R.height&gt;L.height) <span class="keyword">return</span> <span class="keyword">new</span> Res(R.node, R.height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Res(node, L.height+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Res</span></span>&#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    Res(TreeNode n, <span class="keyword">int</span> h)&#123;</span><br><span class="line">        node = n;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode-236</a></p><blockquote><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><h5 id="分析-5">分析</h5><p>对于寻找最近公共祖先，有两种情况：</p><ol type="1"><li>p 在 q 的子树中，最近公共祖先即为 q。</li><li>p, q 在分别某一个节点 node 的左右子树中。</li></ol><p>因此，我们可以使用后序遍历：</p><p>首先判断 node 的值是否与 p 或 q 相等，若相等，或者遇到node 为空节点，则直接返回 node。这是递归的边界条件。</p><p>若不相等再递归地查找 p 或者 q 是否在 node 的左子树或右子树中，如果在的话，返回节点p或者q，不在的话返回空。设左右子树递归返回的结果为 left 和 right。</p><ol type="1"><li>若 left right 同时为空，则说明不在 node 的子树中。继续返回 空</li><li>若 left 和 right 同时不为空，说明 p 和 q 分别在 node 左右子树中，返回 node 为最近祖先。</li><li>若 left 为空， right 不为空，有以下三种情况：<ol type="1"><li>right指向 q，还未找到p。</li><li>p，q 均在 node 的右子树中，且 right 指向最近公共祖先。</li><li>right 指向q，且p在q 的子树中。</li></ol></li></ol><p>这里解释一下，为什么不需要两个变量来记录在子树中 <strong>找到p</strong> 和 <strong>找到q</strong> 这两件事情。</p><p>在上面的<strong>首先</strong> 与 <strong>3.1</strong> 中，如果 p 在 q 的子树中，我们是访问不到 节点 p 的。在访问到 q 的时候，递归就返回了。返回节点即为公共节点 q。这样的话对于其之上每个节点的递归，left 和 right 都一定只有一个不为空，即每次返回的都是q。</p><p>若 p 和 q 分别在某一节点的 node 中左右子树中，对于其第一个公共祖先 node。其递归的 left 和 right 一定都不为空，且一定是 left 和 right 一个指向 p， 一个指向 q。这时，我们返回的节点 node，即为最近的公共祖先。而对于 node 的祖先节点，其left 和right 也同上，一定只有一个不为空，每次向上返回的不为空的节点即为公共祖先 node。</p><h5 id="代码-5">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || root==p || root==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = dfs(root.left, p, q);</span><br><span class="line">        TreeNode right = dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 不在当前 root 的子树中</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>) <span class="keyword">return</span> right; <span class="comment">// 至少有一个在右子树中</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="tree" scheme="https://github.com/maneback/maneback.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>子序列问题</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/subsequences/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/subsequences/</id>
    <published>2021-09-01T02:44:07.000Z</published>
    <updated>2021-09-03T13:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最长公共子序列</p><p>最长上升子序列</p><p>摆动序列</p><p>编辑距离</p><a id="more"></a><h4 id="最长公共子序列">最长公共子序列</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">LeetCode-1143</a></p><h5 id="题目描述">题目描述</h5><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p></blockquote><h5 id="分析">分析</h5><p>我们用一个二维dp数组 <code>dp[i][j]</code> 表示 <code>text1[0,i]</code> 和 <code>text2[0,j]</code> 的最长公共子序列，则根据最后一个字符 <code>text1[i]</code> 和<code>text2[j]</code> 的关系，得到下面的状态转移方程： <span class="math display">\[dp[i][j] = \cases{dp[i-1][j-1]+1,\;\;\; text1[i]=text2[j],\\                \max\{dp[i][j-1], dp[i-1][j]\}, \;\;text1[i]\neq text2[j]}\]</span></p><h5 id="代码">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length();</span><br><span class="line">    <span class="keyword">int</span> n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长上升子序列">最长上升子序列</h4><p>题目链接： <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCode-300</a></p><h5 id="题目描述-1">题目描述</h5><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><h5 id="分析-1">分析</h5><p>我们用一个一维的dp数组 <code>dp[i]</code> 表示 数组<code>nums[0...i]</code> 的严格递增子序列的长度。考虑到子问题：对于一个严格递增子序列，去掉其最后一个元素，其仍然是一个严格递增子序列。所以，有状态转移方程 <span class="math display">\[dp[i] = \max_{j&lt;i\and nums[j]&lt;nums[i]}(dp[j]+1)\]</span></p><h5 id="代码-1">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;j; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="摆动序列">摆动序列</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">LeetCode-376</a></p><h5 id="题目描述-2">题目描述</h5><blockquote><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p></blockquote><h5 id="分析-2">分析</h5><p>只要理解摆动序列的概念，画个图的话，就是：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210902192124.png"></p><p>这个图中表示了八个数据点，即每一个波峰波谷处。然而原始的数组，可能每一个上山或下山的过程中，都还存在这不止一个数据点。那么其实我们要找到的，就是这些位于波峰波谷的点。</p><p>定义<code>d[i]=sign(nums[i]-nums[i-1])</code> 即表示是上坡还是下坡。每当遇到<code>d[i]!=d[i-1]</code>的情况，则表明遇到了波峰或者波谷，此时把这个数字添加到递增子序列中（表现子序列长度加一）。其次，数组中可能会存在连续的相同数字，所以要用一个 <code>flag</code> 表示它是否在动了。</p><h5 id="代码-2">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> d = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> cd = nums[i]&gt;nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!flag|| d!=cd)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        d = cd;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑距离">编辑距离</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode-72</a></p><h5 id="题目描述-3">题目描述</h5><blockquote><p>给你两个单词 <code>word1</code>和 <code>word2</code>，请你计算出将 <code>word1</code>转换成 <code>word2</code>所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符 删除一个字符 替换一个字符</p></blockquote><h5 id="分析-3">分析</h5><p>很显然，两个字符串的问题，继续使用二维的dp数组，关键之处在于理解这个数组表示的含义。以及状态转移方程。</p><p>在第一个问题公共子序列中，我们用<code>dp[i][j]</code> 表示了前缀 <code>s1[0...i]</code> 和 <code>s2[0...j]</code> 的公共子序列。同理在这个问题中也是类似。</p><p>那么状态转移方程应该怎么变， 是与字符串<code>s1[i]</code>和字符<code>s2[j]</code>相关的。</p><p>相等时可以直接跳过不用操作。 <code>dp[i][j] = dp[i-1][j-1]</code></p><p>不相等时，考虑对字符串<code>s1</code> 的三种操作：</p><ul><li>删除字符<code>s1[i]</code> ，相当于子问题 <code>dp[i-1][j]</code> 再多一步删除的操作</li><li>（在A中插入字符<code>s2[j]</code>）。 相当于让新插入的字符去匹配<code>s2[j]</code>，在子问题<code>dp[i][j-1]</code>上增加一步插入操作</li><li>修改字符<code>s1[i]</code>。相当于子问题<code>dp[i-1][j-1]</code> 上增加一步修改操作。</li></ul><p>其实要理解这个问题的dp数组。把每一个 <code>dp[i][j]</code>都理解成这个矩阵的<strong>最后</strong>一个元素，即完全不要管后面位置的元素，可以帮助理解</p><p>画个图来理解一下这三种情况，框中为此次操作后的相同字符串。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210903211319.png"></p><h5 id="代码-3">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">if</span>(n1==<span class="number">0</span> || n2==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n1; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n2; i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]= Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最长公共子序列&lt;/p&gt;
&lt;p&gt;最长上升子序列&lt;/p&gt;
&lt;p&gt;摆动序列&lt;/p&gt;
&lt;p&gt;编辑距离&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>回文串</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/palindrome/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/palindrome/</id>
    <published>2021-08-29T11:32:55.000Z</published>
    <updated>2021-09-03T11:38:43.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最长回文子串</p><p>回文字符串的个数</p><p>最长回文子序列</p><p>分割回文串</p><a id="more"></a><h4 id="最长回文子串">最长回文子串</h4><p>题目链接： <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode-5</a></p><h5 id="题目描述">题目描述</h5><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></blockquote><h5 id="分析">分析</h5><p>题目描述很简单，也很直白。</p><p>一般来讲，字符串，尤其是回文字符串的问题，都会与动态规划相关，此题也不例外。</p><p>首先，先考虑如何用动态规划，找出最长回文子串的<strong>长度</strong>，即先不要想子串到底是什么。</p><p>使用动态规划的关键则在于，如何找到最优子结构。</p><p>对于一个字符串（长度大于2）来讲，如果它是一个回文串，那么其去掉首尾的两个字母后仍是一个回文串。而边界条件即为长度为<code>1</code> 或者 <code>2</code> 的情况。</p><p>我们用一个布尔类型的二维数组 <code>dp[i, j]</code> 表示 子串 <code>s(i,j)</code> 是否是一个回文串，那么可以得到如下的状态转移方程： <span class="math display">\[dp[i,j] = dp[i+1,j-1]\and S_i==S_j\]</span> 在边界条件中，对于任何一个长度为1的字符串，都可以认为它是一个回文串；对于任何一个长度为2的字符串，只要两个字母相等，它就是一个回文串，即边界条件为： <span class="math display">\[\cases{dp[i,i]=true\\dp[i,i+1]=(S_i==S_{i+1})}\]</span></p><p>同时考虑到 <code>i,j</code> 的大小关系一定有 <code>i&lt;=j</code>， 因此我们只需要来填写dp数组的上半部分。</p><p>然后再考虑如何从边界条件开始扩展：可以按照字符串的长度来扩展，即每次不断增加字符串的长度。</p><p>这样的话，每找到一个子串，就可以记录它的长度和起始位置，最终根据起始位置和长度返回子串即可。</p><h5 id="代码">代码</h5><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] strArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l&lt;=n; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;n; left++)&#123;</span><br><span class="line">            <span class="keyword">int</span> right = left + l -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(strArray[left]!=strArray[right])&#123;</span><br><span class="line">                dp[left][right] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">2</span>)&#123;</span><br><span class="line">                    dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[left][right] = dp[left+<span class="number">1</span>][right-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[left][right] &amp;&amp; right-left+<span class="number">1</span>&gt;res)&#123;</span><br><span class="line">                res = right-left+<span class="number">1</span>;</span><br><span class="line">                begin = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, begin+res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种遍历方法：</li></ul><p>仔细观察状态转移方程，发现每一个 <code>dp[i,j]</code> 只会用到在矩阵中其左下方位置的元素，所以，我们还可以倒序遍历 <code>left</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] strArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=n-<span class="number">1</span>; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>; right&lt;n; right++)&#123;</span><br><span class="line">            dp[left][right] = dp[left+<span class="number">1</span>][right-<span class="number">1</span>]&amp;&amp;(strArray[left]==strArray[right]);</span><br><span class="line">            <span class="keyword">if</span>(dp[left][right] &amp;&amp; right-left+<span class="number">1</span>&gt;res)&#123;</span><br><span class="line">                res = right-left+<span class="number">1</span>;</span><br><span class="line">                begin = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, begin+res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实这两种原理是一样的，都是字符串长度由短向长的遍历。</p><p>第一种遍历是以<strong>子串长度</strong>优先，先遍历所有短的字符串，再遍历长的；第二种是从以<strong>子串起始位置</strong>优先，从结尾处开始遍历。画个图表示就是：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210902165025.png"></p><h4 id="回文字符串的个数">回文字符串的个数</h4><p>题目链接：</p><ul><li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">LeetCode-647</a></li><li><a href="https://leetcode-cn.com/problems/a7VOhD/" target="_blank" rel="noopener">Offer II-020</a></li></ul><h5 id="题目描述-1">题目描述</h5><blockquote><p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p></blockquote><h5 id="题目分析">题目分析</h5><p>按照上一个题的思路，使用动态规划找到所有的回文字符串。然后计数。</p><h5 id="代码-1">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=n-<span class="number">1</span>; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>; right&lt;n; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[left][right] = (s.charAt(left)==s.charAt(right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[left][right] = dp[left+<span class="number">1</span>][right-<span class="number">1</span>]&amp;&amp;(s.charAt(left)==s.charAt(right))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[left][right])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长回文子序列">最长回文子序列</h4><p>题目链接： <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">LeetCode-516</a></p><h5 id="题目描述-2">题目描述</h5><blockquote><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p></blockquote><h5 id="分析-1">分析</h5><p>题目描述如上面那个题一样简单。</p><p>仍然利用上面动态规划的思路。上面我们用一个布尔类型的数组来表示一个字符串是否为回文子串。但是子序列与子串的区别在于，子序列可以是不连续的，什么意思呢？</p><p>举个例子：</p><ul><li>在判断回文子串<code>s(i,j)</code> 时，一定是与字符<span class="math inline">\(S_{i+1}\)</span> 和 <span class="math inline">\(S_{j-1}\)</span>完全相关，回文子串中一定会包括这两个字符。</li><li>但是在判断回文子序列<code>s(i,j)</code> 时，子序列中不一定非得要包含<span class="math inline">\(S_{i+1}\)</span> 和 <span class="math inline">\(S_{j-1}\)</span> 这两个字符，可能只包含其中一个，或是一个都没有。</li></ul><p>也就是说，我们无法用一个布尔类型的数组来记录，这无法给我们提供一个完整的信息。</p><p>既然布尔类型的不够用，就直接记录长度呗。注意这里又有一个不同了：</p><ul><li>在构造回文子串时，两个字符<span class="math inline">\(S_{i}\)</span> 和 <span class="math inline">\(S_{j}\)</span> 一定是同时添加的，如果它们两个不相等，则无法构成回文串。</li><li>在构造回文子序列时，如果它们两个不相等，我们还可以尝试添加其中一个。</li></ul><p>状态转移方程如下： <span class="math display">\[dp[i,j] = \cases{dp[i+1][j-1]+2, S_i==S_j\\                \max(dp[i][j-1], dp[i+1][j]), S_i\neq S_j)}\]</span> 以及边界条件仍然是长度为1 的子串 <span class="math display">\[dp[i,i]=1\]</span> 由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序。</p><p>最终得到<code>dp[0][n-1]</code>即为字符串的最长回文子序列的长度。</p><h5 id="代码-2">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=n-<span class="number">2</span>; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>; right&lt;n; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( charArray[left]==charArray[right])&#123;</span><br><span class="line">                dp[left][right] =dp[left+<span class="number">1</span>][right-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[left][right] = Math.max(dp[left+<span class="number">1</span>][right], dp[left][right-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割回文串">分割回文串</h4><p>题目链接： <a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">LeetCode-131</a></p><h5 id="题目描述-3">题目描述</h5><blockquote><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p></blockquote><h5 id="题目分析-1">题目分析</h5><p>首先，在第一个题目中，已经知道了如何用动态规划算法，判断并记录字符串中任意一个子串是否为回文串，得到这个之后，只要再用回溯法来尝试每一个可行的分割位置就行了。</p><p>再来回忆一下<a href="">回溯法</a>。每个可能的回文串结尾的位置，都是一个可被选的分割点。</p><h5 id="代码-3">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] dp;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=n-<span class="number">1</span>; l&gt;=<span class="number">0</span>; l--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>; r&lt;n; r++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[l][r] = (s.charAt(l)==s.charAt(r));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                dp[l][r] = dp[l+<span class="number">1</span>][r-<span class="number">1</span>]&amp;&amp;(s.charAt(l)==s.charAt(r));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ch=index; ch&lt;n; ch++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[index][ch])&#123;</span><br><span class="line">                ans.add(s.substring(index, ch+<span class="number">1</span>));</span><br><span class="line">                dfs(s, ch+<span class="number">1</span>);</span><br><span class="line">                ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="分割回文串-ii">分割回文串 II</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">LeetCode-132</a></p><h5 id="题目描述-4">题目描述</h5><blockquote><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 <strong>最少分割次数</strong> 。</p></blockquote><h5 id="题目分析-2">题目分析</h5><p>与第一个分割回文串的问题相同，第一步也是找出并记录字符串的回文子串供第二步使用。</p><p>其实对于第二步，也可以采用上述的方法，找出所有可能的分割方案，然后选择一个分割次数最小的。但是这么做太麻烦了。</p><p>第二步中仍使用动态规划来求解，最少分割次数。</p><p>设<code>dp[i]</code> 表示字符串<span class="math inline">\(S_0...S_i\)</span> 的最少分割次数，假设已经已知了<code>dp[i]</code> 的分割方案，对于任意的<code>j&gt;i</code>，如果<span class="math inline">\(S_{i+1}...S_j\)</span> 是一个回文子串，那么 <span class="math inline">\(S_0...S_j\)</span> 的分割方案，可以在 <span class="math inline">\(S_0...S_i\)</span> 分割的基础上，再在 <span class="math inline">\(S_i, S_{i+1}\)</span> 两个字符间多一次分割，即： <span class="math display">\[dp[j] = \min_{i&lt;j}\{dp[i]\}+1, \mbox{ if } S_{i+1}...S_j \mbox{ is Palindrome}\]</span></p><h5 id="代码-4">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] strArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=n-<span class="number">1</span>; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>; right&lt;n; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[left][right] = (strArray[left]==strArray[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[left][right] = dp[left+<span class="number">1</span>][right-<span class="number">1</span>]&amp;&amp;(strArray[left]==strArray[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        f[i] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][i])&#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j+<span class="number">1</span>][i])&#123;</span><br><span class="line">                    f[i] = Math.min(f[j]+<span class="number">1</span>, f[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割回文串-iii">分割回文串 III</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/" target="_blank" rel="noopener">LeetCode-1278</a></p><h5 id="题目描述-5">题目描述</h5><blockquote><p>给你一个由小写字母组成的字符串 <code>s</code>，和一个整数 <code>k</code>。</p><p>请你按下面的要求分割字符串：</p><ul><li>首先，你可以将 <code>s</code> 中的部分字符修改为其他的小写英文字母。</li><li>接着，你需要把 <code>s</code> 分割成 <code>k</code> 个非空且不相交的子串，并且每个子串都是回文串。</li></ul><p>请返回以这种方式分割字符串所需修改的最少字符数。</p></blockquote><h5 id="题目分析-3">题目分析</h5><p>这道题目同样使用动态规划。</p><p>首先定义动态规划数组，用<code>dp[end][j]</code> 表示前<code>end</code>个字符，分割成<code>j</code>个非空不相交的回文串，需要最小修改的字符数。</p><p>如我们已经已知了如何将前<code>end</code>个字符串分割成<code>j-1</code> 个子串，那么下一步便是考虑如何将它分成<code>j</code>个子串。</p><p>其实只需要枚举第<code>j</code>个子串的起始位置<code>ij</code>，把 <code>S[0,ij-1]</code>分割成<code>j</code>个子串，然后 <code>S[ij, end]</code>作为第<code>j</code>个子串。</p><p>然后再计算子串 <code>S[ij, end]</code>构成回文串需要修改的字符数量–定义为 <code>cost(ij, end)</code>。</p><p>同时，为了得到非空的字符串，还要有以下两个限制：</p><ul><li><code>j&lt;=end</code> 因为前 <code>end</code> 个字符，最多能被分成 <code>end</code> 个子串。</li><li><code>ij&gt;=j-1</code>。 因为要得到<code>j-1</code>个非空子串，前面至少要有这么多个字符。</li></ul><p><span class="math display">\[dp[end][j] = \min_{ij}\{dp[ij][j-1] +cost(ij, end)\}\]</span></p><p>边界条件为：当<code>j=1</code>时，也就是不需要分割时，则有<code>dp[i][1] = cost[0][i]</code>成立。</p><p>为了避免重复计算，我们可以再用一次动态规划来记录所有的 <code>cost(ij, end)</code>。这个动态规划的边界条件即为：对任意长度为1的字符串，都有<code>cost(i,i)=0</code>。之后类似于寻找最长子串，以字符串长度为优先遍历，得到： <span class="math display">\[cost(i,j)=\cases{cost(i+1,j-1)+1,\;\; S_i\neq S_j\\cost(i+1, j-1),\;\;\;\; S_i=S_j}\]</span></p><h5 id="代码-5">代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(String s, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] cost = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>; l&lt;=n; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;n; left++)&#123;</span><br><span class="line">            <span class="keyword">int</span> right = left+l-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cost[left][right] = cost[left+<span class="number">1</span>][right-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)!=s.charAt(right))&#123;</span><br><span class="line">                cost[left][right]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=k; i++)&#123;</span><br><span class="line">        Arrays.fill(f[i], <span class="number">10086</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=Math.min(k, i); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                f[i][j] = cost[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i0=j-<span class="number">1</span>; i0&lt;i; i0++)&#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i0][j-<span class="number">1</span>]+cost[i0][i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][k];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割回文串-iv">分割回文串 IV</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/palindrome-partitioning-iv/" target="_blank" rel="noopener">LeetCode-1745</a></p><h5 id="题目描述-6">题目描述</h5><blockquote><p>给你一个字符串 <code>s</code> ，如果可以将它分割成三个 <strong>非空</strong> 回文子字符串，那么返回 <code>true</code>，否则返回 <code>false</code>。</p><p>当一个字符串正着读和反着读是一模一样的，就称其为 <strong>回文字符串</strong> 。</p></blockquote><h5 id="题目分析-4">题目分析</h5><p>第一步仍然相同，先计算并统计所有的回文子串。</p><p>第二步的重点则在于，找到这个字符串能否被分成三个回文串，即 <strong>找到两个分割点</strong>。完成前两个分割回文串的题目后，这个题目的思路就非常地清晰了。</p><p>可以看到，前半部分的代码都是完全重复的。</p><h5 id="代码-6">代码</h5><p><code>p1</code> 和<code>p2</code> 即为分割点，字符串被分成 <code>S[0, p1]</code> , <code>S[p1+1, p2]</code> , <code>S[p2+1, n-1]</code> 三部分。注意由于要求各部分非空，要注意循环范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPartitioning</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] strArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=n-<span class="number">1</span>; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>; right&lt;n; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[left][right] = (strArray[left]==strArray[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[left][right] = dp[left+<span class="number">1</span>][right-<span class="number">1</span>]&amp;&amp;(strArray[left]==strArray[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p1=<span class="number">0</span>; p1&lt;n-<span class="number">2</span>; p1++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p2=p1+<span class="number">1</span>; p2&lt;n-<span class="number">1</span>; p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[<span class="number">0</span>][p1]&amp;&amp;dp[p1+<span class="number">1</span>][p2]&amp;&amp;dp[p2+<span class="number">1</span>][n-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最长回文子串&lt;/p&gt;
&lt;p&gt;回文字符串的个数&lt;/p&gt;
&lt;p&gt;最长回文子序列&lt;/p&gt;
&lt;p&gt;分割回文串&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="动态规划" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回文串" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法（二）</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/back2/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/back2/</id>
    <published>2021-08-25T06:50:18.000Z</published>
    <updated>2021-09-03T11:45:38.733Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前的一篇<a href="../back/index.html">文章</a>介绍了四个跟数组相关的回溯法例题，子集问题与全排列问题，这次继续介绍另外一种回溯法的题。</p><h4 id="例题1-路径总和">例题1 路径总和</h4><p>链接 <a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">Leetcode-112</a></p><blockquote><p>给你二叉树的根节点 root 和一个表示目标和的整数 <code>targetSum</code>，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code>。</p><p>叶子节点 是指没有子节点的节点。</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210825145405.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></blockquote><p>这个就更简单了，连搜索树都帮我们建好了，而且只是一个二叉树。只需要思考：什么样的答案是满足条件的解。</p><p>我们可以在二叉树的后序遍历中，记录路径和，到子节点判断是否和等于 <code>targetSum</code>，再返回 <code>True</code> 或是 <code>False</code>。</p><p>另外，题目中并没有明确说明，所有节点都为非负数，所以我们并不能进行剪枝。要是加上这个条件的话，可以在前缀和已经大于 <code>targetSum</code> 的条件下，可以提前返回，不必再继续去搜索子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, cursum)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: <span class="comment"># 到根节点判断和是否相等</span></span><br><span class="line">                <span class="keyword">if</span> cursum==node.val:  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> dfs(node.left, cursum-node.val) <span class="keyword">or</span> dfs(node.right, cursum-node.val)</span><br><span class="line">            <span class="keyword">elif</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> dfs(node.left, cursum-node.val)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> dfs(node.right, cursum-node.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, sum)</span><br></pre></td></tr></table></figure><h4 id="例题2-路径总和ii">例题2 路径总和II</h4><p>链接 <a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">Leetcode-113</a></p><blockquote><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p></blockquote><p>第一个题是判断是否存在，这个题是找出所有，那其他都一样嘛，用一个数组<code>res</code>记录答案，然后在遍历中不仅记录路径和，还要记录路径的所有节点值。</p><p>在叶子结点不返回 <code>True</code> 或<code>False</code>。而是把 <code>trace</code> 加到<code>res</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, pre, summ)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> summ==node.val:</span><br><span class="line">                    self.res.append([x <span class="keyword">for</span> x <span class="keyword">in</span> pre]) <span class="comment"># 给 res 添加一个解</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                dfs(node.left, pre+[node.left.val], summ-node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                dfs(node.right, pre+[node.right.val], summ-node.val)</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        dfs(root, [root.val], sum)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h4 id="例题3-组合总数">例题3 组合总数</h4><p>链接 <a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">Leetcode-39</a></p><blockquote><p>给定一个无重复元素的正整数数组 <code>candidates</code>和一个正整数 <code>target</code>，找出 <code>candidates</code>中所有可以使数字和为目标数 <code>target</code>的唯一组合。</p><p><code>candidates</code>中的数字可以<strong>无限制重复被选取</strong>。如果至少一个所选数字数量不同，则两种组合是唯一的。</p><p>对于给定的输入，保证和为 <code>target</code>的唯一组合数少于 150 个。</p></blockquote><p>我为何要把这个组合总数与路径和放在一起。</p><p>路径和是人家给定了你一个二叉树，想象一下，假如 <code>candidates</code> 中有 <code>n</code> 个数字，是不是能转换成一个 <code>n</code>层的<code>n</code> 叉树？当然我们并不会真的去建一棵树，只是在搜索的时候把数组<strong>看成</strong> 是一棵树。</p><p>这个并不是要求搜索到 <strong>叶节点</strong> ，即在任意一个节点都可能往 <code>res</code> 集合中更新一个答案。</p><p>但是直接建树的话，树的规模一定比上面的二叉树大很多。同时我上面又提到过，要是给了条件说，数组中全为正数，那么其实是可以提前剪枝的，从而缩小搜索空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        size = len(candidates)</span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        path = []</span><br><span class="line">        self.res = []</span><br><span class="line"></span><br><span class="line">        self.dfs(candidates, <span class="number">0</span>, path, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, begin, path, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            self.res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, len(candidate)):</span><br><span class="line">            residue = target-candidates[index]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> residue&lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># 提前终止</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            self.dfs(candidates, index, path, residue) <span class="comment"># 数字可重复使用，因此下一层继续从 index 开始。</span></span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><h4 id="例题4-组合总和ii">例题4 组合总和II</h4><p>链接 <a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">Leetcode-40</a></p><blockquote><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code>中所有可以使数字和为 <code>target</code>的组合。</p><p><code>candidates</code>中的每个数字在每个组合中只能使用一次。</p><p><strong>注意</strong>：解集不能包含重复的组合。</p></blockquote><p>这个只是加上了条件，只能使用一次。那么再回忆一下在上一篇中，<strong>子集</strong>中的做法，保证每一个解中数字的添加顺序等同于数字在原数组中的顺序即可，即树中的下一层节点仅包含当前节点之后的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(trace, idx)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(trace)== target:</span><br><span class="line">                <span class="comment"># print(idx, trace)</span></span><br><span class="line">                self.res.append([ _ <span class="keyword">for</span> _ <span class="keyword">in</span> trace])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">elif</span> sum(trace)&gt;target:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(idx, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                used[i] = <span class="keyword">True</span></span><br><span class="line">                trace.append(candidates[i]) </span><br><span class="line">                bp(trace, i+<span class="number">1</span>) <span class="comment"># 下一层仅包含当前 i  之后的数字</span></span><br><span class="line">                used[i] = <span class="keyword">False</span></span><br><span class="line">                trace.pop()</span><br><span class="line"></span><br><span class="line">        used = [<span class="keyword">False</span>]*len(candidates)</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        <span class="comment"># print(candidates)</span></span><br><span class="line">        bp([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      继续几个回溯法的例题
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="回溯算法" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法（一）</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/back/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/back/</id>
    <published>2021-08-25T05:29:43.000Z</published>
    <updated>2021-08-26T06:33:17.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="回溯法介绍">回溯法介绍</h4><p>最近在刷题的时候，发现之前手拿把攥的 回溯算法 下手的时候都经常有一点点疑惑和迟疑了。可能是太久没看它了，所以现在再来总结一下吧。</p><p>回溯算法可以理解为一个 n 叉树的查找，再加上剪枝的过程（也可能不存在剪枝）。在每一层中试探所有对可能性，走到叶子节点后，再回溯到父节点，试探下一个可能。因此如果理解了树的三种遍历过程，就能更容易地理解回溯法了。</p><p>回溯法一定是与<strong>递归</strong>紧密联系的，这样的话，就可以简化一下，在每一次递归中，只需要考虑当前步骤可选的操作以及如何进行到下一步，判断回溯是否结束。</p><p>回溯法的框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(step, trace, choices, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(step==n)</span><br><span class="line">        ans.append([_ <span class="keyword">for</span> _ <span class="keyword">in</span> trace])</span><br><span class="line">        <span class="keyword">return</span>;// 探索到根节点, n 表示最大深度</span><br><span class="line">    </span><br><span class="line">    // 尝试每个可行的选择，可能要对可行性进行判断。</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> choices:</span><br><span class="line">        traces.append(ch)//加入选择</span><br><span class="line">        back(step+<span class="number">1</span>, trace, choices, n)</span><br><span class="line">        traces.pop() // 回溯回来，撤销选择</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">trace</span><br><span class="line">back(<span class="number">0</span>, trace, nums, len(nums))</span><br></pre></td></tr></table></figure><h4 id="例题1-全排列">例题1 全排列</h4><p>链接： <a href="https://leetcode-cn.com/problems/permutations/*" target="_blank" rel="noopener">Leetcode-46</a></p><blockquote><p>给定一个<strong>不含重复数字</strong>的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p></blockquote><h5 id="回溯法解题思路">回溯法解题思路</h5><p>把问题套在我们的回溯法上，对全排列来讲假设数组长度为 <code>n</code>，那么数组的每个位置便为 <code>step</code>。即在每一步中，是给数组中的第<code>step</code>个位置安排数字，前面被安排的 <code>step-1</code> 个数字便为<code>trace</code>。</p><p>这里不用显式地记录 <code>step</code> 可以直接用 <code>trace</code> 的长度来表示。同时还需判断当前数字，是否已经在 <code>trace</code> 中了。</p><h5 id="样例代码">样例代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(trace, n, nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span>(len(traces)==n):</span><br><span class="line">                res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> trace])</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> trace:</span><br><span class="line">                    trace.append(trace)</span><br><span class="line">                    back(trace, n, nums)</span><br><span class="line">                    trace.pop()</span><br><span class="line">            n = len(nums)</span><br><span class="line">            back([], n, nums)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="例题2-全排列ii">例题2 全排列II</h4><p>链接 <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">Leetcode-47</a></p><blockquote><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p></blockquote><h5 id="回溯法思路">回溯法思路</h5><p>这道题与上一个题的区别在于，数组中含有重复的数组，而在排列上，相同数字又是不影响排列的。如数组<code>[3,3]</code>， 其只有一个排列 <code>[3,3]</code>，而不把它认为成是两个排列。那么我们下一步要解决的重要问题在于<strong>如何判断重复</strong>以及<strong>如何去重</strong>。</p><p>方法便是，把数组进行排序，这样的话，所有相同的数字便挨在了一起，这样的话只要判断<code>ch</code> 是否与上一个数字相同，以及上一个数字的使用状态。我们用<code>num</code> 表示排序后的数组，用 <code>used</code> 记录每个数字的使用情况。</p><p>如果 <code>num[i]</code> 与 <code>num[i-1]</code> <strong>相等</strong>，且 <code>num[i-1]</code> <strong>未被使用</strong>的话，那么便跳过当前数字 <code>num[i]</code>。这句话便是去重的关键，可能不太好理解。我们来画个树理解一下，以数组 <code>[1,1,2,3]</code> 为例。</p><p>节点里面的数组表示<code>used</code>数组，直线表示前进过程，曲线表示回溯过程。</p><p>看一下第 1 层的黄色节点。表示我们即将在第一个位置选择数组中的第二个 <code>1</code>，而它的整个子树产生的排列结果，与最左边<code>[1,0,0,0]</code>子树是完全一致的。也就是说要保证每个重复出现的数字在<strong>每一层</strong>中只会被选择一次，而在不同的层，它们是没有影响的，因为<code>used[i-1]=1</code> 时，<code>num[i-1]</code>一定是在上一层中添加的，而不是在这一层。</p><p>我们怎么判断它是在哪一层呢？只有在<strong>前一个节点刚刚完成回溯的时候</strong>，才会出现 <code>num[i-1]</code> 未被使用的情况，这时候如果我们继续探索 <code>num[i]</code> 便是一个重复的过程。</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210825141431.png" alt="image-20210825141431597"><figcaption aria-hidden="true">image-20210825141431597</figcaption></figure><h5 id="样例代码-1">样例代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(trace, nums, used)</span>:</span></span><br><span class="line">            <span class="keyword">if</span>(len(traces)==len(nums)):</span><br><span class="line">                self.res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> trace])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">## 去重</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                        used[i]= <span class="keyword">True</span></span><br><span class="line">                        trace.append(nums[i])</span><br><span class="line">                        back(trace, nums, used)</span><br><span class="line">                        used[i] = <span class="keyword">False</span></span><br><span class="line">                        trace.pop()</span><br><span class="line">            </span><br><span class="line">        nums.sort()</span><br><span class="line">       used = [<span class="keyword">False</span>]*len(nums)</span><br><span class="line">        back([], nums, used)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h4 id="例题3-子集i">例题3 子集I</h4><p>链接 <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">Leetcode-78</a></p><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p></blockquote><p>子集和全排列的区别在于，全排列仅在叶子结点更新要返回的答案集合，而子集要在每个节点都要更新答案集合（每个节点都是一个子集）。</p><p>还有就是，元素添加的顺序是不重要的，因此我们每次的选择，不是从头开始选，而是从当前位置 <code>step</code> 以后开始选，保证子集中的元素是按照其在原数组中的顺序被添加到其中的。如<code>[1,2,3,4,5]</code>。当我们回溯到 <code>3</code> 的时候，后续只考虑 添加 <code>4,5</code>。而不能乱序添加，这样的话，结果中就不会出现重复子集了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(step, trace, nums, used)</span>:</span></span><br><span class="line">           self.res.append(trace)</span><br><span class="line">            <span class="keyword">if</span> len(trace)&gt;=len(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> range(idx, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[ch]:</span><br><span class="line">                    used[ch] = <span class="keyword">True</span></span><br><span class="line">                    trace.append(nums[ch])</span><br><span class="line">                    back(ch+<span class="number">1</span>, trace, nums, used) <span class="comment"># 下一层只能添加，ch 之后的数字</span></span><br><span class="line">                    used[ch] = <span class="keyword">False</span></span><br><span class="line">                    trace.pop()</span><br><span class="line">n = len(nums)</span><br><span class="line">        used = [<span class="keyword">False</span>]*n</span><br><span class="line">        back(<span class="number">0</span>, [], nums, used)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h4 id="例题4-子集ii">例题4 子集II</h4><p>链接 <a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">Leetcode-90</a></p><blockquote><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p></blockquote><p>把例题2 和 例题3 结合一下，就能得这个题目的答案了。同样是<strong>子集</strong> + <strong>去重</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(trace, nums, idx)</span>:</span></span><br><span class="line">            self.res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> trace])</span><br><span class="line">            <span class="keyword">if</span> idx&gt;=len(nums):</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(idx, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i<span class="number">-1</span>]: <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                used[i] = <span class="keyword">True</span></span><br><span class="line">                trace.append(nums[i])</span><br><span class="line">                bp(trace, nums, i+<span class="number">1</span>)  <span class="comment"># 下一层只添加 i 之后的数字</span></span><br><span class="line">                used[i] = <span class="keyword">False</span></span><br><span class="line">                trace.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="keyword">False</span>]*len(nums)</span><br><span class="line">        bp([], nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><ul><li>继续阅读 <a href="../back2/index.html">回溯算法2</a></li></ul>]]></content>
    
    <summary type="html">
    
      回溯算法
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="回溯法" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Select/poll/epoll的区别</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/select-poll-epoll/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/select-poll-epoll/</id>
    <published>2021-08-16T08:59:52.000Z</published>
    <updated>2021-08-25T07:36:07.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制来监视多个描述符，一旦某个描述符就绪（读或写），就能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>。在高并发服务器中，轮询I/O是最耗时间的操作之一。</p><h2 id="select">1. select</h2><p>select 的本质是通过设置或检查存放fd 标志位的数据结构进行下一步的操作，select的调用复杂度是线性的，每次以O(n)的时间遍历一遍所有的对象。它的缺点如下：</p><ul><li>对 socket 的扫描都是线性的，即每一个都要轮询一遍，效率低。当IO事件发生时，却不知道是哪个流或是哪几个流，只会无差异地轮询所有留，找出能进行读或写操作的流来。监视的流越多，需要的处理时间越长。</li><li>除了慢之外，单个进程所能监视的fd数量也会受到限制，单个进程所能打开的最大连接数量由<code>FD_SETSIZE</code> 宏定义。32位机器中默认1024个，64位机器中默认2048个。</li><li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ul><h2 id="poll">2.poll</h2><p>poll 本质上和select没有区别，也是通过轮询的方式来进行处理，只是用的存储结构不同。它是基于链表来存储的，所以与select相比没有最大连接数量的限制。但是它仍然需要把大量的fd数组复制于用户态和内核地址空间之间，而不论这些文件描述符是否就绪。开销随着fd的数量增加而线性增大。</p><h2 id="epoll">3.epoll</h2><p><strong>epoll可以理解为event poll</strong>，epoll会把哪个流发生了怎样的I/O事件通知我们。</p><p>epoll提供了三个函数，<code>epoll_create</code>,<code>epoll_ctl</code>和<code>epoll_wait</code>，<code>epoll_create</code>是创建一个epoll句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p><p>epoll 有两种触发机制： EPOLLLT 和 EPOLLET ，LT是默认的模式，ET是高速模式。</p><ul><li>LT模式下，只要这个fd还有数据可读，每次 <code>epoll_wait</code>都会返回它的事件，提醒用户程序去操作.</li><li>在ET模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。</li></ul><p>epoll使用“事件”的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似<code>callback</code>的回调机制来激活该fd，<code>epoll_wait</code>便可以收到通知。因此，epoll的这种机制，能够高效的处理更多的并发连接，而且性能不会随着连接数增加而下降。</p><p>优点：</p><ul><li>没有最大并发连接的限制。</li><li>不需要进行轮询，效率提升，也不会随着fd数量的增加而降低效率。只有活跃的fd才会调用<code>callback</code>函数。</li><li>内存拷贝，利用<code>mmap()</code> 文件映射内存加速与内核空间的消息传递，减少复制开销</li></ul><h2 id="总结">4.总结</h2><ol type="1"><li>支持最大连接数：<ul><li>select：由 <code>FS_SETSIZE</code> 宏定义，在32位的机器上，大小就是1024，同理64位机器上FD_SETSIZE为2048。</li><li>poll：poll采用链表存储，没有最大连接数量的限制。</li><li>epoll： 虽然连接数有上限，但是很大。</li></ul></li><li>fd增加后带来的IO 效率问题<ul><li>select/poll：因每次调用都要轮询所有的fd，因此效率会线性下降。</li><li>select：是根据每个fd上的回调函数实现的，只有活跃的fd才会调用callback。但是当所有socket都活跃的情况下，可能会有性能问题。</li></ul></li><li>消息传递机制<ul><li>select/poll：内核需要将消息传递到用户空间，需要内核拷贝动作。</li><li>epoll：通过内核和用户空间共享内存来实现。</li></ul></li></ol><p><strong>参考链接</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/272891398" target="_blank" rel="noopener">一文搞懂select、poll和epoll区别</a></li><li><a href="https://www.cnblogs.com/Anker/" target="_blank" rel="noopener">Dale工作学习笔记</a></li></ul>]]></content>
    
    <summary type="html">
    
      select/poll/epoll的区别
    
    </summary>
    
      <category term="基础知识" scheme="https://github.com/maneback/maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Linux" scheme="https://github.com/maneback/maneback.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/java-reflection/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/java-reflection/</id>
    <published>2021-08-16T03:25:11.000Z</published>
    <updated>2021-09-09T05:54:31.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="为什么需要反射机制">为什么需要反射机制</h3><p>Java反射机制是：在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有<strong>属性和方法</strong>；对于任意一个对象，都能够<strong>调用它的任意一个方法</strong>。这种动态获取的信息以及动态调用对象的方法的功能称为反射机制。</p><p>所以如果能够在运行时拿到Class对象，就可以生成java对象并进行调用。</p><p>反射赋予了jvm动态编译的能力。动态编译可以最大限度的体现Java的灵活性（多态）。否则类的元信息只能通过静态编译的形式实现（在编译期确定类型，绑定对象），而不能实现动态编译（在运行期确定类型，绑定对象）。也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译，在Java中就需要反射机制。</p><ul><li>情景一： 有的类无法使用 new 一个对象的方式来实例化。</li><li>情景二：有的类可以在用到时再动态加载到jvm中，这样可以减少jvm的启动时间，同时更重要的是可以动态的加载需要的对象（多态）。</li><li>情景三：避免将程序写死到代码中。</li></ul><p>反射的缺点：</p><ul><li>性能开销：由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。</li><li>破坏封装性： 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li>内部曝光： 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。</li></ul><h3 id="代码实现">代码实现</h3><p>首先构造一个类 Person 来实现反射，这个类是我们要通过反射来调用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gao.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">func3</span><span class="params">(<span class="keyword">int</span> x, String y)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"protected func3"</span>);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取class-对象">1. 获取class 对象</h4><p>应用反射的第一步是要拿到该类的静态属性<code>class</code> 然后通过拿到类的方法和属性。</p><p>共有三种方法获取：通过实例的方法、通过类的静态属性、通过字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        Class&lt;? extends Person&gt; c_by_obj = person.getClass(); <span class="comment">//方法1</span></span><br><span class="line">        Class&lt;Person&gt; c_by_class = Person.class; <span class="comment">// 方法2</span></span><br><span class="line">        Class&lt;?&gt; c_by_name = Class.forName(<span class="string">"com.gao.reflect.Person"</span>);<span class="comment">//方法3</span></span><br><span class="line">        System.out.println(c_by_class==c_by_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取构造函数并创建对象">2. 获取构造函数并创建对象</h4><p>之后我们都将通过字节码文件，来获取 class 对象。</p><p>可以由两种划分：</p><ul><li>私有构造函数/公有构造函数</li><li>单个构造函数/构造函数集合</li></ul><p>在获取单个带参构造函数的时候，需要指定参数个数和数据类型对应的字节码文件对象（Class）。</p><p>对于私有方法还可以通过<code>.setAccessible(true)</code> 来访问。</p><p>通过反射调用构造函数，是把实例对象和参数交给<strong>函数对象</strong>的<code>invoke</code> 来做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取构造方法</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"com.gao.pojo.reflect.Person"</span>);</span><br><span class="line">        <span class="comment">//返回包含构造对象数组（公共的）</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons =  cls.getConstructors();</span><br><span class="line">        <span class="comment">//返回包含构造对象数组（所有的）</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons_all =  cls.getDeclaredConstructors();</span><br><span class="line">        System.out.println(cons_all);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回指定的公共构造函数</span></span><br><span class="line">        <span class="comment">// 参数：表示要获取的构造方法的参数个数和数据类型对应的字节码文件对象（Class）</span></span><br><span class="line">        Constructor&lt;?&gt; con1 = cls.getConstructor(); <span class="comment">// 无参构造函数</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Object p = (Person) con1.newInstance(); <span class="comment">//Person p = new Person();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 带参构造方法    private Person(String name, int age, String address)</span></span><br><span class="line">        Constructor&lt;?&gt; con2 = cls.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        Object obj =  con2.newInstance(<span class="string">"name"</span>, <span class="number">30</span>, <span class="string">"xian"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//私有构造方法不能被在外部访问</span></span><br><span class="line">        <span class="comment">//暴力反射：</span></span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; con3 = cls.getDeclaredConstructor(String.class);</span><br><span class="line">        con3.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 暴力反射访问私有构造方法</span></span><br><span class="line">        Object ob = con3.newInstance(<span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取属性并赋值">3. 获取属性并赋值</h4><p>属性可以直接通过名字直接访问。</p><p>通过反射给属性赋值，是把对象和属性值交给 属性域的 <code>set</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类对象</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"com.gao.pojo.reflect.Person"</span>);</span><br><span class="line"></span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        Field[] all_fields = cls.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单个的属性</span></span><br><span class="line">        Field address_field = cls.getField(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; con = cls.getConstructor();</span><br><span class="line">        Object obj =  con.newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给成员变量的属性赋值</span></span><br><span class="line">        address_field.set(obj, <span class="string">"xian"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问成员方法">4. 访问成员方法</h4><p>同构造方法一样，也是通过 <code>invoke</code> 的函数来调用反射得到的成员方法。</p><p>对于有返回值的方法，<code>invoke</code> 会返回函数调用的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类对象</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"com.gao.pojo.reflect.Person"</span>);</span><br><span class="line">        Constructor&lt;?&gt; con = cls.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">        Method[] methods = cls.getMethods(); <span class="comment">// 所有公共方法和继承的方法</span></span><br><span class="line">        Method[] methods1 = cls.getDeclaredMethods(); <span class="comment">// 私有方法（不包括继承的方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参数的方法</span></span><br><span class="line"></span><br><span class="line">        Method func1 = cls.getMethod(<span class="string">"func1"</span>);</span><br><span class="line">        func1.invoke(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参的方法</span></span><br><span class="line">        Method fun2 = cls.getDeclaredMethod(<span class="string">"func2"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        fun2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        fun2.invoke(obj, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//带返回</span></span><br><span class="line">        <span class="comment">//参数 是参数类型</span></span><br><span class="line">        Method fun3 = cls.getMethod(<span class="string">"func3"</span>, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        fun3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = fun3.invoke(obj, <span class="number">30</span>, <span class="string">"tianjin"</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="越过泛型检查">5. 越过泛型检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class实例获取class信息的方法称为反射（Reflection）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//越过泛型检查</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class cls = list.getClass();</span><br><span class="line">        Method mthd = cls.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        mthd.invoke(list, <span class="string">"world"</span>);</span><br><span class="line">        System.out.println(list );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong>：</p><p><a href="https://blog.csdn.net/tongdanping/article/details/103252352" target="_blank" rel="noopener">为什么需要Java反射</a></p>]]></content>
    
    <summary type="html">
    
      介绍Java的反射知识
    
    </summary>
    
      <category term="基础知识" scheme="https://github.com/maneback/maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="https://github.com/maneback/maneback.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/java-collections/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/java-collections/</id>
    <published>2021-08-16T02:59:10.000Z</published>
    <updated>2021-08-29T11:43:33.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>集合提供了一个对象来在内部容纳若干其他的 Java 对象，并提供相应的访问接口。Java 的<code>java.util</code> 包主要提供了一下三种不同类型的集合：</p><ul><li><code>List</code> 有序列表的集合，可按插入顺序访问。，</li><li><code>Set</code> 确保不可以插入重复元素的集合。</li><li><code>Map</code> 通过 <code>key-value</code> 快速查找元素的集合。</li></ul><p>Java的集合设计有两个特点：一是支持泛型，可以限制插入到集合中元素的数据类型；二是实现了接口与类的分离，以上三种均为接口而非具体的实现类。并且可以通过统一的迭代器方式进行访问。</p><p><strong>我们尽量以接口而非具体的实现类来访问元素。</strong></p><p><strong>重要</strong> 以下遗留类不应该被继续使用：</p><p><code>Hashtable</code>, <code>Vector</code>, <code>Stack</code>, <code>Enumeration&lt;E&gt;</code>.</p><h3 id="list">List</h3><p>需要实现<code>equals</code> 方法。</p><p><code>ArrayList</code>基于动态数组实现，支持随机访问。<code>LinkedList</code>：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插⼊和删除元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; array2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; array = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//(index, elem)</span></span><br><span class="line">array.remove(<span class="number">1</span>);<span class="comment">//(elem)</span></span><br><span class="line"><span class="keyword">int</span> elem = array.get(<span class="number">1</span>)<span class="comment">//(index)</span></span><br><span class="line"><span class="keyword">int</span> n = array.size();</span><br></pre></td></tr></table></figure><h3 id="map">Map</h3><ul><li><code>HashMap</code> 的 <code>key</code>必须实现<code>equals()</code> 和 <code>hashCode()</code> 方法。</li><li>有序 map 必须实现<code>Comparable</code> 接口；或者在声明时传入一个<code>Comparator</code> 接口，里面声明<code>compare</code> 函数</li><li>无序的 <code>HashMap</code>基于哈希表实现， 有序的 <code>TreeMap</code>基于红⿊树实现 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无序map</span></span><br><span class="line">Map&lt;String, Integer&gt; mapper = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">mapper.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">mapper.containsKey(ch);</span><br><span class="line">mapper.get(key);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (String key : mapper.keySet());</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : mapper.entrySet());</span><br><span class="line"><span class="keyword">for</span>(String value: mapper.valueSet());</span><br><span class="line"><span class="comment">//有序map</span></span><br><span class="line">Map&lt;String, Integer&gt; order_map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础的使用map计数出现次数</span></span><br><span class="line">Map&lt;Integer, Integer&gt; mapper1 = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: arr)&#123;</span><br><span class="line">            mapper1.put(num, occur.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="set">Set</h3><ul><li>只会存储 <code>key</code> 的值。</li><li>需要正确实现<code>equals()</code>和<code>hashCode()</code>方法。</li><li>有序的Set还要实现<code>Comparable</code> 接口； 或者在声明时传入一个<code>Comparator</code> 接口，里面声明<code>compare</code> 函数</li><li><code>HashSet</code>基于哈希表实现， <code>TreeSet</code>基于红黑树实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无序Set</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"123"</span>);</span><br><span class="line">set.contains(<span class="string">"123"</span>);</span><br><span class="line">set.remove(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> n = set.size();</span><br><span class="line"><span class="comment">//有序</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="queue">Queue</h3><ul><li>实现类为 <code>LinkedList</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>&gt; que = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">int</span> n = que.size();</span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.add();</span><br><span class="line">que.remove();</span><br><span class="line">que.element();</span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offer();</span><br><span class="line">que.poll();</span><br><span class="line">que.peel();</span><br></pre></td></tr></table></figure><p>注意有两套方法，对应不同的情况。</p><h3 id="priorityqueue">PriorityQueue</h3><ul><li>放入的元素需要实现<code>Comparable</code>，或者提供一个<code>Comparator</code>对象来判断两个元素的顺序。</li><li>PriorityQueue：基于堆结构实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类与接口分离</span></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.add();</span><br><span class="line">que.remove();</span><br><span class="line">que.element();</span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offer();</span><br><span class="line">que.poll();</span><br><span class="line">que.peek();</span><br></pre></td></tr></table></figure><h3 id="deque">Deque</h3><ul><li>deque 是用 <code>LinkedList</code>实现的接口，赋予了不同的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throw exception</span></span><br><span class="line">que.addLast(); <span class="comment">//addFirst</span></span><br><span class="line">que.removeLast(); <span class="comment">//removeFirst</span></span><br><span class="line">que.getLast(); <span class="comment">// getFirst</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return false or null</span></span><br><span class="line">que.offerLast(); <span class="comment">//offerFirst</span></span><br><span class="line">que.pollLast(); <span class="comment">//pollLast</span></span><br><span class="line">que.peekLast(); <span class="comment">//peekLast</span></span><br></pre></td></tr></table></figure><h3 id="stack">Stack</h3><ul><li>stack 是用<code>Deque</code>接口来模拟的，原来的stack被不推荐使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stack.isEmpty();</span><br><span class="line">stack.pop();</span><br><span class="line">stack.push(ch);</span><br><span class="line">stack.peek()</span><br></pre></td></tr></table></figure><h3 id="并发容器">并发容器</h3><h4 id="concurrenthashmap">ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code> 是线程安全的 Map。</p><p><code>ConcurrentHashMap</code>采⽤锁分段技术，将整个 <code>Hash</code>数组分成几个小的 segment，在每个 <code>segment</code>分别上锁。在插⼊元素的时候就需要先找到应该插⼊到哪⼀个⽚<code>segment</code>，然后对该 <code>segment</code>上锁并操作。这样做明显减小了锁的粒度。</p><p><code>HashTable</code> 同样是线程安全的，然而其使用了<code>synchronized</code> 关键字对 <code>get</code> 和<code>put</code> 等操作进行加锁，也就是每一次操作都会锁住整个 <code>Hash</code>表，每个线程独占哈希表，效率低下。</p><h4 id="copyonwritearraylist">CopyOnWriteArrayList</h4><p>线程安全的 List。所有可变操作（<code>add</code>，<code>set</code>等等）都是通过创建底层数组的新副本来实现的。当需要修改的时并不直接修改原有内容，⽽是对原有数据进⾏⼀次复制，将修改的内容写⼊副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。读取操作没有任何同步控制和锁操作，因此可以保证数据安全。</p><p>此外，写⼊操作在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会复制出多个副本。</p><h4 id="blockingqueue">BlockingQueue</h4><p>提供了可阻塞的插入和移除方法。当容器队列已满时，插入线程会被阻塞，直到队列有新的空余位置产生；当队列为空时，移除线程会被阻塞，直到队列中有新的元素。</p><h4 id="concurrentlinkedqueue">ConcurrentLinkedQueue</h4><p>高效的并发队列，基于链表实现。是一个非阻塞队列</p><h3 id="继承关系">继承关系</h3><p>橙色为类，蓝色为接口。</p><p><code>List</code>， <code>Queue</code>， <code>Set</code>类</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210824100823.png" alt="image-20210824100823589" style="zoom:80%;"></p><hr><p><code>Map</code> 类</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816164347.png" alt="image-20210816164347532" style="zoom:80%;"></p><p><strong>参考链接</strong></p><ul><li><a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java 集合的使用方式
    
    </summary>
    
      <category term="基础知识" scheme="https://github.com/maneback/maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="https://github.com/maneback/maneback.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务管理与锁</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/db-lock/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/db-lock/</id>
    <published>2021-08-12T02:57:18.000Z</published>
    <updated>2021-08-19T10:19:59.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数据库的事务与锁">数据库的事务与锁</h2><h3 id="事务及其性质">事务及其性质</h3><p>事务必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。</p><ol type="1"><li>原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；</li><li>一致性指的是事务的执行结果必须是使数据库从一个一致性状态变成另一个一致性状态，一致性和原子性是密切相关的；</li><li>隔离性指的是一个事务执行不能被其他事务干扰；</li><li>持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</li></ol><h4 id="事务隔离级别">事务隔离级别</h4><p>数据库的隔离级别可以分为：<strong>读未提交、读提交、可重复读和串行化</strong>。</p><blockquote><p>在学习这里的时候，总感觉说得满头雾水的，怎么也不能理解，因为它又联系着三个现象： <strong>脏读、不可重复读、幻读</strong>。</p></blockquote><p>当时很难理解隔离级别与现象之间的关系，现象可以理解为多个事务并发时候如不哦不加控制而导致的<strong>问题</strong>。隔离级别是为了避免其中的某种或某几种问题而设置的一种<strong>执行要求</strong> 或<strong>执行流程</strong>。</p><p>我们假设有两个事务 A 和 B 在进行读写操作。先来看现象：</p><ul><li><p><strong>脏读</strong>： B读到了A未提交的修改数据 A修改未提交—B读—A回滚 （A写的时候B读），这时候B读到的就是错误的数据。</p></li><li><p><strong>不可重复读</strong>： 在两次读之间插入了另一个事务的修改操作，并提交，导致两次读取不一致。 （A读的时候B写）</p></li><li><p><strong>幻读</strong>：在两次读取之间，出现了 INSERT 操作。 A读—–B插入—–A读。两次读取不一致。</p></li></ul><p>不可重复读与幻读之间的区别在于，A 两次读之间的差别，是由于 <strong>UPDATE</strong> 操作还是由 <strong>INSERT</strong> 操作引起的。</p><p>那么为了避免这些问题的发送，数据库设计了不同的事务隔离级别。</p><ul><li><p><strong>读未提交</strong>：一个事务可以读取另一个未提交事务的数据</p><p>这种情况下不会带来任何的隔离，三种情况都可能发生。</p></li><li><p><strong>读提交</strong>：一个事务要等另一个事务提交后才能读取数据（<strong>避免脏读</strong>）（给修改加锁禁止读）</p><p>B无法读到A未提交的修改，避免了脏读。</p></li><li><p><strong>可重复读</strong>：读取事务开始后，不允许修改（<strong>避免不可重复读</strong>）（读加锁禁止修改）</p><p>A在读取的时候，B只能读，不能改，可以保证A读取的过程的一致性。</p><p>但是只能锁住表中已有的行，而不能阻止其他事务的插入，无法避免幻读。</p></li><li><p><strong>串行化</strong>：每个事务完全串行化进行。（<strong>避免幻读</strong>）</p></li></ul><p>MySQL 默认的事务隔离级别为 可重复读。</p><p>事务隔离级别和可能存在的问题如下：</p><table><thead><tr class="header"><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr class="odd"><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>读已提交</td><td></td><td>√</td><td>√</td></tr><tr class="odd"><td>可重复读</td><td></td><td></td><td>√</td></tr><tr class="even"><td>串行化</td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="锁">锁</h3><p>数据库锁出现的原因是为了处理并发问题。数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制。</p><p>数据库的锁根据不同的分类角度可以由不同的分类：</p><ul><li>从使用角度： 乐观锁与悲观锁</li><li>从数据库机制上：共享锁与排它锁</li><li>从锁的粒度上： 行级锁和表级锁</li></ul><h5 id="悲观锁与乐观锁">悲观锁与乐观锁</h5><ul><li>悲观锁：假定会发生并发冲突，在最整个数据处理过程中都将数据处于锁定的状态。 适用于写操作多的场景。</li><li>乐观锁：假设不会发生并发冲突，只有在提交时检查是否违反数据的完整性。适用于读操作多的场景。</li></ul><h5 id="排它锁与共享锁">排它锁与共享锁</h5><ul><li>排它锁：也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。</li><li>共享锁：也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。</li></ul><h4 id="行级锁与表级锁">行级锁与表级锁</h4><ul><li>行级锁： 是粒度最小的一种锁，只会对当前进行操作的行进行加锁，能够大大减少数据库操作的冲突，并发度最高，同时有可能出现死锁。但是加锁慢，开销也最大。</li><li>表级锁：是粒度最大的一种锁，会对当前进行操作的整个数据表进行加锁。但是实现简单，加锁快，消耗资源少。发生锁冲突的概率最高，并发度最低。</li><li>页面锁：粒度介于行级锁和表级锁之间；会出现死锁，并发度一般。</li></ul><h5 id="二阶段锁">二阶段锁</h5><p>每个事务分两个阶段提出加锁和解锁申请。最初处于加锁阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，并且不能再发出加锁请求。<strong>二阶段封锁并不会保证不发生死锁</strong>（如果请求锁的数据顺序不同）。</p><p>引入2PL是为了保证事务的隔离性，<strong>保证并发调度的准确性</strong>，多个事务在并发的情况下依然是串行的。</p><h4 id="锁与隔离级别">锁与隔离级别</h4><ul><li>在 RU 中，读取数据不需要加锁，这样读写都没有被保护。</li><li>在 RC 中，写过程需要排他锁，禁止读进程读取到未提交的修改。</li><li>在 RR 中，读过程需要加共享锁，这是可以几个进程共享地读，但是禁止被修改，可以保证一个事务中读到的数据是一致的。</li></ul><hr><h3 id="mvcc版本控制">MVCC版本控制</h3><p><strong>多版本并发控制（MVCC）</strong> 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。简单来说，<strong>MVCC</strong> 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。 是乐观锁的一种实现方式。</p><p>MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的创建版本号，一个保存了行的删除版本号。每开启一个新的事务，系统版本号都会自动递增，作为事务的版本号。</p><ul><li><p>MVCC读写不冲突不加锁，写写之间互相冲突需要加锁串联执行。（乐观锁）</p></li><li><p>select</p><p>只会查找版本号小于等于当前事务版本的数据行。这样保证事务读取的是之前已经存在的或是事务自身插入的。</p></li><li><p>insert</p><p>每插入新的一行，都保存当前的系统版本号作为行的版本号。</p></li><li><p>delete</p><p>为删除的每一行保存当前系统版本号作为行删除版本号。</p></li><li><p>update</p><p>插入一条新的记录，保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行作为删除版本号。</p></li></ul><h5 id="mvcc-解决了哪些问题">MVCC 解决了哪些问题</h5><ol type="1"><li>读写阻塞问题：MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率：读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li></ol><h5 id="快照读与当前度">快照读与当前度</h5><p>MVCC 版本控制引入了一个新的概念：即快照读与当前读的区别。</p><p><strong>快照读</strong>（SnapShot Read） 是一种一致性不加锁的读，是InnoDB并发如此之高的核心原因之一。</p><blockquote><p>这里的<strong>一致性</strong>是指，事务读取到的数据，要么是<strong>事务开始前就已经存在的数据</strong>，要么是<strong>事务自身插入或者修改过的数据</strong>。</p></blockquote><p>不加锁的简单的 SELECT 都属于<strong>快照读</strong>。</p><p>与 <strong>快照读</strong> 相对应的则是 <strong>当前读</strong>，<strong>当前读</strong>就是读取最新数据，而不是历史版本的数据。加锁的 SELECT 就属于当前读，例如：</p>]]></content>
    
    <summary type="html">
    
      介绍数据库的事务管理，锁以及MVCC
    
    </summary>
    
      <category term="基础知识" scheme="https://github.com/maneback/maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="database" scheme="https://github.com/maneback/maneback.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/db-index/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/db-index/</id>
    <published>2021-08-12T02:56:04.000Z</published>
    <updated>2021-09-07T01:19:23.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="索引的数据结构">1 索引的数据结构</h3><p>MySQL的底层存储引擎支持 InnoDB 和 MyISAM 两种，而默认存储引擎 InnoDB 采用的是B+树来作为索引的存储结构。</p><p><strong>那么为什么 InnoDB 存储引擎会使用 B+ 树来存储数据</strong> ，而不是采用 <strong>B- 树</strong>、<strong>红黑树</strong> 或是 <strong>AVL 树</strong> 来存储索引？</p><h3 id="数据结构的比较">2 数据结构的比较</h3><p>MySQL需要把数据持久化到磁盘上，因此需要频繁地读取磁盘上的数据，因此磁盘 IO 的次数很大程度上决定了查询效率，磁盘 IO 每次以<strong>页</strong>为单位进行。</p><p>对于大规模数据的索引来讲， 红黑树和 AVL 的结构往往会导致 <strong>深度过大</strong> 而造成磁盘 IO 次数增多导致效率低下。同时为了保证平衡会进行频繁的结构调整。而B-树和B+树的特点是每一个层的节点数量更多，树的层数更小，这样查询的时候就能够减少磁盘 IO 的次数。</p><p>另外B-树的非叶子节点都存有数据域，这无疑增加了非叶子节点的大小，而减少了每一磁盘页中所能容纳的节点数量；而B+树只有叶子结点来存储数据，节点更小，从而磁盘页能够存储更多的节点，磁盘 IO 次数更少。</p><p>除此之外，深入分析数据库索引和底层的存储结构能发现B-树和B+树更重要的区别。</p><h3 id="数据库存储结构">3 数据库存储结构</h3><h4 id="b-树">① B-树</h4><p>对于 InnoDB 来说，所有的数据都是以键值对（key-data）的方式存储的，主键索引和辅助索引在存储数据时会将 <code>id</code> 和 <code>index</code> 作为键，将所有列和 <code>id</code> 作为键对应的值。 这个key就是存储在B+树非叶子节点中的值。在B-树中除了键外，还会存储data值。</p><p>再提一次这句话： <strong>B-树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中。</strong></p><p>在B-树中，由于所有的节点都可能包含目标数据，我们总是要不止一次地从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 IO，也是 B-树最大的性能问题。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816090826.png" alt="image-20210816090826822" style="zoom:50%;"></p><p>如上：如果我要查找 【<strong>位于4到16之间的所有值</strong>】的时候，就需要：</p><ul><li>加载 node1 所在的页</li><li>找到指向 node2 的指针，并加载所在页，遍历页面中的数据，发现还没找全；</li><li>再一次加载 node1 所在的页，发现还没找全；</li><li>找到指向 node3 的指针，并加载所在也，遍历页面中的数据，完成查找。</li></ul><p>这样一来，如果范围查询需要跨越不同的节点，都需要从根节点向下遍历所有子节点来查找。会经历多次磁盘 IO。</p><h4 id="b-树-1">② B+ 树</h4><p>而使用 B+树，所有的节点都储存在叶子节点中，此外通过构建树的过程中， 还可以保证每一个叶子节点中的数据都是有序（按照键值排序）的，所以我们还可以在叶子节点中增加一个（双向）的指针，来指向相邻节点。如图中每个灰色节点都代表磁盘上存储数据的一个页。这样当出现跨页的时候，就不需要从根节点从上至下查找了，只需要根据指针找到下一页。</p><p>此外也可以发现，由于 B+ 树中所有的数据都连在叶子节点上，那么对于所有的查询来讲，其查询时间即查询层数都是相等的，比较稳定。B+ 树是数据库底层的真实数据存储结构。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210816092140.png" alt="image-20210816092140647" style="zoom:50%;"></p><h4 id="聚簇索引与非聚簇索引">③ 聚簇索引与非聚簇索引</h4><p><strong>聚簇索引</strong></p><p>在数据库中，我们可能会根据需要建立多个不同用途的索引，每个索引都是组成像上述B+树的结构，但是实际上在硬盘中只会存储一份数据文件。像上述图中这样把索引与数据建在一起的索引称为<strong>聚簇索引</strong>。</p><p><strong>聚簇索引默认建立在数据表的主键上。</strong></p><p><strong>非聚簇索引</strong></p><p>当再建立新的索引时，就不需要存储data文件了，而是只需要存储索引结构，这种索引与数据分离的就成为 <strong>非聚簇索引</strong> 。这时候每个叶子结点存储的不是 data 而是指向聚簇索引的 key值，通过 key 值再反过来查找聚簇索引。也就是需要二次查找。</p><p><strong>覆盖索引</strong></p><p>当一个语句检索的列只包含建立非聚簇索引的列及主键，这样在非聚簇索引的结构中就包含了我们需要的全部数据项，不用再去二次查找聚簇索引了。</p><p><strong>最左匹配原则</strong> <a label="left"></a></p><p>在建立联合索引时，如 <code>(a,b,c)</code>上建立索引，会先对 <code>a</code> 进行排序，在此基础上对 <code>b</code>排序，最后是 <code>c</code>。因此 <code>a</code> 是有序的，而 <code>b</code> 和<code>c</code> 无序。简单理解的话，假设<code>a,b,c</code>的取值范围都是 <code>0~9</code> 那么在建立索引的时候就是把 <code>a</code>放在百位，把<code>b</code>放在十位，把<code>c</code>放在个位，再对这些数字排序。</p><p>联合索引在检索数据是，会从索引的最左边开始匹配，直到匹配到 <code>where</code> 子句中一个无法使用索引的条件。</p><p>所以单独对<code>a</code>进行检索，可以使用上述索引<code>abc</code>，但是对<code>b,c</code>单独检索，则无法使用。索引的匹配一定是与索引建立时候的顺序是一致的。</p><p>此外，对 <code>a,c</code> 进行检索，则只能对 <code>a</code>使用索引，而<code>c</code>则不能。</p><p>（<strong>这里不考虑无法使用索引的条件，只是说明匹配原则。</strong>）</p><h4 id="b树与b树的对比">④ B树与B+树的对比</h4><ol type="1"><li>B 树只适合随机检索， B+ 树同时支持随机检索和顺序检索。</li><li>B+ 树节点的利用效率更高，可减少 IO 次数，磁盘读写代价更低。</li><li>B+ 树的查询效率更加稳定。B 树的查询过程可能在非叶子节点结束；B+ 树的查询全部在叶子节点结束。</li><li>B 树在提高 IO 性能的同时并没有解决元素遍历效率低下的问题。进行范围查询，当元素存储在不同的磁盘页上时，需多次从根节点开始查找；而 B+ 树的叶子节点使用双指针连接在一起，且是有序的，只要遍历叶子结点就能实现整棵树的遍历。</li></ol><h3 id="索引失效的情况">4. 索引失效的情况</h3><p>在一定条件下，索引可能会失效，即无法通过索引来加速查询过程。</p><ul><li>where 子句中进行 NULL 判断</li><li>where 子句中使用 <code>!=, &lt;&gt;, not</code> 这样的判断</li><li>避免在 where 子句中使用 or， 如果其中一个字段没有索引的话，将放弃使用索引</li><li>避免在 where 子句中使用 <code>in</code></li><li>避免在 where 子句中<code>=</code>的左边使用表达式操作或者函数操作</li><li>避免在 where 子句中使用 ‘like’ 模糊查询</li><li>联合索引的<a href="#left">最左原则</a></li></ul><h3 id="myisam-与-innodb-的索引的区别">5. MyISAM 与 InnoDB 的索引的区别</h3><h5 id="myisam">MyISAM</h5><ul><li>主键索引：MyISAM 引擎使用B+树作为主键索引结果，叶节点的data域存放的是数据记录的<strong>地址</strong>。</li><li>辅助索引：MyISAM 的辅助索引在结构上跟主键索引没有什么区别，只是辅助索引的 key 可以重复，同样节点的data 域存放数据记录的地址。</li></ul><h5 id="innodb">InnoDB</h5><ul><li>主键索引： InnoDB 表数据文件本身就是一个索引结构，树的叶节点data域保存了完整的数据记录，即主键索引是<strong>聚集索引</strong>。</li><li>辅助索引： InnoDB 的所有辅助索引也构成一个B+ 树来存放，叶节点的data域存放的是数据记录的<strong>主键</strong>。即辅助索引需要通过这个主键再去二次检索主键索引。</li></ul><h3 id="数据库存储引擎的对比">6. 数据库存储引擎的对比</h3><ol type="1"><li><strong>事务支持</strong>： InnoDB 支持事务，MyISAM 不支持事务。</li><li><strong>外键支持</strong>： InnoDB 支持外键，而 MyISAM 不支持。</li><li><strong>索引支持</strong>： InnoDB 是聚集索引，MyISAM 是非聚集索引。</li><li><strong>锁支持</strong>： InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。</li><li><strong>恢复</strong>： 系统崩溃后，MyISAM恢复起来更困难。</li><li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li><li>innoDB所有的表在磁盘上保存在一个文件中；myISAM存储成三个文件。</li></ol><blockquote><p>6.1 如何选择</p></blockquote><ol type="1"><li>如果要支持事务，选择 InnoDB。</li><li>如果大多是只是读查询，可以考虑MyISAM。如果既有读写也挺频繁，请使用InnoDB。</li></ol><h3 id="索引的设计原则">7. 索引的设计原则</h3><ol type="1"><li>符合<strong>最左前缀</strong>原则。联合索引时候，MySQL会匹配所有的等式条件直到第一个范围查询（<code>&gt;</code>, <code>&lt;</code>, <code>between</code>, <code>like</code>） 这些就停止匹配。</li><li>更新频繁的字段不适合创建索引</li><li>较为频繁被查询的字段才适合创建索引</li><li>对于查询中很少涉及到的列，重复值较多的不要建立索引</li><li>不能有效区分数据的列不适合建立索引（如性别）</li><li>尽量地扩展索引，而不是新建索引</li><li>定义外键的数据列一定要创建索引</li><li>适合索引的列是出现在 <code>where</code> 子句的列，或者是连接子句中指定的列</li><li>使用短索引，如果对长字符串建立索引，应该指定一个前缀长度，这样能节省索引空间。</li><li>不要过度索引。索引需要占用存储空间。此外增删改操作都需要重新更新索引，会带来额外的时间消耗。</li></ol><h3 id="其他小问题">8. 其他小问题</h3><ol type="1"><li>为什么主键通常建议使用自增id</li></ol><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。</p><p>如果主键不是自增id，在不断地插入数据的过程中主键值是完全随机的，就需要不断地调整数据的物理地址、分页。而使用自增id作为主键，可以保证，相邻插入的数据一定保存在磁盘中相邻的位置，避免聚集索引的不断调整。</p><ol start="2" type="1"><li>默认聚簇索引</li></ol><p>聚簇索引<strong>默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。</p><ol start="3" type="1"><li>聚簇索引的劣势</li></ol><p><strong>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页 (page split) 的时候</strong>。如果使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用<code>int</code>类型的<code>auto_increment</code>作为主键。</p><ol start="3" type="1"><li>索引的优缺点</li></ol><ul><li>优点：加快查询速度</li><li>降低增删改速度，存储索引需要占用额外的空间。</li><li>每当数据库中有记录插入或删除时，索引都需要更新。如果有记录更新，任何搜索码属性受影响的索引也必须更新。</li></ul><hr><p><strong>参考链接</strong></p><ul><li><a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/" target="_blank" rel="noopener">为什么 MySQL 使用 B+ 树</a></li><li><a href="https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html" target="_blank" rel="noopener">菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      介绍数据库的索引结构
    
    </summary>
    
      <category term="基础知识" scheme="https://github.com/maneback/maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="database" scheme="https://github.com/maneback/maneback.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>TCP 相关知识</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/network-TCP/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/network-TCP/</id>
    <published>2021-08-11T07:22:29.000Z</published>
    <updated>2021-08-27T02:01:33.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>TCP 是一种面向连接的网络层传输协议，它建立在不可靠的 IP 层之上，向上层应用层提供可靠的传输服务。</p><p>它是面向字节流的传输。</p><p>TCP 报文头部：</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210819155803.png"></p><h4 id="可靠传输">可靠传输</h4><p>其可靠传输主要依赖于以下几方面实现：校验和、序列号和确认序号、三次握手建立连接、超时重传、流量控制、拥塞控制。</p><h5 id="三次握手">三次握手</h5><ol type="1"><li>客户端 发送建立连接请求，设置 <code>SYN=1</code>， 初始化序列号 <code>seq=x</code>，发送请求连接报文给 服务端，然后客户端 进入 <code>SYN_SENT</code> 状态，等待服务器确定。</li><li>服务端 接收到 客户端 的 <code>SYN</code> 报文，对该报文进行确认，设置 <code>ACK=1</code>。 同时还要发送自己的 SYN 报文，设置 <code>SYN=1</code>, seq=y， 将确认报文和 SYN 报文合并到同一个报文中，发送给 客户端， 此时 服务端 进入 <code>SYN_RECV</code> 状态。</li><li>客户端 收到 服务端 的 <code>SYN_ACK</code> 报文后，向 <code>sever</code> 发送<code>ACK</code>报文，将 <code>ACK=1</code>，发送给服务端， 服务端接收到报文后，都进入建立状态，完成三次握手。</li></ol><div id="sequence-0"></div><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210819163508.png"></p><h5 id="四次挥手">四次挥手</h5><p><strong>TCP断开连接都由用户请求。</strong></p><ol type="1"><li>客户端 发送数据完成后，向服务端发送释放连接报文，报文 FIN=1， 发送后，客户端只能接受数据，不能发送。客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到释放连接报文后，向客户端发送 ACK 报文，报文 ACK=1。此时服务端能向客户端单向传输数据。进入 <code>CLOSE_WAIT</code> 状态。客户端收到后，进入 <code>FIN_WAIT_2</code> 状态。</li><li>客户端完成数据发送后，向客户端发送释放连接报文， 报文 FIN=1, ACK=1。 进入<code>LAST_ACK</code> 状态。</li><li>客户端收到释放连接报文后，向服务端发送 ACK 报文，报文 ACK=1。进入 <code>TIME_WAIT</code> 状态。等待两个 MSL 长度后，关闭连接。</li></ol><div id="sequence-1"></div><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210819163519.png"></p><h5 id="连接相关问题">连接相关问题：</h5><h6 id="为什么不能两次握手">为什么不能两次握手？</h6><p>三次握手是为了保证双方都能确认自己和对方都能正常的发送和接收。考虑丢失，如果第二个报文丢失，则客户端认为还没有建立连接，而在服务端看来已经正常建立连接，这样会浪费服务端的资源。</p><h6 id="为什么关闭四次">为什么关闭四次</h6><p>因为要确保双方都能通知对方释放连接。第一次是断开客户端到服务端的单向连接，而此时服务端可能还没发送完所有数据，还要继续发送。当服务端发送完成后，再通知客户端断开连接。同时每一次释放连接的报文都需要分别收到对方的确认报文。其实是，在建立连接时，服务端的 ACK 和 SYN 都在第二次的握手过程中一次性完成了，而在断开连接时，则要先传 ACK， 等自己发送完成后才能传 SYN。所以需要四次。</p><h6 id="为什么-需要等待-2msl">为什么 需要等待 2MSL</h6><p>可以使每次 TCP 连接的报文全部消失，不会出现在下一次的 TCP 连接中。</p><p>如果第四次握手信息丢失，则服务端无法收到客户端的确认信息，就需要重发第三次握手的报文。如果此时客户端已关闭，则会导致服务端无法正常关闭。</p><h6 id="syn-flood-攻击">SYN flood 攻击</h6><p>如果恶意地向某个服务器端口发送大量的SYN包而并不完成建立连接的全过程，则可以使服务器打开大量的半开连接，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。</p><h5 id="流量控制">流量控制</h5><h6 id="什么情况下需要流量控制">什么情况下需要流量控制？</h6><p>流量控制是为了避免接收方缓冲区溢出造成的丢包。如果发送端发送的数据过快，接收端来不及接收就会出现丢包，这时就要用到流量控制，避免因接收端缓冲区溢出的丢包。</p><p>如图所示，在TCP首部有一个窗口大小字段，表示当前接收端缓冲区的大小。每当接收端发送ACK报文时，会将窗口大小填入其中，发送方会根据窗口大小调整发送速度。当窗口大小为0， 发送方会停止发送数据。</p><h6 id="流量控制出现死锁怎么办">流量控制出现死锁怎么办？</h6><p>发送方在接收到一个窗口大小为0的ACK报文后，发送方便停止发送，等待下一个ACK。但是如果下一个ACK丢失，则发送方就会一直等待下去，而接收方会认为发送方已经收到该ACK，等待新数据，便会产生死锁。</p><p>为避免死锁的发生，TCP采用计时器，当接收到一个零窗口的ACK后便启动计时器，一旦到达计时器的实践便主动询问接收方窗口大小，如果仍返回零则继续等待，若窗口不为零则开始发送。</p><h5 id="拥塞控制">拥塞控制</h5><h6 id="什么时候需要拥塞控制">什么时候需要拥塞控制</h6><p>拥塞控制是为了避免网络状况拥塞造成的丢包。 注意其与流量控制的作用的不同之处。</p><h6 id="拥塞控制方法">拥塞控制方法</h6><p>拥塞控制方法主要包括：<strong>慢启动、拥塞避免。快速重传。快速恢复。</strong></p><ul><li><p>慢启动</p><p>发送方维持一个叫做拥塞窗口<code>cwnd</code>的变量，取决于网络的拥塞程度，并在不断变化。注意由于可能存在接收方的流量控制的缓冲区窗口，所以发送方的真正的发送窗口可能小于拥塞窗口。</p><p>慢启动的思想就是不要一开就发送大量数据，而是不断增加发送的数据的大小，不断试探一下网络的拥塞程度。</p><p>在慢启动中<code>cwnd</code>的每次加倍</p></li><li><p>拥塞避免</p><p>当拥塞窗口<code>cwnd</code>增加到一定程度超过门限值<code>ssthresh</code>后，再每次倍增则风险太高。这时就进入慢启动阶段</p><p>在拥塞避免中<code>cwnd</code>每次增加一</p><p>当判断网络出现拥塞（根据没能按时收到<code>ACK</code>）则开始把拥塞避免的门限<code>ssthresh</code>变为<strong>出现拥塞时发送窗口的一半</strong>。并将拥塞窗口置为一，重新进入慢启动。</p></li><li><p>快速重传</p><p>若接收方连续收到三个重复确认则立即重传对方尚未接收到的报文段，而不必继续等待计时器时间到期。（因为这表明是发生了丢包，而不是网络延迟大）</p></li><li><p>快速恢复</p><p>在拥塞避免时，一旦发送拥塞则<code>cwnd</code>重置为慢启动阶段，为提高性能则把<code>cwnd</code>设置为<code>ssthresh</code>减半后的值，而不是重新从头开始进入慢启动。</p></li></ul><h5 id="总结">总结</h5><p>注意到流量控制会存在一个流量控制窗口，而拥塞控制中同样存在一个拥塞控制窗口，因此在实际传输时，TCP 传输窗口的大小取决于这两个值的最小值。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant  Client as ccparticipant  Server as ssnote left of cc: SYN_SENTcc-->ss: SYN=1 seq=xnote right of ss:SYN_Rcvdss-->cc: ACK=1 SYN=1  ack=x+1 seq=ynote left of cc: ESTABLISHEDcc-->ss: ACK=1 seq=x+1 ack=y+1note right of ss: ESTABLISHED</textarea><textarea id="sequence-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">title: 四次挥手participant Client as ccparticipant Server as ssnote left of cc: FIN_WAIT_1\n[close()]cc->ss:FIN=1     ACK=1note right of ss: CLOSE_WAITss->cc: ACK=1 note left of cc: FIN_WAIT_2ss->cc: FIN=1     ACK=1note right of ss: LAST_ACKcc->ss: ACK=1note left of cc: TIME_WAITnote left of cc: WAIT FOR 2MSL  close</textarea><textarea id="sequence-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script>]]></content>
    
    <summary type="html">
    
      TCP 知识： 三次握手、四次挥手、流量控制、拥塞控制
    
    </summary>
    
      <category term="基础知识" scheme="https://github.com/maneback/maneback.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Network" scheme="https://github.com/maneback/maneback.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>排序算法汇总</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/sortings/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/sortings/</id>
    <published>2021-07-22T02:01:30.000Z</published>
    <updated>2021-08-16T08:58:06.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比总结常见的排序算法：</p><p>选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序</p><a id="more"></a><h4 id="排序算法">排序算法</h4><p>均默认为升序排列。</p><h5 id="选择排序">选择排序</h5><p>每次遍历数组，找到未排序中的最小元素，然后放到已排序的末尾位置，直到所有的元素均排序完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        print(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="冒泡排序">冒泡排序</h5><p>每次比较两个相邻元素，较大的元素每次移动一个位置，不断地冒泡到数组末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):</span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>]&gt;nums[j]:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="插入排序">插入排序</h5><p>每次选择一个数，在前面已排序好的序列中寻找该数字应该所在的位置，并向后移动部分已排序数字，将新数字插入到相应位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        idx = c</span><br><span class="line">        n = nums[c]</span><br><span class="line">        <span class="keyword">while</span> idx&gt;<span class="number">0</span> <span class="keyword">and</span> nums[idx<span class="number">-1</span>]&gt;n:</span><br><span class="line">            nums[idx] = nums[idx<span class="number">-1</span>]</span><br><span class="line">            idx-=<span class="number">1</span></span><br><span class="line">        nums[idx] = n</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="希尔排序">希尔排序</h5><p>希尔排序是对插入排序的改进版。在插入排序中， 数字每一次只能移动一个位置，而希尔排序是增加移动间隔，使较小的数字能更加快速地移动到队列头部。</p><p>具体算法描述如下：</p><ul><li><p>选择一个增量序列 <span class="math inline">\(g_1 &gt; g_2&gt;\cdots&gt; g_k\)</span> 且 <span class="math inline">\(g_k=1\)</span>。</p></li><li><p>对于每一个增量<span class="math inline">\(g\)</span>, 进行一次排序。</p></li><li><p>在每次排序中，按照间隔进行一次插入排序。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap=n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            i = c</span><br><span class="line">            <span class="keyword">while</span> i-gap&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i-gap]&gt;gap:</span><br><span class="line">                nums[i-gap], nums[i] = nums[i], nums[i-gap]</span><br><span class="line">                print(nums)</span><br><span class="line"></span><br><span class="line">                i-=gap</span><br><span class="line">        gap = gap//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="归并排序">归并排序</h5><p>归并排序是一种分治思想，先将数组分为子序列，缩小问题规模，让每个子序列各自有序，然后再将有序的子序列合并成一个完整数组。这样每一次的问题规模都变为原问题的 1/2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">            <span class="keyword">if</span> left[l]&lt;right[r]:</span><br><span class="line">                res.append(left[l])</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[r])</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">        res += left[l:]</span><br><span class="line">        res += right[r:]</span><br><span class="line">        print( res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = n//<span class="number">2</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><h5 id="快排">快排</h5><p>快排是选取一个哨兵位置，将小于哨兵的数据全部放到左边，将大于哨兵的数据全放到右边，然后再用相同的思想对左右两边继续排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        <span class="comment"># print(left, right)</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;=right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;nums[pivot]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=nums[pivot]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        quick(left, j<span class="number">-1</span>)</span><br><span class="line">        quick(j+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h5 id="计数排序">计数排序</h5><p>计数排序是开辟额外的空间来存储每个值的出现次数，然后再根据计数填充数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    _min = min(nums)</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    tmp_arr = [<span class="number">0</span>]*(_max-_min+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_arr[nums-_min]+=<span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> tmp_arr[j]==<span class="number">0</span>:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        nums[i] = j+_min</span><br><span class="line">        tmp_arr[j] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="堆排序">堆排序</h5><p>堆排序是使用了堆这个数据结构来进行的排序算法。把一维的数组想象成一个二叉树（堆）结构。</p><p>过程如下：</p><ol type="1"><li>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；</li><li>交换堆顶和最后一个元素，重新调整堆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, startops, endops)</span>:</span></span><br><span class="line">        pos = startops</span><br><span class="line">        childops = pos*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> childops&lt;endops:</span><br><span class="line">            rightops = childops+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightops&lt;endops <span class="keyword">and</span> nums[rightops]&gt;nums[childops]:</span><br><span class="line">                childops = rightops</span><br><span class="line">            <span class="keyword">if</span> nums[childops]&gt;nums[pos]:</span><br><span class="line">                nums[pos], nums[childops] = nums[childops], nums[pos]</span><br><span class="line">                adjust_heap(nums, childops, endops)</span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 从后往前即低向上</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n//<span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i,n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="基数排序">基数排序</h5><p>基数排序是针对数字每一位进行排序，从最低位开始排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    max_digit = len(str(_max))</span><br><span class="line">    buckList = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    div, mod = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckList[num%mod//div].append(num)</span><br><span class="line">        div *= <span class="number">10</span></span><br><span class="line">        mod *= <span class="number">10</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        print(buckList)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> buckList[j]:</span><br><span class="line">                nums[idx] = item</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            buckList[j] = []</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="对比">对比</h5><p>下面对排序算法做一个总结和对比。</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814104124.png" alt="image-20210814104124495"><figcaption aria-hidden="true">image-20210814104124495</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对比总结常见的排序算法：&lt;/p&gt;
&lt;p&gt;选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="排序算法" scheme="https://github.com/maneback/maneback.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/beibao/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/beibao/</id>
    <published>2021-06-15T11:22:56.000Z</published>
    <updated>2021-08-16T08:57:34.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="问题描述">问题描述</h3><p>对于背包问题，是求在具有容量（质量体积个数）约束的情况下，求所有商品满足约束的<strong>可行性解、最优解或解的个数</strong>。</p><h4 id="一般化描述">一般化描述</h4><p>本文关注于 0-1 背包问题，即：每个物品只有一个。</p><blockquote><p>物品总数 <span class="math inline">\(n\)</span></p><p>背包容量 <span class="math inline">\(W\)</span></p><p>物品质量 <span class="math inline">\(w_i\)</span></p><p>物品价值 <span class="math inline">\(p_i\)</span></p></blockquote><p>总质量约束为 <span class="math inline">\(W\)</span></p><p>物品的质量/成本为 <span class="math inline">\(w_i\)</span></p><p>物品的价值为 <span class="math inline">\(p_i\)</span></p><p>一般来讲，背包问题可以用动态规划问题来求解。对于背包问题有三类，即：求是否有可行解、最优解的值（价值最大化最小化）、求可行解的总个数。这三类问题对应了三种动态规划递推式。</p><p>好多问题都可以转化成背包问题来求解。</p><p>对于每一类问题，在这里我们用到动态规划数组 <code>dp[i][j]</code> 表示前 <span class="math inline">\(i\)</span> 商品放入容量为 <span class="math inline">\(j\)</span> 的背包时的解。</p><h3 id="问题分类">问题分类</h3><h4 id="最大价值">最大价值</h4><p>其转移方程如下： <span class="math display">\[f[i][j] = \cases{f[i-1][j]\\f[i-1][j-w_i]+p_i}\]</span> 初始化时，<code>dp[0][0]=0</code>。</p><p>第一种情况表示不放置第 <span class="math inline">\(i\)</span> 件商品，第二种情况表示放置，所以要给它腾出 <span class="math inline">\(w_i\)</span> 大小的空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(weights, profit, W)</span>:</span></span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>]* (W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(profit[i<span class="number">-1</span>], W+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i<span class="number">-1</span>]]+profit[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br></pre></td></tr></table></figure><p>在这里，我们看到，数组 <code>dp</code> 只会用到前面一行来更新，因此我们可以用一个一维的滚动数组来替代二维数组降低空间复杂度。同时在遍历容量时，会用到上一行中小于当前容量的数据，并不会用到大于当前容量的数据。因此要对一维数组对容量进行倒序遍历。</p><h4 id="可行解数量">可行解数量</h4><p>例题： <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494 目标和</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><blockquote><p>解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3</p></blockquote></blockquote><p>数组总和为 <code>sum</code>， 设添加 <code>+</code> 的数字和为 <code>positive</code>, 添加 <code>-</code> 的数字和为<code>negative</code>，则有一下方程组成立 <span class="math display">\[\cases{positve+negative = sum\\positive-negative = target}\]</span> 解方程组可得： <span class="math display">\[negative = \frac{sum-target}{2}\]</span> 即从数组中找到若干个数字和为 <code>negative</code>，求解的个数。</p><p>数字大小即为成本。</p><p><code>dp[i]</code> 表示和为 <code>i</code> 的解的个数。</p><p>在每一个数字开始循环时，<code>dp[i]</code>表示的既是上一轮的解的个数，又是当前轮不包含当前数组的情况下的解的个数。因此再加上包含当前数字的情况的解的个数，即为本轮的解。</p><p>初始化为<code>dp[0] = 1</code> 其他为0， 表示和为 0 有一种解，即什么都不选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> (s-target)%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">or</span> target&gt;s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] += dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        num = nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有赋值，下一行可能被用到，所以要从 0  开始遍历。</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j-num]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="是否存在可行解">是否存在可行解</h4><blockquote><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><blockquote><p>输入：[1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote></blockquote><p>同样，在每一个数组开始循环前，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPatrition</span><span class="params">(nums)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">   V = s//<span class="number">2</span></span><br><span class="line">    dp = [<span class="keyword">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = dp[v]|dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = s//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="keyword">False</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有被赋值，而前面的可能会被下一行用到，所以要从 0 开始赋值。把上一行的复制下来</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=nums[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i][j] | dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong></p><ul><li>背包九讲</li></ul>]]></content>
    
    <summary type="html">
    
      背包问题
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="背包问题" scheme="https://github.com/maneback/maneback.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/slidingwindow/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/slidingwindow/</id>
    <published>2021-06-14T13:29:42.000Z</published>
    <updated>2021-08-16T03:11:24.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="滑动窗口">滑动窗口</h4><p>滑动窗口可以用来解决一系列的数组问题，如最长无重复子数组（子串）、窗口最大值、满足某种条件的最长数组/最短数组。</p><p>感觉滑动窗口可以分为几类：</p><ol type="1"><li>定长窗口</li><li>寻找最长窗口</li><li>寻找最短窗口</li></ol><p>其主要的区别就在于：如何添加元素、合适进行窗口的合理性判断（即判断是否满足条件）以及更新答案。</p><p>对于定长窗口来讲，只要一直保持窗口的长度，每次增加一个元素并删除一个元素即可。</p><p>对于最长窗口来讲，每次删除一个最左元素，然后一直扩展右边界，直到不满足条件（窗口内仍满足条件），再更新答案。</p><p>对于最短窗口来讲，每次一直扩展右边界，直到不满足条件，然后再一直删除左元素，在循环中更新答案。（因为是寻找最短窗口，且在缩短左边界，因此这种情况下最后一次更新答案一定是最小值。）</p><h4 id="存在重复元素ii">存在重复元素II</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Leetcode-219</a></p><ul><li>题目描述</li></ul><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引<code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code>和<code>j</code> 的差的 绝对值 至多为 <code>k</code>。</p><ul><li>分析</li></ul><p>最初我是用一个dict 保存每个数字出现的次数，每次用滑动窗口添加元素删除元素，但是后来边界样例给我惊了，那就是当<code>k</code>的大小等于数组的长度的时候，是没有办法判断的。所以不能这样搞。</p><p>后来直接用字典记录每个数字最后出现的位置，再用位置去相减判断距离就好了。</p><ul><li>错误代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span> </span><br><span class="line">        windows = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> windows[nums[i]]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                windows[nums[i-k]]-=<span class="number">1</span></span><br><span class="line">                windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><ul><li>正确代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>       </span><br><span class="line">        dit = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> dit <span class="keyword">and</span> idx-dit[n]&lt;=k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dit[n] = idx</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h4 id="爱生气的书店老板">爱生气的书店老板</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">Leetcode-1052</a></p><ul><li>题目描述</li></ul><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210810140952.png" alt="image-20210810140952301"><figcaption aria-hidden="true">image-20210810140952301</figcaption></figure><ul><li>分析</li></ul><p>当已知有 <code>grumpy</code> 数组时候，对于不生气的情况，无论怎么怎么控制情绪，这部分满意的顾客总数是不会改变的，所以我们只需要考虑，老板控制了脾气之后，最大能 improve 多少挽回多少新的顾客。如果把 <code>grumpy</code> 与 <code>customer</code> 数组做 <code>element-wise</code> 乘积的话，就可以知道能够挽回的顾客数量，再进行 <code>X</code> 长度的子数组和取最大就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(customers)</span><br><span class="line">        level = sum([c*(<span class="number">1</span>-g) <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy)])</span><br><span class="line"></span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X):</span><br><span class="line">            inc+= customers[i]*grumpy[i]</span><br><span class="line">        max_inc = inc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X, n):</span><br><span class="line">            inc = inc+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X]</span><br><span class="line">            max_inc = max(inc, max_inc)</span><br><span class="line">        <span class="keyword">return</span> level + max_inc</span><br></pre></td></tr></table></figure><h4 id="无重复字符的最长子串">无重复字符的最长子串</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><ul><li>分析</li></ul><p><strong>依次枚举子串起始位置的左边界</strong>，记录以该位置开始子串的最长长度，每一次剔除一个最左字符串， 不断地扩展右边界。直到不满足条件位置，这时判断是否需要更新答案。</p><p><strong>窗口内永远是满足条件的子串，而非剔除直到不满足。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ccc = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">                ccc.remove(s[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk+<span class="number">1</span>&lt;n <span class="keyword">and</span> s[rk+<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ccc:</span><br><span class="line">                ccc.add(s[rk+<span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            ans = max(ans, rk+<span class="number">1</span>-i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="滑动窗口最大值">滑动窗口最大值</h4><ul><li>题目描述</li></ul><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><ul><li>分析</li></ul><p>只要用 滑动窗口 + 单调队列 即可解决，每次边界移动一个位置，向结果数组中添加一个元素。</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># init </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">        res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> que[<span class="number">0</span>]==nums[i-k]:</span><br><span class="line">                que.popleft()</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">            res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组">长度最小的子数组</h4><ul><li>题目描述</li></ul><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><ul><li>分析</li></ul><p>返回最小长度，依旧是扩充右边界，判断是否满足，缩减左边界</p><p>因为是最小长度，所以在缩减左边界时候更新答案</p><p>注意当退出内层 <code>while</code> 循环时，其实已经不满足和 <code>&gt;= target</code> 的条件了，所以要在 <code>while</code> 循环内部更新答案。窗口是在不断减小的，所以最后一次更新一定是最小的，不会影响结果的正确性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)==target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        wind_sum = <span class="number">0</span></span><br><span class="line">        res = n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;n:</span><br><span class="line">            wind_sum += nums[right]</span><br><span class="line">            <span class="keyword">while</span> wind_sum&gt;=target:</span><br><span class="line">                res = min(res, right-left+<span class="number">1</span>)</span><br><span class="line">                wind_sum-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==n+<span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      滑动窗口
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="滑动窗口" scheme="https://github.com/maneback/maneback.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 定时任务</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/crontab/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/crontab/</id>
    <published>2021-05-22T07:29:33.000Z</published>
    <updated>2021-08-14T03:55:24.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>介绍 Linux 定时任务命令 <code>crontab</code> 的使用</p><a id="more"></a><h1 id="linux-crontab">linux crontab</h1><p>linux crontab 是用来定期执行程序的命令。系统会默认启动此任务调度命令。</p><p>crond命令会每分钟定期检查是否有需要执行的工作，如果有的话，便执行该工作。</p><h5 id="语法">1.语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-e | -l | -r&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li><code>-e</code> 执行文字编辑器设定日程表</li><li><code>-r</code>删除目前的日程表</li><li><code>-l</code>列出目前的日程表</li></ul></li></ul><h5 id="时间格式">2. 时间格式</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f1</span> <span class="built_in">f2</span> <span class="built_in">f3</span> <span class="built_in">f4</span> <span class="built_in">f5</span> program</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>f1表示分钟，f2表示小时，f3表示一个月份中的第几天，f4表示月份，f5表示一个星期中的星期几。</li><li>某一项为*表示每分钟或每小时等都要执行程序</li><li>某一项为<code>a-b</code>时表示在a-b这段时间执行。</li><li>某一项为<code>*/n</code>时表示每隔n个单位执行。</li><li>某一项为<code>a,b,c</code>时表示取值为a，b，c时执行。</li></ul></li></ul><h5 id="实例">3. 实例</h5><p>说一千道一万都不如来几个例子来得实在。</p><ul><li><p>每月每天每小时的第0分钟<code>0 * * * * ls</code></p></li><li><p>在12月份，每天早上6点到12点，每隔3小时，每小时第10分钟执行<code>10 6-12/3 * 12 * ls</code></p></li><li><p>每周一到周五下午5:00执行<code>0 17 * * 1-5 ls</code></p></li><li><p>每月每天每偶数小时的20分执行<code>20 0-23/2 * * * ls</code></p></li></ul><p>这样，就可以把需要定期执行的操作写成一个脚本，然后交给crontab来执行了，这样真的方便。真的是，懒惰是第一生产力。我才发明这个的人肯定是一个很懒的人。让电脑帮助人来定期执行一些任务，不会忘记，不会出错，严格执行。这不正是机器比人优越的地方吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 Linux 定时任务命令 &lt;code&gt;crontab&lt;/code&gt; 的使用&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.com/maneback/maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://github.com/maneback/maneback.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- 情侣牵手</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/couple-holding/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/couple-holding/</id>
    <published>2021-02-24T02:51:51.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 <a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">Leetcode-765</a></p><a id="more"></a><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105405.png" alt="image-20210224105405609"><figcaption aria-hidden="true">image-20210224105405609</figcaption></figure><h4 id="解题思路">解题思路</h4><p>对于一堆坐错位置的情侣的集合，只要按照首位相连环路交换位置即可，此种交换位置的方法一定是最少的，次数为情侣数量-1。</p><p>因此下一步的目标即寻找互相独立的情侣的集合，以及每个集合的情侣数量。</p><p>可以用并查集的方法来解决。编号为<code>n, n+1</code> 的两个人组成情侣编号为 <code>n/2</code>，以此编号来作为节点执行并查集算法</p><p>然后利用 map 记录每个并查集集合的大小 <span class="math inline">\(size_i\)</span>，再返回 <span class="math inline">\(\sum{size_i-1}\)</span></p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105550.png" alt="image-20210224105550507"><figcaption aria-hidden="true">image-20210224105550507</figcaption></figure><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSwapCouple</span><span class="params">(row)</span>:</span></span><br><span class="line">    n = len(couple)//<span class="number">2</span></span><br><span class="line">    father = [i <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> father[x] ==x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">       f = find(father[x])</span><br><span class="line">        father[x] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        fx = find(x)</span><br><span class="line">        fy = find(y)</span><br><span class="line">        father[fx] = fy</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a, b = row[<span class="number">2</span>*n]//<span class="number">2</span>, row[<span class="number">2</span>*n+<span class="number">1</span>]//<span class="number">2</span></span><br><span class="line">        union(a, b)</span><br><span class="line">    dit = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            f = find(i)</span><br><span class="line">            dit[f]+=<span class="number">1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> dit.values():</span><br><span class="line">            ret+=(v<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 &lt;a href=&quot;https://leetcode-cn.com/problems/couples-holding-hands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-765&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="并查集" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>单调栈基础</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/monotonic-stack/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/monotonic-stack/</id>
    <published>2021-02-24T02:46:14.000Z</published>
    <updated>2021-08-14T03:25:34.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>与单调队列类似，对于单调栈来讲，我们不仅要满足栈的后入先出顺序，还要满足栈内元素的单调性，来存储当前栈内元素的对应最大值或最小值。</p><p>每次入栈时，先将栈顶所有小于当前值的元素移出，直到当前栈顶元素大于当前值，或者栈为空</p><p>例题：</p><p>每日温度</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814112531.png" alt="image-20210814111129834"><figcaption aria-hidden="true">image-20210814111129834</figcaption></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[<span class="number">-1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文介绍单调栈的基本原理和用法
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调队列基础</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/monotonic-queue/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/monotonic-queue/</id>
    <published>2021-02-24T02:30:35.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单调队列是一个特殊的队列，除满足队列先进先出的特点外，队列内的元素根据需要，还满足单调递增或单调递减。</p><p>以单调递增队列为例：当我们想队尾添加元素<code>x</code>时，为了保持单调性，要把当前队尾所有小于<code>x</code> 的元素从队列中移出，直到队列为空，或是找到了比<code>x</code> 大的元素。这样，单调队列头部始终保存的是当前队列内的最大值。</p><p>当我们在队列内移除元素时，若当前移除的元素与单调队列头部元素相等，说明此时此最大值在队列内已不存在，此元素也应被移除以维护队列内的最大值。</p><h4 id="例题">例题</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指offer - 59-II</a></p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224104022.png"></p><h4 id="代码示例">代码示例</h4><p>在这里，我们用一个数组（双向队列）<code>self.que</code> 保存所有的队列元素，<code>self.max_</code> 保存遇到的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.que = collections.deque()</span><br><span class="line">        self.max_= collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.max_:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.max_[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.que.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.max_ <span class="keyword">and</span> self.max_[<span class="number">-1</span>]&lt;value:</span><br><span class="line">            self.max_.pop()</span><br><span class="line">        self.max_.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.que:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = self.que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.max_[<span class="number">0</span>] == self.que[<span class="number">0</span>]:</span><br><span class="line">            self.max_.popleft()</span><br><span class="line">        self.que.popleft()</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      介绍单调队列的基本原理与用法
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调队列" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 区间合并</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/merge-intervals/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/merge-intervals/</id>
    <published>2021-02-24T02:06:25.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接： <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">Leetcode-56</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100900.png"></p><h4 id="思路">思路</h4><p>如果我们按照区间起始位置将所有区间排序，那么可合并的区间在排序后的数组中是连续的。如下图：相同颜色的区间可以被合并。</p><p>这样的话只一次遍历区间，并判断每个区间能不能与前一个区间合并。</p><p>判断一个区间能不能与前面的区间合并：只需要比较当前区间的起始与前一个区间（可能是已经合并过的区间）的结束位置的大小。</p><p>若当前区间在前一个区间结束前开始，则可以合并。</p><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100018.png"></p><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(intervals)</span>:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="comment"># cannot be merged</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> inter[<span class="number">0</span>]&gt;merged[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 此区间成为一个新的区间</span></span><br><span class="line">            merged.append(inter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可以合并，取两个区间结束点较大的一个</span></span><br><span class="line">            merged[<span class="number">-1</span>][<span class="number">1</span>] = max(merged[<span class="number">-1</span>][<span class="number">1</span>], inter[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-56&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- 最长湍流子数组</title>
    <link href="https://github.com/maneback/maneback.github.io/2021/longest-turbulent-subarray/"/>
    <id>https://github.com/maneback/maneback.github.io/2021/longest-turbulent-subarray/</id>
    <published>2021-02-09T03:02:50.000Z</published>
    <updated>2021-08-25T07:37:54.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 ： <a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">Leetcode-978</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><p><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210209110647.png"></p><h4 id="解题思路">解题思路</h4><p>最长湍流子数组，形象地描述就是数组中的一个子数组，连续数字大小交替变化，我们把这种交替变化用 <strong>上升 下降</strong> 表示，如果<code>arr[-1]&lt;arr[-2]</code> 则称下降序列，如果 <code>arr[-1]&gt;arr[-2]</code> 则称上升序列，即用最后一个变化方向代表整个序列的变化方向。</p><p>考虑动态规划的算法，找到如何描述状态以及状态转移方程。用 <code>dp[i][0]</code> 表示以 <code>num[i]</code> 结尾的上升序列的长度；用<code>dp[i][1]</code> 表示以<code>num[i]</code> 结尾的下降序列的长度。<strong>考虑到上升序列去掉最后一个数字之后成为下降序列，下降序列去掉最后一个数字之后成为上升序列。</strong></p><p>然后我们考虑当前状态 <code>dp[i][0], dp[i][1]</code> 与下一个数组<code>num[i+1]</code> 之间的大小关系：</p><ul><li>如果 <code>num[i+1]&gt;num[i]</code> 则可以把<code>num[i+1]</code>添加到下降序列最后， 成为上升序列；而下降序列长度为1（因为连续两个下降方向）。</li><li>如果 <code>num[i+1]&lt;num[i]</code> 则可以把<code>num[i+1]</code>添加到上升序列最后， 成为下降序列；而上升序列长度为1（因为连续两个上升方向）。</li><li>如果<code>num[i+1]=num[i]</code> 则上升序列和下降序列的长度均变为 1。</li></ul><p>然后从两个数组中找到最长的那个子数组。</p><p>有了状态表示和状态转移方程，就可以写代码解题了。</p><h4 id="示例代码">示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxTurbulenceSize</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (arr[i]&gt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">0</span>])</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 ： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-turbulent-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-978&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/maneback/maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/maneback/maneback.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="https://github.com/maneback/maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
