<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漠·然</title>
  
  <subtitle>Maneback&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maneback.github.io/"/>
  <updated>2021-08-14T03:53:41.279Z</updated>
  <id>http://maneback.github.io/</id>
  
  <author>
    <name>Maneback</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://maneback.github.io/2021/regx/"/>
    <id>http://maneback.github.io/2021/regx/</id>
    <published>2021-08-14T03:37:17.000Z</published>
    <updated>2021-08-14T03:53:41.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正则表达式</p><a id="more"></a><h3 id="正则表达式">正则表达式</h3><h4 id="限定符">1. 限定符</h4><p>限定符用来指定正则表达式的一个给定组件要出现多少次才能满足匹配，共有<code>*</code>、<code>?</code>、<code>+</code>、<code>{n}</code>、<code>{n,}</code>，<code>{n,m}</code>六种，他们的描述如下：（限定出现次数）</p><table><thead><tr class="header"><th>字符</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td>*</td><td style="text-align: left;">匹配前面的子表达式零次或多次，等价于{0,}</td></tr><tr class="even"><td>+</td><td style="text-align: left;">匹配前面的子表达式一次或多次，等价于{1,}</td></tr><tr class="odd"><td>？</td><td style="text-align: left;">匹配前面的子表达式零次或一次，等价于{0,1}</td></tr><tr class="even"><td>{n}</td><td style="text-align: left;">n是一个非负数，匹配确定的n次</td></tr><tr class="odd"><td>{n,}</td><td style="text-align: left;">至少匹配n次</td></tr><tr class="even"><td>{n,m}</td><td style="text-align: left;">最少匹配n次且最多匹配m次。注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p><strong>注意：</strong><code>*</code>和<code>+</code>都是贪婪的，他们会尽可能匹配多的文字，只有在它们后面加上一个<code>?</code>就可以实现非贪婪匹配。</p><h4 id="普通字符">2. 普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有的大小写字母、所有的数字、所有的标点和一些其他符号。</p><h4 id="非打印字符">3. 非打印字符</h4><h4 id="特殊字符">4. 特殊字符</h4><p>特殊字符是一些有特殊含义的字符。</p><table><thead><tr class="header"><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>$</td><td>匹配输入字符串的结尾位置</td></tr><tr class="even"><td>()</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</td></tr><tr class="odd"><td>*</td><td>匹配前面的子表达式零次或多次。</td></tr><tr class="even"><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr class="odd"><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪的限定符</td></tr><tr class="even"><td>.</td><td>匹配除换行符之外的任何单字符</td></tr><tr class="odd"><td>[</td><td>标记一个中括号表达式的开始</td></tr><tr class="even"><td>\</td><td>将下一个字符标记为或特殊字符、或原意字符、或向后引用、或八进制转义符。</td></tr><tr class="odd"><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，表示不接受该字符集合</td></tr><tr class="even"><td>{</td><td>标记限定符表达式的开始</td></tr><tr class="odd"><td>|</td><td>指明两项之间的一个选择</td></tr></tbody></table><p>当你想匹配表格中列举的特殊字符的话，请在该字符前面加上<code>\</code>。</p><h4 id="定位符">5. 定位符</h4><p>定位符使得能够将正则表达式固定到行首或行尾，还能创建出现在一个单词内，在一个单词开头或者结尾的表达式，</p><p>定位符用于描述字符串或单词的边界，<code>^</code>和<code>$</code>分别标记字符串的开始和结尾。<code>\b</code>描述单词的前或后边界，<code>\B</code>表示非单词边界。</p><p>定位符有：</p><table><thead><tr class="header"><th>定位符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>^</td><td>匹配输入字符串开始的位置。</td></tr><tr class="even"><td>$</td><td>匹配输入字符串结束的位置。</td></tr><tr class="odd"><td> 匹配一个单词边界，即字与空格之间的位置。</td><td></td></tr><tr class="even"><td></td><td>非单词边界匹配</td></tr></tbody></table><p><strong>注意：</strong> 不能将限定符和定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上的位置。</p><h4 id="选择">6. 选择</h4><p>用圆括号将所有的选择项括出来，相邻的选择项用|分隔，但用圆括号会使相关的匹配被缓存（<strong>什么是缓存？</strong>），因此可以放一个<code>?:</code>放在选择项前消除这种副作用。</p><h4 id="反向引用">7. 反向引用</h4><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。可以使用非捕获元字符<code>?:</code>, <code>?=</code>, <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p><h3 id="匹配规则">匹配规则</h3><h4 id="基本匹配模式">1. 基本匹配模式</h4><p>从最基本的开始。<strong>模式</strong> 是正则表达式的最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，也可以很复杂，如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="built_in">once</span></span><br><span class="line"><span class="built_in">once</span>$</span><br><span class="line">^<span class="built_in">once</span>$</span><br></pre></td></tr></table></figure><p>该模式包含一个特殊字符<code>^</code>，匹配那些以once开头的字符串。<code>$</code>匹配以该模式结尾的字符串。而当二者同时使用时，代表精准匹配一个模式。</p><p>如果一个模式不包括<code>^ $</code>， 那么它与任何包含该模式的字符串匹配，例如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure><p>与字符串</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There once was <span class="keyword">a</span> man <span class="built_in">from</span> NewYork</span><br><span class="line">Who kept all <span class="keyword">of</span> his cash <span class="keyword">in</span> <span class="keyword">a</span> bucket.</span><br></pre></td></tr></table></figure><p>都是匹配的。</p><h4 id="字符族">2. 字符族</h4><p>可以用方括号来表示字符族，如，以下元音字符族：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure><p>以及表示范围的字符族</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">a-z</span>] <span class="comment">//匹配所有的小写字母 </span></span><br><span class="line">[<span class="meta">A-Z</span>] <span class="comment">//匹配所有的大写字母 </span></span><br><span class="line">[<span class="meta">a-zA-Z</span>] <span class="comment">//匹配所有的字母 </span></span><br><span class="line">[<span class="meta">0-9</span>] <span class="comment">//匹配所有的数字 </span></span><br><span class="line">[<span class="meta">0-9\.\-</span>] <span class="comment">//匹配所有的数字，句号和减号</span></span><br></pre></td></tr></table></figure><p>这些字符族只表示一个字符。如我们要匹配又一个小写字母加一位数字组成的两位的字符串，可以用以下这个模式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">a-z</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure><p>这里的<code>^</code>表示字符串开头，但是在一组方括号中使用<code>^</code>时，表示“非”和“排除”的意思，即不能包含该字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">^0-9</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure><p>表示第一位不能为数字</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="正则表达式" scheme="http://maneback.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法汇总</title>
    <link href="http://maneback.github.io/2021/sortings/"/>
    <id>http://maneback.github.io/2021/sortings/</id>
    <published>2021-07-22T02:01:30.000Z</published>
    <updated>2021-08-14T03:35:22.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比总结常见的排序算法：</p><p>选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序</p><a id="more"></a><h4 id="排序算法">排序算法</h4><p>均默认为升序排列。</p><h5 id="选择排序">选择排序</h5><p>每次遍历数组，找到未排序中的最小元素，然后放到已排序的末尾位置，直到所有的元素均排序完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        print(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="冒泡排序">冒泡排序</h5><p>每次比较两个相邻元素，较大的元素每次移动一个位置，不断地冒泡到数组末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):</span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>]&gt;nums[j]:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="插入排序">插入排序</h5><p>每次选择一个数，在前面已排序好的序列中寻找该数字应该所在的位置，并向后移动部分已排序数字，将新数字插入到相应位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        idx = c</span><br><span class="line">        n = nums[c]</span><br><span class="line">        <span class="keyword">while</span> idx&gt;<span class="number">0</span> <span class="keyword">and</span> nums[idx<span class="number">-1</span>]&gt;n:</span><br><span class="line">            nums[idx] = nums[idx<span class="number">-1</span>]</span><br><span class="line">            idx-=<span class="number">1</span></span><br><span class="line">        nums[idx] = n</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="希尔排序">希尔排序</h5><p>希尔排序是对插入排序的改进版。在插入排序中， 数字每一次只能移动一个位置，而希尔排序是增加移动间隔，使较小的数字能更加快速地移动到队列头部。</p><p>具体算法描述如下：</p><ul><li><p>选择一个增量序列 <span class="math inline">\(g_1 &gt; g_2&gt;\cdots&gt; g_k\)</span> 且 <span class="math inline">\(g_k=1\)</span>。</p></li><li><p>对于每一个增量<span class="math inline">\(g\)</span>, 进行一次排序。</p></li><li><p>在每次排序中，按照间隔进行一次插入排序。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap=n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            i = c</span><br><span class="line">            <span class="keyword">while</span> i-gap&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i-gap]&gt;gap:</span><br><span class="line">                nums[i-gap], nums[i] = nums[i], nums[i-gap]</span><br><span class="line">                print(nums)</span><br><span class="line"></span><br><span class="line">                i-=gap</span><br><span class="line">        gap = gap//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="归并排序">归并排序</h5><p>归并排序是一种分治思想，先将数组分为子序列，缩小问题规模，让每个子序列各自有序，然后再将有序的子序列合并成一个完整数组。这样每一次的问题规模都变为原问题的 1/2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">            <span class="keyword">if</span> left[l]&lt;right[r]:</span><br><span class="line">                res.append(left[l])</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[r])</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">        res += left[l:]</span><br><span class="line">        res += right[r:]</span><br><span class="line">        print( res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = n//<span class="number">2</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><h5 id="快排">快排</h5><p>快排是选取一个哨兵位置，将小于哨兵的数据全部放到左边，将大于哨兵的数据全放到右边，然后再用相同的思想对左右两边继续排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        <span class="comment"># print(left, right)</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;=right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;nums[pivot]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=nums[pivot]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        quick(left, j<span class="number">-1</span>)</span><br><span class="line">        quick(j+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h5 id="计数排序">计数排序</h5><p>计数排序是开辟额外的空间来存储每个值的出现次数，然后再根据计数填充数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    _min = min(nums)</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    tmp_arr = [<span class="number">0</span>]*(_max-_min+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_arr[nums-_min]+=<span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> tmp_arr[j]==<span class="number">0</span>:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        nums[i] = j+_min</span><br><span class="line">        tmp_arr[j] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="堆排序">堆排序</h5><p>堆排序是使用了堆这个数据结构来进行的排序算法。把一维的数组想象成一个二叉树（堆）结构。</p><p>过程如下：</p><ol type="1"><li>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；</li><li>交换堆顶和最后一个元素，重新调整堆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, startops, endops)</span>:</span></span><br><span class="line">        pos = startops</span><br><span class="line">        childops = pos*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> childops&lt;endops:</span><br><span class="line">            rightops = childops+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightops&lt;endops <span class="keyword">and</span> nums[rightops]&gt;nums[childops]:</span><br><span class="line">                childops = rightops</span><br><span class="line">            <span class="keyword">if</span> nums[childops]&gt;nums[pos]:</span><br><span class="line">                nums[pos], nums[childops] = nums[childops], nums[pos]</span><br><span class="line">                adjust_heap(nums, childops, endops)</span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 从后往前即低向上</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n//<span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i,n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="基数排序">基数排序</h5><p>基数排序是针对数字每一位进行排序，从最低位开始排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    max_digit = len(str(_max))</span><br><span class="line">    buckList = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    div, mod = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckList[num%mod//div].append(num)</span><br><span class="line">        div *= <span class="number">10</span></span><br><span class="line">        mod *= <span class="number">10</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        print(buckList)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> buckList[j]:</span><br><span class="line">                nums[idx] = item</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            buckList[j] = []</span><br><span class="line">        print(nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h5 id="对比">对比</h5><p>下面对排序算法做一个总结和对比。</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814104124.png" alt="image-20210814104124495"><figcaption aria-hidden="true">image-20210814104124495</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对比总结常见的排序算法：&lt;/p&gt;
&lt;p&gt;选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="排序算法" scheme="http://maneback.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://maneback.github.io/2021/beibao/"/>
    <id>http://maneback.github.io/2021/beibao/</id>
    <published>2021-06-15T11:22:56.000Z</published>
    <updated>2021-08-14T03:53:39.995Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>背包问题</p><a id="more"></a><h3 id="问题描述">问题描述</h3><p>对于背包问题，是求在具有容量（质量体积个数）约束的情况下，求所有商品满足约束的<strong>可行性解、最优解或解的个数</strong>。</p><h4 id="一般化描述">一般化描述</h4><p>本文关注于 0-1 背包问题，即：每个物品只有一个。</p><blockquote><p>物品总数 <span class="math inline">\(n\)</span></p><p>背包容量 <span class="math inline">\(W\)</span></p><p>物品质量 <span class="math inline">\(w_i\)</span></p><p>物品价值 <span class="math inline">\(p_i\)</span></p></blockquote><p>总质量约束为 <span class="math inline">\(W\)</span></p><p>物品的质量/成本为 <span class="math inline">\(w_i\)</span></p><p>物品的价值为 <span class="math inline">\(p_i\)</span></p><p>一般来讲，背包问题可以用动态规划问题来求解。对于背包问题有三类，即：求是否有可行解、最优解的值（价值最大化最小化）、求可行解的总个数。这三类问题对应了三种动态规划递推式。</p><p>好多问题都可以转化成背包问题来求解。</p><p>对于每一类问题，在这里我们用到动态规划数组 <code>dp[i][j]</code> 表示前 <span class="math inline">\(i\)</span> 商品放入容量为 <span class="math inline">\(j\)</span> 的背包时的解。</p><h3 id="问题分类">问题分类</h3><h4 id="最大价值">最大价值</h4><p>其转移方程如下： <span class="math display">\[f[i][j] = \cases{f[i-1][j]\\f[i-1][j-w_i]+p_i}\]</span> 初始化时，<code>dp[0][0]=0</code>。</p><p>第一种情况表示不放置第 <span class="math inline">\(i\)</span> 件商品，第二种情况表示放置，所以要给它腾出 <span class="math inline">\(w_i\)</span> 大小的空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(weights, profit, W)</span>:</span></span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>]* (W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(profit[i<span class="number">-1</span>], W+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i<span class="number">-1</span>]]+profit[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br></pre></td></tr></table></figure><p>在这里，我们看到，数组 <code>dp</code> 只会用到前面一行来更新，因此我们可以用一个一维的滚动数组来替代二维数组降低空间复杂度。同时在遍历容量时，会用到上一行中小于当前容量的数据，并不会用到大于当前容量的数据。因此要对一维数组对容量进行倒序遍历。</p><h4 id="可行解数量">可行解数量</h4><p>例题： <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494 目标和</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><blockquote><p>解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3</p></blockquote></blockquote><p>数组总和为 <code>sum</code>， 设添加 <code>+</code> 的数字和为 <code>positive</code>, 添加 <code>-</code> 的数字和为<code>negative</code>，则有一下方程组成立 <span class="math display">\[\cases{positve+negative = sum\\positive-negative = target}\]</span> 解方程组可得： <span class="math display">\[negative = \frac{sum-target}{2}\]</span> 即从数组中找到若干个数字和为 <code>negative</code>，求解的个数。</p><p>数字大小即为成本。</p><p><code>dp[i]</code> 表示和为 <code>i</code> 的解的个数。</p><p>在每一个数字开始循环时，<code>dp[i]</code>表示的既是上一轮的解的个数，又是当前轮不包含当前数组的情况下的解的个数。因此再加上包含当前数字的情况的解的个数，即为本轮的解。</p><p>初始化为<code>dp[0] = 1</code> 其他为0， 表示和为 0 有一种解，即什么都不选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> (s-target)%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">or</span> target&gt;s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] += dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = (s-target)//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        num = nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有赋值，下一行可能被用到，所以要从 0  开始遍历。</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j-num]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="是否存在可行解">是否存在可行解</h4><blockquote><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><blockquote><p>输入：[1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote></blockquote><p>同样，在每一个数组开始循环前，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPatrition</span><span class="params">(nums)</span>:</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">   V = s//<span class="number">2</span></span><br><span class="line">    dp = [<span class="keyword">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = dp[v]|dp[v-n]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维 dp</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    V = s//<span class="number">2</span></span><br><span class="line">    dp = [[<span class="keyword">False</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为这第 i 行还没有被赋值，而前面的可能会被下一行用到，所以要从 0 开始赋值。把上一行的复制下来</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j&gt;=nums[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i][j] | dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背包问题&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="背包问题" scheme="http://maneback.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://maneback.github.io/2021/slidingwindow/"/>
    <id>http://maneback.github.io/2021/slidingwindow/</id>
    <published>2021-06-14T13:29:42.000Z</published>
    <updated>2021-08-14T03:47:29.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>滑动窗口</p><a id="more"></a><h4 id="滑动窗口">滑动窗口</h4><p>滑动窗口可以用来解决一系列的数组问题，如最长无重复子数组（子串）、窗口最大值、满足某种条件的最长数组/最短数组。</p><p>感觉滑动窗口可以分为几类：</p><ol type="1"><li>定长窗口</li><li>寻找最长窗口</li><li>寻找最短窗口</li></ol><p>其主要的区别就在于：如何添加元素、合适进行窗口的合理性判断（即判断是否满足条件）以及更新答案。</p><p>对于定长窗口来讲，只要一直保持窗口的长度，每次增加一个元素并删除一个元素即可。</p><p>对于最长窗口来讲，每次删除一个最左元素，然后一直扩展右边界，直到不满足条件（窗口内仍满足条件），再更新答案。</p><p>对于最短窗口来讲，每次一直扩展右边界，直到不满足条件，然后再一直删除左元素，在循环中更新答案。（因为是寻找最短窗口，且在缩短左边界，因此这种情况下最后一次更新答案一定是最小值。）</p><h4 id="存在重复元素ii">存在重复元素II</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Leetcode-219</a></p><ul><li>题目描述</li></ul><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引<code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code>和<code>j</code> 的差的 绝对值 至多为 <code>k</code>。</p><ul><li>分析</li></ul><p>最初我是用一个dict 保存每个数字出现的次数，每次用滑动窗口添加元素删除元素，但是后来边界样例给我惊了，那就是当<code>k</code>的大小等于数组的长度的时候，是没有办法判断的。所以不能这样搞。</p><p>后来直接用字典记录每个数字最后出现的位置，再用位置去相减判断距离就好了。</p><ul><li>错误代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span> </span><br><span class="line">        windows = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> windows[nums[i]]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                windows[nums[i-k]]-=<span class="number">1</span></span><br><span class="line">                windows[nums[i]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><ul><li>正确代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>       </span><br><span class="line">        dit = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> dit <span class="keyword">and</span> idx-dit[n]&lt;=k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dit[n] = idx</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h4 id="爱生气的书店老板">爱生气的书店老板</h4><p>题目链接 <a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">Leetcode-1052</a></p><ul><li>题目描述</li></ul><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210810140952.png" alt="image-20210810140952301"><figcaption aria-hidden="true">image-20210810140952301</figcaption></figure><ul><li>分析</li></ul><p>当已知有 <code>grumpy</code> 数组时候，对于不生气的情况，无论怎么怎么控制情绪，这部分满意的顾客总数是不会改变的，所以我们只需要考虑，老板控制了脾气之后，最大能 improve 多少挽回多少新的顾客。如果把 <code>grumpy</code> 与 <code>customer</code> 数组做 <code>element-wise</code> 乘积的话，就可以知道能够挽回的顾客数量，再进行 <code>X</code> 长度的子数组和取最大就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(customers)</span><br><span class="line">        level = sum([c*(<span class="number">1</span>-g) <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy)])</span><br><span class="line"></span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X):</span><br><span class="line">            inc+= customers[i]*grumpy[i]</span><br><span class="line">        max_inc = inc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X, n):</span><br><span class="line">            inc = inc+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X]</span><br><span class="line">            max_inc = max(inc, max_inc)</span><br><span class="line">        <span class="keyword">return</span> level + max_inc</span><br></pre></td></tr></table></figure><h4 id="无重复字符的最长子串">无重复字符的最长子串</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><ul><li>分析</li></ul><p><strong>依次枚举子串起始位置的左边界</strong>，记录以该位置开始子串的最长长度，每一次剔除一个最左字符串， 不断地扩展右边界。直到不满足条件位置，这时判断是否需要更新答案。</p><p><strong>窗口内永远是满足条件的子串，而非剔除直到不满足。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ccc = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">                ccc.remove(s[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk+<span class="number">1</span>&lt;n <span class="keyword">and</span> s[rk+<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ccc:</span><br><span class="line">                ccc.add(s[rk+<span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            ans = max(ans, rk+<span class="number">1</span>-i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="滑动窗口最大值">滑动窗口最大值</h4><ul><li>题目描述</li></ul><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><ul><li>分析</li></ul><p>只要用 滑动窗口 + 单调队列 即可解决，每次边界移动一个位置，向结果数组中添加一个元素。</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># init </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">        res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> que[<span class="number">0</span>]==nums[i-k]:</span><br><span class="line">                que.popleft()</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[<span class="number">-1</span>]&lt;nums[i]:</span><br><span class="line">                que.pop()</span><br><span class="line">            que.append(nums[i])</span><br><span class="line">            res.append(que[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组">长度最小的子数组</h4><ul><li>题目描述</li></ul><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><ul><li>分析</li></ul><p>返回最小长度，依旧是扩充右边界，判断是否满足，缩减左边界</p><p>因为是最小长度，所以在缩减左边界时候更新答案</p><p>注意当退出内层 <code>while</code> 循环时，其实已经不满足和 <code>&gt;= target</code> 的条件了，所以要在 <code>while</code> 循环内部更新答案。窗口是在不断减小的，所以最后一次更新一定是最小的，不会影响结果的正确性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)==target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        wind_sum = <span class="number">0</span></span><br><span class="line">        res = n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;n:</span><br><span class="line">            wind_sum += nums[right]</span><br><span class="line">            <span class="keyword">while</span> wind_sum&gt;=target:</span><br><span class="line">                res = min(res, right-left+<span class="number">1</span>)</span><br><span class="line">                wind_sum-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==n+<span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滑动窗口&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="滑动窗口" scheme="http://maneback.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 定时任务</title>
    <link href="http://maneback.github.io/2021/crontab/"/>
    <id>http://maneback.github.io/2021/crontab/</id>
    <published>2021-05-22T07:29:33.000Z</published>
    <updated>2021-08-14T03:36:44.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>介绍 Linux 定时任务命令 <code>crontab</code> 的使用</p><h1 id="linux-crontab">linux crontab</h1><p>linux crontab 是用来定期执行程序的命令。系统会默认启动此任务调度命令。</p><p>crond命令会每分钟定期检查是否有需要执行的工作，如果有的话，便执行该工作。</p><h5 id="语法">1.语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-e | -l | -r&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li><code>-e</code> 执行文字编辑器设定日程表</li><li><code>-r</code>删除目前的日程表</li><li><code>-l</code>列出目前的日程表</li></ul></li></ul><h5 id="时间格式">2. 时间格式</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f1</span> <span class="built_in">f2</span> <span class="built_in">f3</span> <span class="built_in">f4</span> <span class="built_in">f5</span> program</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>f1表示分钟，f2表示小时，f3表示一个月份中的第几天，f4表示月份，f5表示一个星期中的星期几。</li><li>某一项为*表示每分钟或每小时等都要执行程序</li><li>某一项为<code>a-b</code>时表示在a-b这段时间执行。</li><li>某一项为<code>*/n</code>时表示每隔n个单位执行。</li><li>某一项为<code>a,b,c</code>时表示取值为a，b，c时执行。</li></ul></li></ul><h5 id="实例">3. 实例</h5><p>说一千道一万都不如来几个例子来得实在。</p><ul><li><p>每月每天每小时的第0分钟<code>0 * * * * ls</code></p></li><li><p>在12月份，每天早上6点到12点，每隔3小时，每小时第10分钟执行<code>10 6-12/3 * 12 * ls</code></p></li><li><p>每周一到周五下午5:00执行<code>0 17 * * 1-5 ls</code></p></li><li><p>每月每天每偶数小时的20分执行<code>20 0-23/2 * * * ls</code></p></li></ul><p>这样，就可以把需要定期执行的操作写成一个脚本，然后交给crontab来执行了，这样真的方便。真的是，懒惰是第一生产力。我才发明这个的人肯定是一个很懒的人。让电脑帮助人来定期执行一些任务，不会忘记，不会出错，严格执行。这不正是机器比人优越的地方吗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://maneback.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- 情侣牵手</title>
    <link href="http://maneback.github.io/2021/couple-holding/"/>
    <id>http://maneback.github.io/2021/couple-holding/</id>
    <published>2021-02-24T02:51:51.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 <a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">Leetcode-765</a></p><a id="more"></a><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105405.png" alt="image-20210224105405609"><p class="caption">image-20210224105405609</p></div><h4 id="解题思路">解题思路</h4><p>对于一堆坐错位置的情侣的集合，只要按照首位相连环路交换位置即可，此种交换位置的方法一定是最少的，次数为情侣数量-1。</p><p>因此下一步的目标即寻找互相独立的情侣的集合，以及每个集合的情侣数量。</p><p>可以用并查集的方法来解决。编号为<code>n, n+1</code> 的两个人组成情侣编号为 <code>n/2</code>，以此编号来作为节点执行并查集算法</p><p>然后利用 map 记录每个并查集集合的大小 <span class="math inline">\(size_i\)</span>，再返回 <span class="math inline">\(\sum{size_i-1}\)</span></p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224105550.png" alt="image-20210224105550507"><p class="caption">image-20210224105550507</p></div><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSwapCouple</span><span class="params">(row)</span>:</span></span><br><span class="line">    n = len(couple)//<span class="number">2</span></span><br><span class="line">    father = [i <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> father[x] ==x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">       f = find(father[x])</span><br><span class="line">        father[x] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        fx = find(x)</span><br><span class="line">        fy = find(y)</span><br><span class="line">        father[fx] = fy</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a, b = row[<span class="number">2</span>*n]//<span class="number">2</span>, row[<span class="number">2</span>*n+<span class="number">1</span>]//<span class="number">2</span></span><br><span class="line">        union(a, b)</span><br><span class="line">    dit = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            f = find(i)</span><br><span class="line">            dit[f]+=<span class="number">1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> dit.values():</span><br><span class="line">            ret+=(v<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 &lt;a href=&quot;https://leetcode-cn.com/problems/couples-holding-hands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-765&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="并查集" scheme="http://maneback.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>单调栈基础</title>
    <link href="http://maneback.github.io/2021/monotonic-stack/"/>
    <id>http://maneback.github.io/2021/monotonic-stack/</id>
    <published>2021-02-24T02:46:14.000Z</published>
    <updated>2021-08-14T03:25:34.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>与单调队列类似，对于单调栈来讲，我们不仅要满足栈的后入先出顺序，还要满足栈内元素的单调性，来存储当前栈内元素的对应最大值或最小值。</p><p>每次入栈时，先将栈顶所有小于当前值的元素移出，直到当前栈顶元素大于当前值，或者栈为空</p><p>例题：</p><p>每日温度</p><figure><img src="https://gitee.com/MyTypora/typorapic/raw/master/img/20210814112531.png" alt="image-20210814111129834"><figcaption aria-hidden="true">image-20210814111129834</figcaption></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[<span class="number">-1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文介绍单调栈的基本原理和用法
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://maneback.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调队列基础</title>
    <link href="http://maneback.github.io/2021/monotonic-queue/"/>
    <id>http://maneback.github.io/2021/monotonic-queue/</id>
    <published>2021-02-24T02:30:35.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单调队列是一个特殊的队列，除满足队列先进先出的特点外，队列内的元素根据需要，还满足单调递增或单调递减。</p><p>以单调递增队列为例：当我们想队尾添加元素<code>x</code>时，为了保持单调性，要把当前队尾所有小于<code>x</code> 的元素从队列中移出，直到队列为空，或是找到了比<code>x</code> 大的元素。这样，单调队列头部始终保存的是当前队列内的最大值。</p><p>当我们在队列内移除元素时，若当前移除的元素与单调队列头部元素相等，说明此时此最大值在队列内已不存在，此元素也应被移除以维护队列内的最大值。</p><h4 id="例题">例题</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指offer - 59-II</a></p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224104022.png"></div><h4 id="代码示例">代码示例</h4><p>在这里，我们用一个数组（双向队列）<code>self.que</code> 保存所有的队列元素，<code>self.max_</code> 保存遇到的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.que = collections.deque()</span><br><span class="line">        self.max_= collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.max_:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.max_[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.que.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.max_ <span class="keyword">and</span> self.max_[<span class="number">-1</span>]&lt;value:</span><br><span class="line">            self.max_.pop()</span><br><span class="line">        self.max_.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.que:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = self.que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.max_[<span class="number">0</span>] == self.que[<span class="number">0</span>]:</span><br><span class="line">            self.max_.popleft()</span><br><span class="line">        self.que.popleft()</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      介绍单调队列的基本原理与用法
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="单调队列" scheme="http://maneback.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 区间合并</title>
    <link href="http://maneback.github.io/2021/merge-intervals/"/>
    <id>http://maneback.github.io/2021/merge-intervals/</id>
    <published>2021-02-24T02:06:25.000Z</published>
    <updated>2021-03-17T11:03:01.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接： <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">Leetcode-56</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100900.png"></div><h4 id="思路">思路</h4><p>如果我们按照区间起始位置将所有区间排序，那么可合并的区间在排序后的数组中是连续的。如下图：相同颜色的区间可以被合并。</p><p>这样的话只一次遍历区间，并判断每个区间能不能与前一个区间合并。</p><p>判断一个区间能不能与前面的区间合并：只需要比较当前区间的起始与前一个区间（可能是已经合并过的区间）的结束位置的大小。</p><p>若当前区间在前一个区间结束前开始，则可以合并。</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224100018.png"></div><h4 id="代码示例">代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(intervals)</span>:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="comment"># cannot be merged</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> inter[<span class="number">0</span>]&gt;merged[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 此区间成为一个新的区间</span></span><br><span class="line">            merged.append(inter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可以合并，取两个区间结束点较大的一个</span></span><br><span class="line">            merged[<span class="number">-1</span>][<span class="number">1</span>] = max(merged[<span class="number">-1</span>][<span class="number">1</span>], inter[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-56&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- unique binary search trees II</title>
    <link href="http://maneback.github.io/2021/longest-turbulent-subarray/"/>
    <id>http://maneback.github.io/2021/longest-turbulent-subarray/</id>
    <published>2021-02-09T03:02:50.000Z</published>
    <updated>2021-03-17T11:03:01.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目链接 ： <a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">Leetcode-978</a></p><a id="more"></a><h4 id="题目描述">题目描述</h4><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210209110647.png"></div><h4 id="解题思路">解题思路</h4><p>最长湍流子数组，形象地描述就是数组中的一个子数组，连续数字大小交替变化，我们把这种交替变化用 <strong>上升 下降</strong> 表示，如果<code>arr[-1]&lt;arr[-2]</code> 则称下降序列，如果 <code>arr[-1]&gt;arr[-2]</code> 则称上升序列，即用最后一个变化方向代表整个序列的变化方向。</p><p>考虑动态规划的算法，找到如何描述状态以及状态转移方程。用 <code>dp[i][0]</code> 表示以 <code>num[i]</code> 结尾的上升序列的长度；用<code>dp[i][1]</code> 表示以<code>num[i]</code> 结尾的下降序列的长度。<strong>考虑到上升序列去掉最后一个数字之后成为下降序列，下降序列去掉最后一个数字之后成为上升序列。</strong></p><p>然后我们考虑当前状态 <code>dp[i][0], dp[i][1]</code> 与下一个数组<code>num[i+1]</code> 之间的大小关系：</p><ul><li>如果 <code>num[i+1]&gt;num[i]</code> 则可以把<code>num[i+1]</code>添加到下降序列最后， 成为上升序列；而下降序列长度为1（因为连续两个下降方向）。</li><li>如果 <code>num[i+1]&lt;num[i]</code> 则可以把<code>num[i+1]</code>添加到上升序列最后， 成为下降序列；而上升序列长度为1（因为连续两个上升方向）。</li><li>如果<code>num[i+1]=num[i]</code> 则上升序列和下降序列的长度均变为 1。</li></ul><p>然后从两个数组中找到最长的那个子数组。</p><p>有了状态表示和状态转移方程，就可以写代码解题了。</p><h4 id="示例代码">示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxTurbulenceSize</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (arr[i]&gt;arr[i<span class="number">-1</span>]):</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">0</span>])</span><br><span class="line">            ret = max(ret, dp[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接 ： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-turbulent-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-978&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>VScode 快捷键</title>
    <link href="http://maneback.github.io/2021/vscodeshortcut/"/>
    <id>http://maneback.github.io/2021/vscodeshortcut/</id>
    <published>2021-01-17T13:15:35.000Z</published>
    <updated>2021-01-17T13:18:53.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol style="list-style-type: decimal"><li>多行编辑</li></ol><ul><li>鼠标+ <code>Alt+Shift</code> 按键选择，此方式只能选择连续竖列的对应位置不可随意插入光标位置，且不可间隔列</li><li><code>Shift+Ctrl</code> 数列选择, 可以在多个地方插入光标。</li></ul>]]></content>
    
    <summary type="html">
    
      记录常用的 VScode 快捷键
    
    </summary>
    
      <category term="技术" scheme="http://maneback.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="VScode" scheme="http://maneback.github.io/tags/VScode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 必要的插件</title>
    <link href="http://maneback.github.io/2021/installed-plugin/"/>
    <id>http://maneback.github.io/2021/installed-plugin/</id>
    <published>2021-01-05T09:53:18.000Z</published>
    <updated>2021-01-18T11:54:00.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="基础环境及必要插件">基础环境及必要插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save  ##wenti</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save ##</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><h4 id="在hexo-博客中插入图片">在hexo 博客中插入图片。</h4><p>先安装插件 <code>hexo-asset-image</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli --save</span><br><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>第一种最简单的方法是使用图床，但是之前折腾过一段时间使用 PicGO +github 图床，但是稳定，后放弃。改用 hexo 自带的资源文件夹。</p><p>第二种方法是启用 assert 资源文件夹，但是这个东西很不智能。当你在 markdown 文档引用图片（不管是相对路径还是绝对路径）都能在文档中显示，但是渲染成 HTML 文件时，就会路径出错了。要用这个新的插件 <code>hexo-asset-image</code> 。</p><h4 id="在-hexo-博客中正常显示-latex-公式">在 hexo 博客中正常显示 latex 公式</h4><p>hexo 竟然对 latex 公式的支持这么不智能。唉，绝了。</p><p>更换 renderer。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall hexo-renderer-marked</span><br><span class="line"><span class="built_in">npm</span> install hexo-renderer-pandoc</span><br></pre></td></tr></table></figure><p>安装完 <code>hexo-render-pandoc</code> ，它在运行 <code>hexo s</code> 命令时会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR][hexo-renderer-pandoc] pandoc exited with code 9: pandoc: Unknown extension: smart</span><br></pre></td></tr></table></figure><p>这时需要把 <code>node_modules\hexo-renderer-pandoc\index.js</code> 文件中的这个东西</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [ <span class="string">'-f'</span>, <span class="string">'markdown-smart'</span>+extensions, <span class="string">'-t'</span>, <span class="string">'html-smart'</span>, math]</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [ <span class="string">'-f'</span>, <span class="string">'markdown'</span>+extensions, <span class="string">'-t'</span>, <span class="string">'html'</span>, math]</span><br></pre></td></tr></table></figure><p>参考来源 <a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/36#issuecomment-555134526" target="_blank" rel="noopener">hexo-renderer-pandoc issues36</a></p>]]></content>
    
    <summary type="html">
    
      配置环境要用到的插件。
    
    </summary>
    
      <category term="Blog" scheme="http://maneback.github.io/categories/Blog/"/>
    
    
      <category term="blog" scheme="http://maneback.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="http://maneback.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- unique binary search trees II</title>
    <link href="http://maneback.github.io/2020/unique-binary-search-trees-ii/"/>
    <id>http://maneback.github.io/2020/unique-binary-search-trees-ii/</id>
    <published>2020-06-16T03:39:50.000Z</published>
    <updated>2021-08-14T03:44:59.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="题目描述">题目描述</h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p><p>0&lt;=n&lt;=8</p><h4 id="解题思路">解题思路</h4><p>对于一个二叉搜索树中的任一个节点来讲，其左子树的所有节点的值都小于该节点，其右子树的所有节点的值都大于该节点。</p><p>对于一个递归的问题，我们只考虑每一步应该做什么，顺序是什么，应该返回什么。</p><p>在每一步中，我们只考虑构建一棵子树，然后把子树返回给上一节点。</p><p>假设某一步中我们以一个区间<code>[start, end]</code> 来构造二叉搜索树，那么对于任意的 <code>i, start&lt;=i&lt;=end</code>， 可以以<code>i</code>为根节点来开始构造二叉搜索树，它的左子树则是以区间<code>[start, i-1]</code>构造的二叉搜索树，它的右子树是以区间<code>[i+1, end]</code> 构造的二叉搜索树，就这样递归地构造即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        node = Treenode(start, i)</span><br><span class="line">        lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">        rc = dfs(i+<span class="number">1</span>, end)</span><br></pre></td></tr></table></figure><p>但是对于区间 <code>[start, i-1]</code> 和<code>[i+1, end]</code>构造的左右子树，可能不止为1， 然而其可以任意地组合，这样，我们用一个数组保存以<code>[start， end]</code>构造的所有子树，然后再将其返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start&gt;end:</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">None</span>, ]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        node = Treenode(start, i)</span><br><span class="line">        lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">        rc = dfs(i+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lc:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rc:</span><br><span class="line">                node.left = l</span><br><span class="line">                node.right = r</span><br><span class="line">                res.append(node)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这样，我们就完成了代码的书写。</p><h4 id="解题代码">解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">None</span>, ]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">            node = Treenode(start, i)</span><br><span class="line">            lc = dfs(start, i<span class="number">-1</span>)</span><br><span class="line">            rc = dfs(i+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> lc:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> rc:</span><br><span class="line">                    node.left = l</span><br><span class="line">                    node.right = r</span><br><span class="line">                    res.append(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">   <span class="keyword">return</span> dfs(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      LeetCode-95
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="tree" scheme="http://maneback.github.io/tags/tree/"/>
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://maneback.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- binary tree maximum path sum</title>
    <link href="http://maneback.github.io/2020/binary-tree-maximum-path-sum/"/>
    <id>http://maneback.github.io/2020/binary-tree-maximum-path-sum/</id>
    <published>2020-06-15T13:04:57.000Z</published>
    <updated>2021-03-17T11:03:01.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>题目链接</strong>： <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" class="uri" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><h4 id="题目描述">题目描述</h4><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><h4 id="解题思路">解题思路</h4><p>首先，这是一道非常标准的树形结构搜索的问题，对于树结构相关的问题，都可以用深度优先搜索或广度优先搜索的方法来解决，此题也不例外。只要考虑好在每个节点上做什么操作、在 child 节点上做什么操作，以及是先序、中序还是后续就行了。</p><p>关于这个题，很明显是后序。因为你需要找到当前 node 节点的子节点的路径长，才能确定通过当前 node 节点的路径长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">       <span class="comment"># pass</span></span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br><span class="line">    <span class="comment"># do sth to node</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">#path.</span></span><br></pre></td></tr></table></figure><p>对于这个问题，其路径可以不经过 root 节点，那么对于最长路径中的任意一个节点 n，可选的操作有四种：①从 n 的父节点连接 n 到 n 的左子树；②从 n 的父节点连接 n 到 n 的右子树；③从 n 的左子树连接到 n 连接到 n 的右子树；④最大路径从 n 点结束，包括最上的点和最下的点两种情况。</p><p>我们用全局变量 <code>path</code> 表示当前的全局最优解。</p><p>对于前两种情况，到目前为止我们只求得了或者说是遍历过了最长路径的部分，因此这一部分要把经过该节点的子路径的长度返回给父节点继续计算。其中除了情况一和二之外，还有一种就是情况四中的最大路径最下从当前节点结束：即它的所有子树的最大路径都是负值。因此我们要针对这三种情况计算局部最优值。</p><p>对于情况三，在得到了左右子树的最大路径值后，都能直接计算出该情况的解，因此此时直接将其与全局最优解比较。此外还可能其其中一个子树的最大子路径值为负数，且父节点的最大子路径值也为负数，即最大路径最上从当前节点结束，都要和全局最优解比较。</p><p>具体代码如下：</p><h4 id="解题代码">解题代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.path = <span class="number">-1000000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">           dl = dfs(node.left)</span><br><span class="line">            dr = node.right</span><br><span class="line">            <span class="comment"># local max</span></span><br><span class="line">            local_max = max(node.val, node.val+dl, node.val+dr)</span><br><span class="line">            self.path = max(node.val+dl+dr, local_max, self.path)</span><br><span class="line">            <span class="keyword">return</span> local_max</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.path</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      LeetCode-124
    
    </summary>
    
    
      <category term="tree" scheme="http://maneback.github.io/tags/tree/"/>
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="BFS&amp;DFS" scheme="http://maneback.github.io/tags/BFS-DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- subsets</title>
    <link href="http://maneback.github.io/2020/subset/"/>
    <id>http://maneback.github.io/2020/subset/</id>
    <published>2020-06-09T00:38:42.000Z</published>
    <updated>2021-01-04T13:36:59.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>原题链接：<a href="https://leetcode-cn.com/problems/subsets/" class="uri" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p><a id="more"></a><h5 id="题目描述">题目描述：</h5><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><h5 id="示例">示例：</h5><blockquote><p>输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]</p></blockquote><h5 id="解法">解法：</h5><p>本题是非常经典的回溯法解决的题目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subset</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(first=<span class="number">0</span>, curr=[])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(curr)==k:</span><br><span class="line">            output.append(curr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">            curr.append(nums[i])</span><br><span class="line">            backtrack(i+<span class="number">1</span>, curr)</span><br><span class="line">            curr.pop()</span><br><span class="line">    output = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">        backtrack()</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode-cn.com/problems/subsets/&quot; class=&quot;uri&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/subsets/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://maneback.github.io/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://maneback.github.io/tags/Leetcode/"/>
    
      <category term="backtrack" scheme="http://maneback.github.io/tags/backtrack/"/>
    
  </entry>
  
  <entry>
    <title>论文解读|点云深度学习方法--PointNet</title>
    <link href="http://maneback.github.io/2020/pointnet/"/>
    <id>http://maneback.github.io/2020/pointnet/</id>
    <published>2020-05-19T10:49:03.000Z</published>
    <updated>2021-03-17T11:03:01.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation [CVPR 2017]</p><a id="more"></a><blockquote><p>论文解读系列第①篇</p></blockquote><p>今天带来的是 CVPR 2017 的一篇文章 PointNet。这片文章可以说是深度学习直接处理原始点云数据 (raw point cloud) 的开篇之作。目前在 Google Scholar 上面查到的引用量已经超过了 2000 次。</p><h2 id="一背景">一、背景</h2><p>先来看一看点云与深度学习结合的问题。近年来，深度学习方法取得了广泛的关注和应用，在图像、语音、文字等领域都取得了很好的应用成果。而点云是一种新型的 3D 空间的数据表示格式。它一般以一个四维向量 (x, y, z, i) 表示一个点。其中， (x, y, z) 是空间中的三维坐标，而 i 表示的是该点的反射强度。</p><p>当 2D 图像输入到深度学习的网络中时，它是规则的数据，每个像素值的位置都可以以一个二维坐标来表示，且它在空间上是连续的表示，即相邻像素就是在图像中相邻的。而点云的表示方法有所不同。它是无序且非结构化的表示，只是一个由点的坐标构成的集合，而相邻点之间并没有这种空间的相邻关系。这就会造成如下面这样的结果：</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102056.png"></div><p>如上图：一副点云由若干的点构成，但是同一副点云图像其中点的排列顺序可能会不同，当以两者分别输入卷积网络中时，无论对于分类任务还是对于目标检测任务来讲，会带来不同的结果。然而实际上二者表示的是同一个物体或内容。这显然不是我们想要的结果。</p><p>卷积网络需要结构化的输入，而点云的输入是非结构化的，这样就会导致卷积网络并不适用于点云数据，基于此，人们想出了两种预处理方式，来使点云成为结构化的输入。</p><ul><li><p>第一种方法是 multi-view 投影的方法。即以点云在多个视角的投影作为输入，用原来的 2D 图像的卷积网络来处理。</p></li><li><p>第二种方法是 voxelization 的方法，即把空间划分成离散的体素 (3D voxel)， 然后每个点按照坐标位置决定落到那个体素单元中。这样，就可以把原来无序的点云输入规则化。</p></li></ul><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102059.png"></div><p>但是这种预处理的方式肯定会造成一定的信息损失。</p><p>基于此问题，本文的作者就提出了 PointNet 神经网络来处理点云数据。设计了一种直接处理点云来提取特征的新型网络，很好地考虑了对于输入点<strong>排列顺序</strong>的不变性。以及网络对于输入点集小的扰动和数据破坏（丢失）也具有很好的鲁棒性。</p><h2 id="二网络结构">二、网络结构</h2><p>首先来总结一下点云数据的三个特征以及由此带来的问题：</p><ul><li><strong>Unordered</strong> ：点云在采集和存储是都是无序的，因此要求网络必须对一副点云所有可能的输入保持结果不变。</li><li><strong>Interaction among points</strong> ：点云中每个点都与其周围的若干点表示了一定的空间结果，但是在存储来讲，并不能表示出这种结构。</li><li><strong>Invariance under transformation</strong> ：点云表示了一定的三维结构，这要求网络的处理结果对于点云的旋转、转换等必须保持结果不变性。</li></ul><p>针对以上的问题，本文采取的方法是：在初始阶段，对点云中每个点都<strong>单独</strong>进行<strong>相同</strong>的处理，然后再应用一个对称函数(MaxPooling)来解决点集的无序性问题。</p><p><strong>PointNet 的网络结构如下：</strong></p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102102.png"></div><p>网络的输入即为一个 nx3 的向量，表示 n 个点的三维坐标。可以用于分类任务与分割任务。对于分类任务，输出结果为 k 个分类类别的得分；对于分割任务，输出结果为 n 个点逐个的所属分割部分的得分。</p><p>最重要的三个部分已在图中圈出：</p><ul><li>两个小型的 T-Net 网络用于学习一个坐标变换矩阵，并应于该坐标变换矩阵增强输入数据，使得网络对于输入的旋转等操作具有一定的不变性。</li><li>MaxPooling 操作，以对称函数解决点云输入的不变性。</li><li>Aggregation 操作，将全局特征拼接到每个点的特征后面，用于分类任务。</li></ul><p>首先，对于 nx3 的输入数据，先经过一个两层的 MLP ，提取得到每个点的 64 维特征，此外输入数据与特征数据分别经过 input transform 和 feature transform 操作进行增强。这样我们就得到了一个 nx64 的特征，每个点的特征以一个 64 维的向量表示。在此之后，再经过一个三层的 MLP 将 64 维的特征升到 1024 维。 然后经过 maxpooling 操作提取得到一个全局的 1024 维特征。然后输入到分类网络中用以分类。</p><p>对于如何解决无序性问题，使得模型能够不受输入的排列顺序的影响。那么作者提出了三种可能的解决方法：(1)是将输入按一个规范顺序排序。这个很显然是不可行的。(2)是将输入作为一个连续的序列来训练一个RNN，并通过所有可能的排序来增加训练数据。一方面，有研究表明在RNN中顺序确实是有影响的，不能被忽略；另一方面，当point clouds 数据集很大的时候，对所有的N!个排列都处理一次也是不现实的。(3)是采用对称函数。</p><p>下面来介绍一下对称函数。所谓对称函数，通俗来讲就是参数的输入顺序不会影响函数的结果。如加法、乘法等，都是非常常见且明显的对称函数，可以任意改变参数的顺序。对于 maxpooling 操作来讲，它当然也是对称函数，无论输入的 n 个点的排列顺序如何，在对 nx1024 维的特征应用 maxpooling 操作时，得到的结果永远都是一样的。</p><p>这样借用 maxpooling 函数的对称性，我们就可以无视输入的无序性。先对每个点单独地进行相同的操作，然后再应用对称函数提取全局特征就好了。形式上来讲，可以表示为： <span class="math display">\[f(x_1, x_2,...x_n)=g(h(x_1), h(x_2),...h(x_n))\]</span> 函数 <span class="math inline">\(f\)</span> 是作用在点集上的函数，函数 <span class="math inline">\(h\)</span> 是作用在单个点上的函数，而函数 <span class="math inline">\(g\)</span> 是一个作用在经过处理的点 <span class="math inline">\(h(x)\)</span> 上的对称函数，这样我们就可以用函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 来得到关于点集的操作 <span class="math inline">\(f\)</span> 。而相关的理论证明，将会在第四部分给出。</p><p>对于分割任务来讲，既要考虑全局的特征，又要考虑全局特征，所以做法便是将 1024 维的全局特征聚合到每一个 64 为的点特征之后，这样得到的特征就既包含了全局的信息，也包含了点的局部信息了，从而用于分割任务。</p><h2 id="三结果">三、结果</h2><p>在论文中，作者给出了 PointNet 网络在分类、部分分割与场景语义分割三项任务上的结果。</p><h3 id="分类">3.1 分类</h3><p>在 ModelNet40 数据集上分类的准确率如下：</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102105.png"></div><p>在这项任务中，与 multi-view 与 voxel 的方法进行了对比。</p><h3 id="部分分割">3.2 部分分割</h3><p>所谓部分分割，就是对每个点生成一个类别标记：</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102111.png"></div><p>在 ModelNet40 部分分割结果如下，评价指标为 IoU:</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102115.png"></div><h3 id="场景语义分割">3.3 场景语义分割</h3><p>场景语义分割任务与部分分割任务类似，也是为每个点分配一个类别标记，判断每个点属于哪个物体。数据集为 Stanford 3D semantic parsing data Set.</p><p>在这一项任务中，输入不在是三维向量，而是九维，包括 (三维坐标，RGB值，归一化后的三维坐标)。得到的结果如下：</p><h2 id="四理论分析">四、理论分析</h2><p>在这一章节中，给出一些理论上的分析。</p><h3 id="近似逼近性">4.1 近似逼近性</h3><p>首先，给出为什么可以用 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 来近似逼近函数 <span class="math inline">\(f\)</span>。</p><p>对于定义在集合上的连续函数 <span class="math inline">\(f\)</span> , 有如下的性质：</p><p><span class="math display">\[\begin{align}&amp;\chi = \{S:S\subseteq[0,1]^m and\; |S|=n \}\\&amp;f:\chi \to \mathbb{R},\mbox{ 是一个连续的集合函数。}\\&amp;\mbox{Hausdorff distance  } d_H(.,.) \mbox{ 定义元素之间的距离。}\\&amp; \forall\, \theta&gt;0, \exist  \,\delta&gt;0, for\;any\;S_1,S_2\in\chi:\\&amp;if\;\;d_H(S_1,S_2)&lt;\delta, then\;|f(S_1)-f(S_2)|&lt;\theta\end{align}\]</span></p><p>由于连续函数 <span class="math inline">\(f\)</span> 有了这个性质，那么我们就可以定义一个对称函数 <span class="math inline">\(g\)</span> ，是一个<span class="math inline">\(\gamma\)</span> 和 max的复合函数。使得函数 <span class="math inline">\(g\)</span> 作用于 <span class="math inline">\(h(x)\)</span> 之上的函数值与 <span class="math inline">\(f(S)\)</span> 之间的数值足够小。</p><p>换句话说，我们可以用这样一个作用于每一元素的函数 <span class="math inline">\(h\)</span> 以及一个对称函数 <span class="math inline">\(MAX\)</span> 来近似集合函数 <span class="math inline">\(f\)</span> 。</p><p><span class="math display">\[\begin{align}&amp;\forall \theta&gt;0,\;\exist \mbox{ 一个连续函数 }\;h\\&amp;\mbox{ 和一个对称函数 }\;g(x_1,...,x_n)=\gamma\circ MAX:\\&amp;\mbox{such that for any }\; S\in \chi :\\&amp;\bigg|f(S)-\gamma\bigg(MAX_{x_i\in S}\{h(x_i)\}\bigg)\bigg|&lt;\theta\\&amp; (x_1,...,x_n \mbox{ 是 }S\mbox{ 中的元素。})\end{align}\]</span></p><h3 id="稳定性分析">4.2 稳定性分析</h3><p>第二是全局特征维度的维度K对结果的影响，以及整个网络的鲁棒性分析。</p><p>首先令 <span class="math inline">\(u\)</span> 是由一个点集经过 <span class="math inline">\(h\)</span> 计算每个点，再进行最大池化，得到一个 k 维向量的函数，那么 <span class="math inline">\(f\)</span> 可以表示为 <span class="math inline">\(\gamma\)</span> 和 <span class="math inline">\(u\)</span> 的复合函数。</p><p>那么，对于任意一个点集 S，都存在另外两个点集 C 和 N ，使得在任意一个不小于 C 且不大于N 的点集 T，<span class="math inline">\(f(S) = f(T)\)</span>。即对于一个集合 <span class="math inline">\(S\)</span>, <span class="math inline">\(f(S)\)</span> 的函数值，只受到这个集合 <span class="math inline">\(C\)</span> 的影响，更多的点对于函数的结果并不起到作用。</p><p>b)说明C中点的个数不大于K。这个K就是特征的维度。因为我们在用 <span class="math inline">\(u\)</span> 做最大池化操作时，对于 K 维中的每一个，只会选择来自一个点的特征作为该位的最大值，也就是说 MAXPOOLING 操作只会选择 K 个起作用的点。</p><p>因此，maxpooling 时候的特征维度K会影响C，进而影响分类的准确率。</p>$$<span class="math display">\[\begin{align}&amp; 令\; u: \chi\to\mathbb{R}^K\\&amp;u=MAX_{X_i\in S}\{h(x_i)\}\;\;即u由一组点生成一个K维的向量。\\&amp;f=\gamma\circ u,则有：\\&amp;(a)\;\forall S,\; \exist \mathcal{C}_s \,\mathcal{N}_S\subseteq\chi,\,f(S)=f(T)\;if\;\mathcal{C}_s\subseteq T\subseteq \mathcal{N}_S\\&amp;(b)\; |\mathcal{C}_S|\leq K\end{align}\]</span><p>$$</p><p><span class="math display">\[\begin{align}&amp;(a)式说明\;f(S)\;的函数值由一组关键点\mathcal{C}_S 决定\\&amp;且添加的噪声点只要不超过\mathcal{N}_S,对函数值不会产生影响。\\&amp;(b)式说明关键点的个数 |\mathcal{C}_S|存在上界,\\&amp;不大于K，即最大池化时特征的维数。\end{align}\]</span></p><p><span class="math display">\[称 \mathcal{C}_S 为\; critical\; point\; set,K\;为\;bottleneck\; dimension\]</span></p><p>上述证明说明了此网络对于输入中一些微小的扰动与离群点具有很好的鲁棒性，并不会很大程度上影响结果。</p><p>下面给出了一些点云输入的 $_S $ 和 <span class="math inline">\(\mathcal{C}_N\)</span> 集合可视化例子。可以看出经过这个网络提取出的 <span class="math inline">\(\mathcal{C}_S\)</span> 集合，大体上描绘了这个物体的大致轮廓。</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102120.png"></div><p>下图是 maxpooling 的维度 K 对准确率的影响。横坐标是 K 设置的数值，纵坐标是分类的准确率。每条线是每个输入中点的数量。可以看到随着 K 的增加，准确率有所上升，但是当 K 到达 1000 左右时基本上就不再变了，所以本文中 K 的取值就是选择 1024 ，以达到效率与精确度的最好权衡。</p><h3 id="设计分析">4.3 设计分析</h3><p>在之前，提到过有三种方法解决无序性问题：排序、RNN、对称函数，现在给出这三种设计方法的效果对比：</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102123.png"></div><p>可以看到对称函数操作的准确性最高，而在所考虑的三种对称函数中，maxpooling 的准确性又是其中最高的。</p><p>此外，我们提到过 T-Net 对齐网络的作用，在这里给出它的实际效果，可以看出它可以在一定程度上提高分类的准确率。</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102125.png"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation [CVPR 2017]&lt;/p&gt;
    
    </summary>
    
      <category term="论文解读" scheme="http://maneback.github.io/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="点云" scheme="http://maneback.github.io/tags/%E7%82%B9%E4%BA%91/"/>
    
      <category term="深度学习" scheme="http://maneback.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="学习" scheme="http://maneback.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于微信的一件小事</title>
    <link href="http://maneback.github.io/2020/wechat-account/"/>
    <id>http://maneback.github.io/2020/wechat-account/</id>
    <published>2020-05-06T02:12:58.000Z</published>
    <updated>2021-03-17T11:03:01.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>首发于个人公众号<strong>不愿意透露姓名的松哥</strong>， <a href="https://mp.weixin.qq.com/s/wYHRxYCJoi1L6r0mJqV0uQ" target="_blank" rel="noopener">文章链接</a>， 文章略有修改。</p><p>我开始飘了，都开始写公众号文章了，都开始思考微信公众号的产品逻辑了，都开始分析评论公众号的种种优缺点了。</p></blockquote><p><strong>零</strong></p><p>最近，突然发现微信里面开始有了一些“小动作”。</p><p>比如文章底部开始有相关推荐，比如看一看里面开始带话题，比如信息流中开始有公众号推荐。</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102151.jpg"></div><p><strong>一</strong></p><p>稍微思考一下微信的使用时间，基本上可以分为以下两部分：聊天刷朋友圈+公众号文章阅读。只要你的好友也还在用微信，你就不得不保证前者的使用时长。而后者呢，则是由公众号文章的质量决定的。</p><p>再看一看近来（其实也不太近了）微信其他的一些更新：公众号改为信息流的形式，增加浮窗的个数，越来越强化看一看的推荐，（还在测试中的？）付费阅读？以及上述的几个小细节。这些功能都是针对后者的优化，也就是为公众号服务的，而不是针对普通用户。</p><p>获取讯息是多数人的重要需求。如果公众号的这些创作者不再在微信中创作，就有可能去微博、去知乎、去B站等等，而普通用户这方面在微信花费的时间也会流失。</p><p>微信公众号只是平台，而不生产内容。给内容创作者以更好的体验和有效的激励（更多真实的关注和阅读量）、创造更好的生态与创作环境，留下好的创作者，留下好的内容，用户使用时长自然也会增长。而人的时间和精力也是有限的，在微信上“浪费”的时间更多了，留给其他应用的时间也就更少了。</p><p><strong>二</strong></p><p>微信公众号确实产生了许多高质量的文章，也有很多优质的账号。但是与其他的内容平台还是有许多的不足。比如公众号中禁止插入外部链接（真很难理解这么大的一个互联网公司的这种做法），公众号文章那（几乎等于）没有的分享功能，更不要说公众号这（近乎）残废的留言互动功能。</p><p>公众号系统是以<strong>账号</strong>为中心的，而之外的知乎和微博等，则更多的偏向以内容为中心，比如热榜、热搜的存在等等，这种形式的内容传播，是可以覆盖到其所有用户的。此外，在微博上，内容可以在用户之间任意地转发传播以及曝光；在知乎上，用户更关注的是问题与问题之下的回答与讨论，也就是内容本身，有时用户对于内容的产出者并不是关注太多。</p><p>而对于公众号来讲，其内容的传播链条很短，更何况也无法被常用的搜索引擎爬取（有几个人知道在哪里可以搜索公众号的文章呢？）。几乎没有办法借助微信官方的推荐等等，来增加自己的关注量。即使现在微信官方去出面，去强化看一看功能，增加优质内容的推荐曝光，但是这种也同样是基于微信好友关系，那么势必会影响其传播范围。与微博、知乎官方所使用的推荐算法的覆盖范围差远了。</p><p>因此在那之前，对于公众号自媒体来讲，增加关注量是一件很困难的事情，他们要在微博、知乎、博客等各种平台留下自己的账号、利用自己在其他地方的影响力来给自己增加关注。用户也只能在其他应用、或是好友分享的某一篇文章、或是公众号主们之间的互推来关注到一个高价值的公众号。</p><p>但是也不得不承认，优质公众号的用户粘性极高，你看到的内容完全是你自己的选择。公众号有更多“个人品牌”的属性在里面。对一个公众号产生了认同感，才会去持续关注，追热点蹭热度很难带来持久的关注增长。也正是因为公众号系统以<strong>账号</strong>为中心，其也特别适合那种专一于特定主题，目标群体明确的账号。点点关注不迷路。</p><p><strong>最后</strong></p><p>在知乎上，关于微信一些设计与功能的提问与讨论也有很多。但是该用微信的人还是在用，毕竟在这个领域完全没有拿得出手的竞争者。微信的用户数量实在是太庞大了，用户实际的使用场景实在是太多了，它在功能上有很多被人们吐槽的地方。</p><p>但是你要明白：微信它本身只是一个即时通讯类的软件，而不是一个什么都包了的软件。你所觉得的一些功能残缺，可能这并不是它当初所设想的使用场景。微信的日活超过十亿，有人用它聊天，有人用它办公，有人用它卖货，也有人用它发广告等等等等。</p><p>只要你想明白了这件事情，你就会明白它为什么对某些用户需求无动于衷。同时要考虑它做出某些改进的原因。</p><p>另外最近在微博上面也看到了这样一段话：</p><div class="figure"><img src="https://gitee.com/MyTypora/typorapic/raw/master/20210224102158.jpg"></div><p>虽然主语讲的是微博，但是对微信来说也是同理。</p>]]></content>
    
    <summary type="html">
    
      我的第一篇微信公众号文章
    
    </summary>
    
      <category term="公众号文章" scheme="http://maneback.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="微信公众号" scheme="http://maneback.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>要买要看的书</title>
    <link href="http://maneback.github.io/2020/books/"/>
    <id>http://maneback.github.io/2020/books/</id>
    <published>2020-03-16T07:15:39.000Z</published>
    <updated>2021-01-04T13:36:59.305Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="心理人生认知理财">心理、人生、认知、理财</h2><ul><li>人格障碍的认知行为疗法</li><li>谁动了我的奶酪</li><li>思考快与慢</li><li>就业 利息与货币通论</li><li>被讨厌的勇气</li></ul><hr><h2 id="程序员必备">程序员必备</h2><ul><li>C++ Primer Plus</li><li>设计模式</li><li>编程珠玑</li><li>代码整洁之道</li><li>数据科学实战</li><li>Python3 反爬虫原理与绕过实战</li></ul>]]></content>
    
    <summary type="html">
    
      多读书
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Music</title>
    <link href="http://maneback.github.io/2020/music-test/"/>
    <id>http://maneback.github.io/2020/music-test/</id>
    <published>2020-03-03T13:22:16.000Z</published>
    <updated>2021-01-04T13:36:59.319Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>终于找到了在博客中插入音乐的方法了。之前在网易云生成外链的方法不知道怎么就失效了呢。</p><p>新的方法使用了 <a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a> 和 <a href="https://github.com/metowolf/MetingJS" target="_blank" rel="noopener">MetingJS</a> 。</p><p>先来一首最近非常非常喜欢的一个翻唱歌手唱的一首歌：</p>    <div id="aplayer-OkPDDiBW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="567935536" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><h4 id="安装">1. 安装</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span>  <span class="comment">--save hexo-tag-aplayer</span></span><br></pre></td></tr></table></figure><h4 id="使用">2.使用</h4><p>aplayer可以引用本地的音乐文件，但是有时候显然会比较麻烦</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure><ul><li><code>title</code> : 曲目标题</li><li><code>author</code>: 曲目作者</li><li><code>url</code>: 音乐文件 URL 地址</li><li><code>picture_url</code>: (可选) 音乐对应的图片地址</li><li><code>narrow</code>: （可选）播放器袖珍风格</li><li><code>autoplay</code>: (可选) 自动播放，移动端浏览器暂时不支持此功能</li><li><code>width:xxx</code>: (可选) 播放器宽度 (默认: 100%)</li><li><code>lrc:xxx</code>: （可选）歌词文件 URL 地址</li></ul><p>需要开启hexo的文章资源文件夹功能，将图片、音乐文件、歌词文件都放在与文章相对应的资源文件夹中，然后直接引用</p><h4 id="metingjs">3. MetingJS</h4><p>现在hexo的配置文件<code>_config.yml</code>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">  meting:</span><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>接着就可以用<code>\    <div id="aplayer-zzRCTjhb" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="undefined" data-server="undefined" data-type="undefined" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div></code>在文章中使用播放器了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简单示例 (id, server, type)  --&gt;</span></span><br><span class="line">&#123;% meting "60198" "netease" "playlist" "mini:true" %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr class="even"><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr class="odd"><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr class="even"><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr class="odd"><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr class="even"><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr class="odd"><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr class="even"><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr class="odd"><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr class="even"><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr class="odd"><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr class="even"><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr class="odd"><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr class="even"><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr class="odd"><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr class="even"><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      在 hexo 博客中插入音乐
    
    </summary>
    
      <category term="Amazing" scheme="http://maneback.github.io/categories/Amazing/"/>
    
    
  </entry>
  
  <entry>
    <title>latex 速查表</title>
    <link href="http://maneback.github.io/2020/latex/"/>
    <id>http://maneback.github.io/2020/latex/</id>
    <published>2020-02-18T09:15:00.000Z</published>
    <updated>2021-01-04T13:36:59.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一-集合操作">一、 集合操作</h1><table><tbody><tr class="odd"><td><code>\mid</code></td><td><span class="math inline">\(A \mid B\)</span></td></tr><tr class="even"><td>属于<code>\in</code></td><td><span class="math inline">\(a_i\in A\)</span></td></tr><tr class="odd"><td>不属于<code>\not\in</code></td><td><span class="math inline">\(a_i\not\in A\)</span></td></tr><tr class="even"><td>包含于<code>\subset</code></td><td><span class="math inline">\(A \subset B\)</span></td></tr><tr class="odd"><td>子集 <code>\subseteq</code></td><td><span class="math inline">\(A \subseteq B\)</span></td></tr><tr class="even"><td>真包含于<code>\subsetneqq</code></td><td><span class="math inline">\(A \subsetneqq B\)</span></td></tr><tr class="odd"><td>包含<code>\supset</code></td><td><span class="math inline">\(A \supset B\)</span></td></tr><tr class="even"><td>真包含 <code>\supsetneqq</code></td><td><span class="math inline">\(A \supsetneqq B\)</span></td></tr><tr class="odd"><td>交集<code>\cap</code></td><td><span class="math inline">\(A \cap B\)</span></td></tr><tr class="even"><td>并集 <code>\cup</code></td><td><span class="math inline">\(A \cup B\)</span></td></tr><tr class="odd"><td>实数集合 <code>\mathbb{R}</code></td><td><span class="math inline">\(\mathbb{R}\)</span></td></tr><tr class="even"><td>空集<code>\emptyset</code></td><td><span class="math inline">\(\emptyset\)</span></td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h1 id="二数学运算">二、数学运算</h1><table><colgroup><col width="52%"><col width="47%"></colgroup><tbody><tr class="odd"><td>分数 <code>\frac{}{}</code></td><td><span class="math inline">\(\frac{a}{b}\)</span></td></tr><tr class="even"><td>花体字母<code>\mathbb{}</code></td><td><span class="math inline">\(\mathbb{ABC}\)</span></td></tr><tr class="odd"><td><code>\nabla</code></td><td><span class="math inline">\(\nabla\)</span></td></tr><tr class="even"><td><code>\partial</code></td><td><span class="math inline">\(\partial x\)</span></td></tr><tr class="odd"><td>不等号<code>\neq</code></td><td><span class="math inline">\(x \neq 1\)</span></td></tr><tr class="even"><td>角度`<code>\sin\!\frac{\pi}{3}=\sin60^\{operatorname{\omicron}}</code></td><td><span class="math inline">\(\sin\!\frac{\pi}{3}=\sin60^{\operatorname{\omicron}}\)</span></td></tr></tbody></table><h1 id="三逻辑">三、逻辑</h1><table><tbody><tr class="odd"><td>逻辑与 <code>land</code></td><td><span class="math inline">\(A \land B\)</span></td></tr><tr class="even"><td>逻辑或 <code>lor</code></td><td><span class="math inline">\(A \lor B\)</span></td></tr><tr class="odd"><td>逻辑非 <code>\lnot</code></td><td><span class="math inline">\(\lnot B\)</span></td></tr><tr class="even"><td><code>\to</code></td><td><span class="math inline">\(p\to q\)</span></td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h1 id="三上标下标及积分等">三、上标、下标及积分等</h1><table><tbody><tr class="odd"><td>前置上下标<code>{}_1^2X_3^4</code></td><td><span class="math inline">\({}_1^2X_3^4\)</span></td></tr><tr class="even"><td>向量 <code>\vec{x}</code></td><td><span class="math inline">\(\vec{x}\)</span></td></tr><tr class="odd"><td>无穷 <code>\infty</code></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td>求和 <code>\sum_{k=1}^n x_k</code></td><td><span class="math inline">\(\sum_{k=1}^n x_k\)</span></td></tr><tr class="odd"><td>求积<code>\prod_{k=1}^n x_k</code></td><td><span class="math inline">\(\prod_{k=1}^n x_k\)</span></td></tr><tr class="even"><td>极限 <code>\lim_{n \to \infty} x_n</code></td><td><span class="math inline">\(\lim_{n \to \infty} x_n\)</span></td></tr><tr class="odd"><td>积分 <code>\int_{-N}^{N} e^x</code></td><td><span class="math inline">\(\int_{-N}^{N} e^x\)</span></td></tr><tr class="even"><td>双重积分 <code>\iint_{D}^{W}\,dx\,dy</code></td><td><span class="math inline">\(\iint_{D}^{W}xy\,dxdy\)</span></td></tr><tr class="odd"><td>三重积分<code>\iiint_{E}^{V}\,xyz\,dxdydz</code></td><td><span class="math inline">\(\iiint_{E}^{V}\,xyz\,dxdydz\)</span></td></tr><tr class="even"><td>曲线曲面积分<code>\oint_{C}x^3\,dx+4y^2\,dy</code></td><td><span class="math inline">\(\oint_{C}x^3\,dx+4y^2\,dy\)</span></td></tr></tbody></table><h1 id="四分数矩阵和多行列式">四、分数、矩阵和多行列式</h1><table><colgroup><col width="52%"><col width="47%"></colgroup><tbody><tr class="odd"><td>分数<code>\frac{1}{2}=0.5</code></td><td><span class="math inline">\(\frac{1}{2}=0.5\)</span></td></tr><tr class="even"><td>小分数<code>\tfrac{1}{2}=0.5</code></td><td><span class="math inline">\(\tfrac{1}{2}=0.5\)</span></td></tr><tr class="odd"><td>二项式系数<code>\dbinom{n}{r}=C_n^r</code></td><td><span class="math inline">\(\dbinom{n}{r}=C_n^r\)</span></td></tr><tr class="even"><td>矩阵<code>\begin{matrix}x&amp;y \\ z&amp;v\end{matrix}</code></td><td><span class="math display">\[\begin{matrix}x&amp;y \\ z&amp;v\end{matrix}\]</span></td></tr><tr class="odd"><td>矩阵<code>\begin{vmatrix}x&amp;y \\ z&amp;v\end{vmatrix}</code></td><td><span class="math inline">\(\begin{vmatrix}x&amp;y \\ z&amp;v\end{vmatrix}\)</span></td></tr><tr class="even"><td>矩阵<code>\begin{Vmatrix}x&amp;y \\ z&amp;v\end{Vmatrix}</code></td><td><span class="math inline">\(\begin{Vmatrix}x&amp;y \\ z&amp;v\end{Vmatrix}\)</span></td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td></td><td></td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h2 id="矩阵">矩阵</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">x &amp; y \\</span><br><span class="line">z &amp; v</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{matrix}x &amp; y \\z &amp; v\end{matrix}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line"><span class="number">0</span> &amp; \cdots &amp; <span class="number">0</span> \\</span><br><span class="line">\vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line"><span class="number">0</span> &amp; \cdots &amp; <span class="number">0</span></span><br><span class="line">\<span class="keyword">end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{bmatrix}0 &amp; \cdots &amp; 0 \\\vdots &amp; \ddots &amp; \vdots \\0 &amp; \cdots &amp; 0\end{bmatrix}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line"><span class="number">1</span> &amp; <span class="number">2</span> \\</span><br><span class="line"><span class="number">3</span> &amp; <span class="number">4</span></span><br><span class="line">\<span class="keyword">end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{Bmatrix}1 &amp; 2 \\3 &amp; 4\end{Bmatrix}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">a &amp; b \\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{pmatrix}a &amp; b \\c &amp; d\end{pmatrix}\]</span></p><ul><li>条件定义</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n)=</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">n/<span class="number">2</span>, &amp; \mbox&#123;<span class="keyword">if</span> &#125;n \mbox&#123; is even&#125; \\</span><br><span class="line"><span class="number">3</span>n+<span class="number">1</span>, &amp; \mobx&#123;<span class="keyword">if</span> &#125;n \mobx&#123; is odd&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[f(n)=\begin{cases}n/2, &amp; if\; n\;is\; even \\3n+1, &amp; if\; n\; is\; odd\end{cases}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">f(x)&amp;=(m+n)^<span class="number">2</span> \\</span><br><span class="line">&amp;=m^<span class="number">2</span> + <span class="number">2</span>mn + n^<span class="number">2</span>\\</span><br><span class="line">\<span class="keyword">end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{align}f(x)&amp;=(m+n)^2 \\&amp;=m^2 + 2mn + n^2\\\end{align}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;alignat&#125;&#123;<span class="number">2</span>&#125;</span><br><span class="line">f(x) &amp; = (m-n) ^ <span class="number">2</span> \\</span><br><span class="line">f(x) &amp; = (-m+n) ^ <span class="number">2</span> \\</span><br><span class="line">&amp; = m^<span class="number">2</span><span class="number">-2</span>mn+n^<span class="number">2</span> \\</span><br><span class="line">\<span class="keyword">end</span>&#123;alignat&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{alignat}{2}f(x) &amp; = (m-n) ^ 2 \\f(x) &amp; = (-m+n) ^ 2 \\&amp; = m^2-2mn+n^2 \\\end{alignat}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;lcl&#125;</span><br><span class="line">z &amp; = &amp; a\\</span><br><span class="line">f(x,y,z) &amp; = &amp; x+y+z</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{array}{lcl}z &amp; = &amp; a\\f(x,y,z) &amp; = &amp; x+y+z\end{array}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125;</span><br><span class="line"><span class="number">3</span>x + <span class="number">5</span>y +  z \\</span><br><span class="line"><span class="number">7</span>x - <span class="number">2</span>y + <span class="number">4</span>z \\</span><br><span class="line"><span class="number">-6</span>x + <span class="number">3</span>y + <span class="number">2</span>z</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{cases}3x + 5y +  z \\7x - 2y + 4z \\-6x + 3y + 2z\end{cases}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\begin&#123;array&#125;&#123;|c|c||c|&#125; a &amp; b &amp; S \\</span><br><span class="line">\hline</span><br><span class="line"><span class="number">0</span>&amp;<span class="number">0</span>&amp;<span class="number">1</span>\\</span><br><span class="line"><span class="number">0</span>&amp;<span class="number">1</span>&amp;<span class="number">1</span>\\</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">0</span>&amp;<span class="number">1</span>\\</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">1</span>&amp;<span class="number">0</span>\\</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{array}{|c|c|c|} a &amp; b &amp; S \\\hline0ooo&amp;0&amp;1\\0&amp;1&amp;1\\1&amp;0&amp;1\\1&amp;1&amp;0\\\end{array}\]</span></p><h1 id="五字体">五、字体</h1><h2 id="希腊字母">希腊字母</h2><ul><li>大写</li></ul><table><thead><tr class="header"><th></th><th align="center"></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Alpha\)</span></td><td align="center"><span class="math inline">\(\Beta\)</span></td><td><span class="math inline">\(\Gamma\)</span></td><td><span class="math inline">\(\Delta\)</span></td><td><span class="math inline">\(\Epsilon\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Zeta\)</span></td><td><span class="math inline">\(\Eta\)</span></td><td><span class="math inline">\(\Theta\)</span></td><td><span class="math inline">\(\Iota\)</span></td><td><span class="math inline">\(\Kappa\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th>\Nu</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Lambda\)</span></td><td><span class="math inline">\(\Mu\)</span></td><td><span class="math inline">\(\Nu\)</span></td><td><span class="math inline">\(\Xi\)</span></td><td><span class="math inline">\(\Omicron\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Pi\)</span></td><td><span class="math inline">\(\Rho\)</span></td><td><span class="math inline">\(\Sigma\)</span></td><td><span class="math inline">\(\Tau\)</span></td><td><span class="math inline">\(\Upsilon\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th>\\\\\\</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Phi\)</span></td><td><span class="math inline">\(\Chi\)</span></td><td><span class="math inline">\(\Psi\)</span></td><td><span class="math inline">\(\Omega\)</span></td><td></td></tr></tbody></table><ul><li>小写</li></ul><table><thead><tr class="header"><th align="center"></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td align="center"><span class="math inline">\(\alpha\)</span></td><td><span class="math inline">\(\beta\)</span></td><td><span class="math inline">\(\gamma\)</span></td><td><span class="math inline">\(\delta\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td><span class="math inline">\(\eta\)</span></td><td><span class="math inline">\(\theta\)</span></td><td><span class="math inline">\(\iota\)</span></td><td><span class="math inline">\(\kappa\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\varkappa\)</span></td><td><span class="math inline">\(\lambda\)</span></td><td><span class="math inline">\(\mu\)</span></td><td><span class="math inline">\(\nu\)</span></td><td><span class="math inline">\(\xi\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><span class="math inline">\(\pi\)</span></td><td><span class="math inline">\(\rho\)</span></td><td><span class="math inline">\(\sigma\)</span></td><td><span class="math inline">\(\tau\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td>$$</td><td><span class="math inline">\(\chi\)</span></td><td><span class="math inline">\(\psi\)</span></td><td><span class="math inline">\(\omega\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\varepsilon\)</span></td><td><span class="math inline">\(\vartheta\)</span></td><td>$ $</td><td><span class="math inline">\(\varpi\)</span></td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><span class="math inline">\(\varsigma\)</span></td><td><span class="math inline">\(\varphi\)</span></td></tr></tbody></table><h2 id="字体">字体</h2><h4 id="粗体">粗体</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathbb&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\]</span></p><p>只有大写拉丁字母才能正常显示，使用小写字母或数字时会得到其他符号。</p><hr><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\boldsymbol&#123;\Alpha \alpha \Beta \<span class="built_in">beta</span>&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\boldsymbol{\Alpha \alpha \Beta \beta}\]</span></p><p>粗体的希腊字母，大小写均可</p><hr><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathbf&#123;<span class="number">012</span>,abc,ABC&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathbf{012,abc,ABC}\]</span></p><p>拉丁字母和数字的粗体，不能用于希腊字母。</p><h4 id="哥特体">哥特体</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\mathfrak&#123;abcdefghijklmnopqrstuvwxyz&#125;</span><br><span class="line">\mathfrak&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br><span class="line">\marhfrak&#123;<span class="number">1234567890</span>&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathfrak{abcdefghijklmnopqrstuvwxyz}\\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\\mathfrak{1234567890}\]</span></p><h4 id="手写体">手写体</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathcal&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\]</span></p><p>注意：手写字体仅对大写拉丁字母有效。</p><h1 id="六括号">六、括号</h1><h1 id="其他">其他</h1><table><tbody><tr class="odd"><td>加帽子^ <code>\hat</code> 或者<code>\widehat</code></td><td><span class="math inline">\(\hat A\)</span></td></tr><tr class="even"><td>上划线 <code>\overline</code></td><td>$ A$</td></tr><tr class="odd"><td>下划线<code>\undweline</code></td><td><span class="math inline">\(\underline{A}\)</span></td></tr><tr class="even"><td>加波浪线 <code>\widetilde</code></td><td><span class="math inline">\(\widetilde A\)</span></td></tr><tr class="odd"><td>加点 <code>\dot{}</code></td><td><span class="math inline">\(\dot A\)</span></td></tr><tr class="even"><td>加两个点 <code>\ddot</code></td><td><span class="math inline">\(\ddot A\)</span></td></tr><tr class="odd"><td>加箭头 <code>\vec</code></td><td><span class="math inline">\(\vec A\)</span></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      latex 常用公式速查表
    
    </summary>
    
      <category term="knowledge" scheme="http://maneback.github.io/categories/knowledge/"/>
    
    
      <category term="latex" scheme="http://maneback.github.io/tags/latex/"/>
    
  </entry>
  
</feed>
