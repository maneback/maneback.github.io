{"meta":{"title":"漠·然","subtitle":"Maneback's Blog","description":null,"author":"Maneback","url":"http://maneback.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-02-20T10:11:23.000Z","updated":"2021-01-04T13:36:59.338Z","comments":false,"path":"tags/index.html","permalink":"http://maneback.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-02-20T10:12:43.000Z","updated":"2021-01-04T13:36:59.337Z","comments":false,"path":"categories/index.html","permalink":"http://maneback.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"正则表达式","slug":"regx","date":"2021-08-14T03:37:17.000Z","updated":"2021-08-14T03:37:52.727Z","comments":true,"path":"2021/regx/","link":"","permalink":"http://maneback.github.io/2021/regx/","excerpt":"","text":"正则表达式 1. 限定符 限定符用来指定正则表达式的一个给定组件要出现多少次才能满足匹配，共有*、?、+、{n}、{n,}，{n,m}六种，他们的描述如下：（限定出现次数） 字符 描述 * 匹配前面的子表达式零次或多次，等价于{0,} + 匹配前面的子表达式一次或多次，等价于{1,} ？ 匹配前面的子表达式零次或一次，等价于{0,1} {n} n是一个非负数，匹配确定的n次 {n,} 至少匹配n次 {n,m} 最少匹配n次且最多匹配m次。注意在逗号和两个数之间不能有空格。 注意：*和+都是贪婪的，他们会尽可能匹配多的文字，只有在它们后面加上一个?就可以实现非贪婪匹配。 2. 普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有的大小写字母、所有的数字、所有的标点和一些其他符号。 3. 非打印字符 4. 特殊字符 特殊字符是一些有特殊含义的字符。 特殊字符 描述 $ 匹配输入字符串的结尾位置 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪的限定符 . 匹配除换行符之外的任何单字符 [ 标记一个中括号表达式的开始 \\ 将下一个字符标记为或特殊字符、或原意字符、或向后引用、或八进制转义符。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，表示不接受该字符集合 { 标记限定符表达式的开始 | 指明两项之间的一个选择 当你想匹配表格中列举的特殊字符的话，请在该字符前面加上\\。 5. 定位符 定位符使得能够将正则表达式固定到行首或行尾，还能创建出现在一个单词内，在一个单词开头或者结尾的表达式， 定位符用于描述字符串或单词的边界，^和$分别标记字符串的开始和结尾。\\b描述单词的前或后边界，\\B表示非单词边界。 定位符有： 定位符 描述 ^ 匹配输入字符串开始的位置。 $ 匹配输入字符串结束的位置。 匹配一个单词边界，即字与空格之间的位置。 非单词边界匹配 注意： 不能将限定符和定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上的位置。 6. 选择 用圆括号将所有的选择项括出来，相邻的选择项用|分隔，但用圆括号会使相关的匹配被缓存（什么是缓存？），因此可以放一个?:放在选择项前消除这种副作用。 7. 反向引用 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。可以使用非捕获元字符?:, ?=, ?! 来重写捕获，忽略对相关匹配的保存。 匹配规则 1. 基本匹配模式 从最基本的开始。模式 是正则表达式的最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，也可以很复杂，如： 123^onceonce$^once$ 该模式包含一个特殊字符^，匹配那些以once开头的字符串。$匹配以该模式结尾的字符串。而当二者同时使用时，代表精准匹配一个模式。 如果一个模式不包括^ $， 那么它与任何包含该模式的字符串匹配，例如： 1once 与字符串 12There once was a man from NewYorkWho kept all of his cash in a bucket. 都是匹配的。 2. 字符族 可以用方括号来表示字符族，如，以下元音字符族： 1[AaEeIiOoUu] 以及表示范围的字符族 12345[a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9\\.\\-] //匹配所有的数字，句号和减号 这些字符族只表示一个字符。如我们要匹配又一个小写字母加一位数字组成的两位的字符串，可以用以下这个模式： 1^[a-z][0-9]$ 这里的^表示字符串开头，但是在一组方括号中使用^时，表示“非”和“排除”的意思，即不能包含该字符 1^[^0-9][0-9]$ 表示第一位不能为数字","categories":[{"name":"技术","slug":"技术","permalink":"http://maneback.github.io/categories/技术/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://maneback.github.io/tags/正则表达式/"}]},{"title":"排序算法汇总","slug":"sortings","date":"2021-07-22T02:01:30.000Z","updated":"2021-08-14T03:35:22.018Z","comments":true,"path":"2021/sortings/","link":"","permalink":"http://maneback.github.io/2021/sortings/","excerpt":"对比总结常见的排序算法： 选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序","text":"对比总结常见的排序算法： 选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、计数排序、堆排序、基数排序 排序算法 均默认为升序排列。 选择排序 每次遍历数组，找到未排序中的最小元素，然后放到已排序的末尾位置，直到所有的元素均排序完毕。 123456789def selection_sort(nums): n = len(nums) for i in range(n): for j in range(i, n): if nums[i]&gt;nums[j]: nums[i], nums[j] = nums[j], nums[i] print(nums) return nums 冒泡排序 每次比较两个相邻元素，较大的元素每次移动一个位置，不断地冒泡到数组末尾。 1234567891011def bubble_sort(nums): n = len(nums) for i in range(n): flag = False for j in range(1, n-i): if nums[j-1]&gt;nums[j]: flag = True nums[j], nums[j-1] = nums[j-1], nums[j] if not flag: break return nums 插入排序 每次选择一个数，在前面已排序好的序列中寻找该数字应该所在的位置，并向后移动部分已排序数字，将新数字插入到相应位置。 1234567891011def insert_sort(nums): n = len(nums) for c in range(1, n): idx = c n = nums[c] while idx&gt;0 and nums[idx-1]&gt;n: nums[idx] = nums[idx-1] idx-=1 nums[idx] = n print(nums) return nums 希尔排序 希尔排序是对插入排序的改进版。在插入排序中， 数字每一次只能移动一个位置，而希尔排序是增加移动间隔，使较小的数字能更加快速地移动到队列头部。 具体算法描述如下： 选择一个增量序列 \\(g_1 &gt; g_2&gt;\\cdots&gt; g_k\\) 且 \\(g_k=1\\)。 对于每一个增量\\(g\\), 进行一次排序。 在每次排序中，按照间隔进行一次插入排序。 12345678910111213def shell_sort(nums): n = len(nums) gap=n//2 while gap: for c in range(gap, n): i = c while i-gap&gt;=0 and nums[i-gap]&gt;gap: nums[i-gap], nums[i] = nums[i], nums[i-gap] print(nums) i-=gap gap = gap//2 return nums 归并排序 归并排序是一种分治思想，先将数组分为子序列，缩小问题规模，让每个子序列各自有序，然后再将有序的子序列合并成一个完整数组。这样每一次的问题规模都变为原问题的 1/2。 12345678910111213141516171819202122232425def merge_sort(nums): def merge(left, right): res = [] l, r = 0, 0 while l&lt;len(left) and r&lt;len(right): if left[l]&lt;right[r]: res.append(left[l]) l+=1 else: res.append(right[r]) r+=1 res += left[l:] res += right[r:] print( res) return res n = len(nums) if n==1: return nums mid = n//2 left = merge_sort(nums[:mid]) right = merge_sort(nums[mid:]) return merge(left, right) 快排 快排是选取一个哨兵位置，将小于哨兵的数据全部放到左边，将大于哨兵的数据全放到右边，然后再用相同的思想对左右两边继续排序。 1234567891011121314151617181920def quick_sort(nums): n = len(nums) def quick(left, right): # print(left, right) if left&gt;=right: return nums pivot = left i, j = left, right while i&lt;j: while i&lt;j and nums[j]&gt;nums[pivot]: j-=1 while i&lt;j and nums[i]&lt;=nums[pivot]: i+=1 nums[i], nums[j] = nums[j], nums[i] nums[pivot], nums[j] = nums[j], nums[pivot] quick(left, j-1) quick(j+1, right) # print(nums) return nums return quick(0, n-1) 计数排序 计数排序是开辟额外的空间来存储每个值的出现次数，然后再根据计数填充数组。 12345678910111213141516def count_sort(nums): if not nums: return [] n = len(nums) _min = min(nums) _max = max(nums) tmp_arr = [0]*(_max-_min+1) for num in nums: tmp_arr[nums-_min]+=1 j = 0 for i in range(n): while tmp_arr[j]==0: j+=1 nums[i] = j+_min tmp_arr[j] -= 1 return nums 堆排序 堆排序是使用了堆这个数据结构来进行的排序算法。把一维的数组想象成一个二叉树（堆）结构。 过程如下： 建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆； 交换堆顶和最后一个元素，重新调整堆。 1234567891011121314151617181920def heap_sort(nums): def adjust_heap(nums, startops, endops): pos = startops childops = pos*2+1 if childops&lt;endops: rightops = childops+1 if rightops&lt;endops and nums[rightops]&gt;nums[childops]: childops = rightops if nums[childops]&gt;nums[pos]: nums[pos], nums[childops] = nums[childops], nums[pos] adjust_heap(nums, childops, endops) n = len(nums) # 从后往前即低向上 for i in reversed(range(n//2)): adjust_heap(nums, i,n) for i in range(n-1, -1, -1): nums[0], nums[i] = nums[i], nums[0] adjust_heap(nums, 0, i) return nums 基数排序 基数排序是针对数字每一位进行排序，从最低位开始排序 123456789101112131415161718192021def radix_sort(nums): if not nums: return [] _max = max(nums) max_digit = len(str(_max)) buckList = [[] for _ in range(10)] div, mod = 1, 10 for i in range(max_digit): for num in nums: buckList[num%mod//div].append(num) div *= 10 mod *= 10 idx = 0 print(buckList) for j in range(10): for item in buckList[j]: nums[idx] = item idx += 1 buckList[j] = [] print(nums) return nums 对比 下面对排序算法做一个总结和对比。 image-20210814104124495","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://maneback.github.io/tags/排序算法/"}]},{"title":"背包问题","slug":"beibao","date":"2021-06-15T11:22:56.000Z","updated":"2021-08-14T03:39:48.899Z","comments":true,"path":"2021/beibao/","link":"","permalink":"http://maneback.github.io/2021/beibao/","excerpt":"","text":"问题描述 对于背包问题，是求在具有容量（质量体积个数）约束的情况下，求所有商品满足约束的可行性解、最优解或解的个数。 一般化描述 本文关注于 0-1 背包问题，即：每个物品只有一个。 物品总数 \\(n\\) 背包容量 \\(W\\) 物品质量 \\(w_i\\) 物品价值 \\(p_i\\) 总质量约束为 \\(W\\) 物品的质量/成本为 \\(w_i\\) 物品的价值为 \\(p_i\\) 一般来讲，背包问题可以用动态规划问题来求解。对于背包问题有三类，即：求是否有可行解、最优解的值（价值最大化最小化）、求可行解的总个数。这三类问题对应了三种动态规划递推式。 好多问题都可以转化成背包问题来求解。 对于每一类问题，在这里我们用到动态规划数组 dp[i][j] 表示前 \\(i\\) 商品放入容量为 \\(j\\) 的背包时的解。 问题分类 最大价值 其转移方程如下： \\[ f[i][j] = \\cases{f[i-1][j]\\\\f[i-1][j-w_i]+p_i} \\] 初始化时，dp[0][0]=0。 第一种情况表示不放置第 \\(i\\) 件商品，第二种情况表示放置，所以要给它腾出 \\(w_i\\) 大小的空间。 1234567def bp(weights, profit, W): n = len(weights) dp = [[0]* (W+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(profit[i-1], W+1): dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+profit[i-1]) return dp[n][W] 在这里，我们看到，数组 dp 只会用到前面一行来更新，因此我们可以用一个一维的滚动数组来替代二维数组降低空间复杂度。同时在遍历容量时，会用到上一行中小于当前容量的数据，并不会用到大于当前容量的数据。因此要对一维数组对容量进行倒序遍历。 可行解数量 例题： 494 目标和 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 数组总和为 sum， 设添加 + 的数字和为 positive, 添加 - 的数字和为negative，则有一下方程组成立 \\[ \\cases{positve+negative = sum\\\\ positive-negative = target} \\] 解方程组可得： \\[ negative = \\frac{sum-target}{2} \\] 即从数组中找到若干个数字和为 negative，求解的个数。 数字大小即为成本。 dp[i] 表示和为 i 的解的个数。 在每一个数字开始循环时，dp[i]表示的既是上一轮的解的个数，又是当前轮不包含当前数组的情况下的解的个数。因此再加上包含当前数字的情况的解的个数，即为本轮的解。 初始化为dp[0] = 1 其他为0， 表示和为 0 有一种解，即什么都不选。 12345678910111213141516171819202122232425def findTargetSumWays(nums, target): s = sum(nums) if (s-target)%2==1 or target&gt;s: return 0 V = (s-target)//2 dp = [0]*(V+1) dp[0] = 1 for n in nums: for v in range(V, n-1, -1): dp[v] += dp[v-n] return dp[-1] # 二维 dp n = len(nums) V = (s-target)//2 dp = [[0]*(V+1) for _ in range(n+1)] dp[0][0] = 1 for i in range(1, n+1): num = nums[i-1] for j in range(V+1): # 因为这第 i 行还没有赋值，下一行可能被用到，所以要从 0 开始遍历。 dp[i][j] = dp[i-1][j] if j&gt;=num: dp[i][j]+=dp[i-1][j-num] return dp[-1][-1] 是否存在可行解 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 输入：[1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 同样，在每一个数组开始循环前， 12345678910111213141516171819202122232425def canPatrition(nums): s = sum(nums) if s%2==1: return False V = s//2 dp = [False]*(V+1) for n in nums: for v in range(V, n-1, -1): dp[v] = dp[v]|dp[v-n] return dp[-1] # 二维 dp n = len(nums) V = s//2 dp = [[False]*(V+1) for _ in range(n+1)] dp[0][0] = True for i in range(1, n+1): for j in range(V+1): # 因为这第 i 行还没有被赋值，而前面的可能会被下一行用到，所以要从 0 开始赋值。把上一行的复制下来 dp[i][j] = dp[i-1][j] if j&gt;=nums[i-1]: dp[i][j] = dp[i][j] | dp[i-1][j-nums[i-1]] return dp[-1]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"背包问题","slug":"背包问题","permalink":"http://maneback.github.io/tags/背包问题/"}]},{"title":"slidingwindow","slug":"slidingwindow","date":"2021-06-14T13:29:42.000Z","updated":"2021-08-14T03:31:11.359Z","comments":true,"path":"2021/slidingwindow/","link":"","permalink":"http://maneback.github.io/2021/slidingwindow/","excerpt":"滑动窗口","text":"滑动窗口 滑动窗口 滑动窗口可以用来解决一系列的数组问题，如最长无重复子数组（子串）、窗口最大值、满足某种条件的最长数组/最短数组。 感觉滑动窗口可以分为几类： 定长窗口 寻找最长窗口 寻找最短窗口 其主要的区别就在于：如何添加元素、合适进行窗口的合理性判断（即判断是否满足条件）以及更新答案。 对于定长窗口来讲，只要一直保持窗口的长度，每次增加一个元素并删除一个元素即可。 对于最长窗口来讲，每次删除一个最左元素，然后一直扩展右边界，直到不满足条件（窗口内仍满足条件），再更新答案。 对于最短窗口来讲，每次一直扩展右边界，直到不满足条件，然后再一直删除左元素，在循环中更新答案。（因为是寻找最短窗口，且在缩短左边界，因此这种情况下最后一次更新答案一定是最小值。） 存在重复元素II 题目链接 Leetcode-219 题目描述 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引i 和 j，使得 nums [i] = nums [j]，并且 i和j 的差的 绝对值 至多为 k。 分析 最初我是用一个dict 保存每个数字出现的次数，每次用滑动窗口添加元素删除元素，但是后来边界样例给我惊了，那就是当k的大小等于数组的长度的时候，是没有办法判断的。所以不能这样搞。 后来直接用字典记录每个数字最后出现的位置，再用位置去相减判断距离就好了。 错误代码 1234567891011121314from collections import defaultdictclass Solution: def containsNearbyDuplicate(self, nums, k): windows = defaultdict(int) for i in range(k): windows[nums[i]]+=1 for i in range(k, len(nums)): if windows[nums[i]]&gt;0: return True else: windows[nums[i-k]]-=1 windows[nums[i]]+=1 return False 正确代码 123456789class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: dit = &#123;&#125; for idx, n in enumerate(nums): if n in dit and idx-dit[n]&lt;=k: return True else: dit[n] = idx return False 爱生气的书店老板 题目链接 Leetcode-1052 题目描述 image-20210810140952301 分析 当已知有 grumpy 数组时候，对于不生气的情况，无论怎么怎么控制情绪，这部分满意的顾客总数是不会改变的，所以我们只需要考虑，老板控制了脾气之后，最大能 improve 多少挽回多少新的顾客。如果把 grumpy 与 customer 数组做 element-wise 乘积的话，就可以知道能够挽回的顾客数量，再进行 X 长度的子数组和取最大就好了。 1234567891011121314class Solution: def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -&gt; int: n = len(customers) level = sum([c*(1-g) for c, g in zip(customers, grumpy)]) inc = 0 for i in range(X): inc+= customers[i]*grumpy[i] max_inc = inc for i in range(X, n): inc = inc+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X] max_inc = max(inc, max_inc) return level + max_inc 无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 分析 依次枚举子串起始位置的左边界，记录以该位置开始子串的最长长度，每一次剔除一个最左字符串， 不断地扩展右边界。直到不满足条件位置，这时判断是否需要更新答案。 窗口内永远是满足条件的子串，而非剔除直到不满足。 12345678910111213class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ccc = set() n = len(s) rk, ans = -1, 0 for i in range(n): if i!=0: ccc.remove(s[i-1]) while rk+1&lt;n and s[rk+1] not in ccc: ccc.add(s[rk+1]) rk += 1 ans = max(ans, rk+1-i) return ans 滑动窗口最大值 题目描述 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 分析 只要用 滑动窗口 + 单调队列 即可解决，每次边界移动一个位置，向结果数组中添加一个元素。 代码 12345678910111213141516171819202122class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if k==1: return nums que = collections.deque() res = [] n = len(nums) # init for i in range(k): while que and que[-1]&lt;nums[i]: que.pop() que.append(nums[i]) res.append(que[0]) for i in range(k, n): if que[0]==nums[i-k]: que.popleft() while que and que[-1]&lt;nums[i]: que.pop() que.append(nums[i]) res.append(que[0]) return res 长度最小的子数组 题目描述 给定一个含有 n 个正整数的数组和一个正整数target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 分析 返回最小长度，依旧是扩充右边界，判断是否满足，缩减左边界 因为是最小长度，所以在缩减左边界时候更新答案 注意当退出内层 while 循环时，其实已经不满足和 &gt;= target 的条件了，所以要在 while 循环内部更新答案。窗口是在不断减小的，所以最后一次更新一定是最小的，不会影响结果的正确性。 123456789101112131415161718class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int: if sum(nums)&lt;target: return 0 if sum(nums)==target: return len(nums) n = len(nums) left, right = 0, 0 wind_sum = 0 res = n+1 while right&lt;n: wind_sum += nums[right] while wind_sum&gt;=target: res = min(res, right-left+1) wind_sum-=nums[left] left+=1 right += 1 return 0 if res==n+1 else res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://maneback.github.io/tags/滑动窗口/"}]},{"title":"Linux 定时任务","slug":"crontab","date":"2021-05-22T07:29:33.000Z","updated":"2021-08-14T03:36:44.098Z","comments":true,"path":"2021/crontab/","link":"","permalink":"http://maneback.github.io/2021/crontab/","excerpt":"","text":"介绍 Linux 定时任务命令 crontab 的使用 linux crontab linux crontab 是用来定期执行程序的命令。系统会默认启动此任务调度命令。 crond命令会每分钟定期检查是否有需要执行的工作，如果有的话，便执行该工作。 1.语法 1crontab [-u user] file 或者 1crontab [-u user] &#123;-e | -l | -r&#125; 说明： -e 执行文字编辑器设定日程表 -r删除目前的日程表 -l列出目前的日程表 2. 时间格式 1f1 f2 f3 f4 f5 program 说明： f1表示分钟，f2表示小时，f3表示一个月份中的第几天，f4表示月份，f5表示一个星期中的星期几。 某一项为*表示每分钟或每小时等都要执行程序 某一项为a-b时表示在a-b这段时间执行。 某一项为*/n时表示每隔n个单位执行。 某一项为a,b,c时表示取值为a，b，c时执行。 3. 实例 说一千道一万都不如来几个例子来得实在。 每月每天每小时的第0分钟0 * * * * ls 在12月份，每天早上6点到12点，每隔3小时，每小时第10分钟执行10 6-12/3 * 12 * ls 每周一到周五下午5:00执行0 17 * * 1-5 ls 每月每天每偶数小时的20分执行20 0-23/2 * * * ls 这样，就可以把需要定期执行的操作写成一个脚本，然后交给crontab来执行了，这样真的方便。真的是，懒惰是第一生产力。我才发明这个的人肯定是一个很懒的人。让电脑帮助人来定期执行一些任务，不会忘记，不会出错，严格执行。这不正是机器比人优越的地方吗。","categories":[{"name":"技术","slug":"技术","permalink":"http://maneback.github.io/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://maneback.github.io/tags/Linux/"}]},{"title":"Leetcode -- 情侣牵手","slug":"couple-holding","date":"2021-02-24T02:51:51.000Z","updated":"2021-03-17T11:03:01.095Z","comments":true,"path":"2021/couple-holding/","link":"","permalink":"http://maneback.github.io/2021/couple-holding/","excerpt":"题目链接 Leetcode-765","text":"题目链接 Leetcode-765 image-20210224105405609 解题思路 对于一堆坐错位置的情侣的集合，只要按照首位相连环路交换位置即可，此种交换位置的方法一定是最少的，次数为情侣数量-1。 因此下一步的目标即寻找互相独立的情侣的集合，以及每个集合的情侣数量。 可以用并查集的方法来解决。编号为n, n+1 的两个人组成情侣编号为 n/2，以此编号来作为节点执行并查集算法 然后利用 map 记录每个并查集集合的大小 \\(size_i\\)，再返回 \\(\\sum{size_i-1}\\) image-20210224105550507 代码示例 1234567891011121314151617181920212223242526def minSwapCouple(row): n = len(couple)//2 father = [i for _ in range(n)] def find(x): if father[x] ==x: return x f = find(father[x]) father[x] = f return f def union(x, y): fx = find(x) fy = find(y) father[fx] = fy for i in range(n): a, b = row[2*n]//2, row[2*n+1]//2 union(a, b) dit = collections.defaultdict(int) for i in range(n): f = find(i) dit[f]+=1 ret = 0 for v in dit.values(): ret+=(v-1) return ret","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"并查集","slug":"并查集","permalink":"http://maneback.github.io/tags/并查集/"}]},{"title":"单调栈基础","slug":"monotonic-stack","date":"2021-02-24T02:46:14.000Z","updated":"2021-08-14T03:25:34.523Z","comments":true,"path":"2021/monotonic-stack/","link":"","permalink":"http://maneback.github.io/2021/monotonic-stack/","excerpt":"","text":"与单调队列类似，对于单调栈来讲，我们不仅要满足栈的后入先出顺序，还要满足栈内元素的单调性，来存储当前栈内元素的对应最大值或最小值。 每次入栈时，先将栈顶所有小于当前值的元素移出，直到当前栈顶元素大于当前值，或者栈为空 例题： 每日温度 image-20210814111129834 代码 123456789101112class Solution: def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]: length = len(temperatures) ans = [0] * length stack = [] for i in range(length): temperature = temperatures[i] while stack and temperature &gt; temperatures[stack[-1]]: prev_index = stack.pop() ans[prev_index] = i - prev_index stack.append(i) return ans","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://maneback.github.io/tags/单调栈/"}]},{"title":"单调队列基础","slug":"monotonic-queue","date":"2021-02-24T02:30:35.000Z","updated":"2021-03-17T11:03:01.096Z","comments":true,"path":"2021/monotonic-queue/","link":"","permalink":"http://maneback.github.io/2021/monotonic-queue/","excerpt":"","text":"单调队列是一个特殊的队列，除满足队列先进先出的特点外，队列内的元素根据需要，还满足单调递增或单调递减。 以单调递增队列为例：当我们想队尾添加元素x时，为了保持单调性，要把当前队尾所有小于x 的元素从队列中移出，直到队列为空，或是找到了比x 大的元素。这样，单调队列头部始终保存的是当前队列内的最大值。 当我们在队列内移除元素时，若当前移除的元素与单调队列头部元素相等，说明此时此最大值在队列内已不存在，此元素也应被移除以维护队列内的最大值。 例题 剑指offer - 59-II 代码示例 在这里，我们用一个数组（双向队列）self.que 保存所有的队列元素，self.max_ 保存遇到的最大值。 123456789101112131415161718192021222324252627class MaxQueue: def __init__(self): self.que = collections.deque() self.max_= collections.deque() def max_value(self) -&gt; int: if not self.max_: return -1 return self.max_[0] def push_back(self, value: int) -&gt; None: self.que.append(value) while self.max_ and self.max_[-1]&lt;value: self.max_.pop() self.max_.append(value) def pop_front(self) -&gt; int: if not self.que: return -1 n = self.que[0] if self.max_[0] == self.que[0]: self.max_.popleft() self.que.popleft() return n","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"单调队列","slug":"单调队列","permalink":"http://maneback.github.io/tags/单调队列/"}]},{"title":"Leetcode - 区间合并","slug":"merge-intervals","date":"2021-02-24T02:06:25.000Z","updated":"2021-03-17T11:03:01.096Z","comments":true,"path":"2021/merge-intervals/","link":"","permalink":"http://maneback.github.io/2021/merge-intervals/","excerpt":"题目链接： Leetcode-56","text":"题目链接： Leetcode-56 题目描述 思路 如果我们按照区间起始位置将所有区间排序，那么可合并的区间在排序后的数组中是连续的。如下图：相同颜色的区间可以被合并。 这样的话只一次遍历区间，并判断每个区间能不能与前一个区间合并。 判断一个区间能不能与前面的区间合并：只需要比较当前区间的起始与前一个区间（可能是已经合并过的区间）的结束位置的大小。 若当前区间在前一个区间结束前开始，则可以合并。 代码示例 12345678910111213def merge(intervals): intervals.sort(key=lambda x: x[0]) merged = [] for inter in intervals: # cannot be merged if not merged or inter[0]&gt;merged[-1][1]: # 此区间成为一个新的区间 merged.append(inter) else: # 可以合并，取两个区间结束点较大的一个 merged[-1][1] = max(merged[-1][1], inter[1]) return merged","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"}]},{"title":"Leetcode -- unique binary search trees II","slug":"longest-turbulent-subarray","date":"2021-02-09T03:02:50.000Z","updated":"2021-03-17T11:03:01.095Z","comments":true,"path":"2021/longest-turbulent-subarray/","link":"","permalink":"http://maneback.github.io/2021/longest-turbulent-subarray/","excerpt":"题目链接 ： Leetcode-978","text":"题目链接 ： Leetcode-978 题目描述 解题思路 最长湍流子数组，形象地描述就是数组中的一个子数组，连续数字大小交替变化，我们把这种交替变化用 上升 下降 表示，如果arr[-1]&lt;arr[-2] 则称下降序列，如果 arr[-1]&gt;arr[-2] 则称上升序列，即用最后一个变化方向代表整个序列的变化方向。 考虑动态规划的算法，找到如何描述状态以及状态转移方程。用 dp[i][0] 表示以 num[i] 结尾的上升序列的长度；用dp[i][1] 表示以num[i] 结尾的下降序列的长度。考虑到上升序列去掉最后一个数字之后成为下降序列，下降序列去掉最后一个数字之后成为上升序列。 然后我们考虑当前状态 dp[i][0], dp[i][1] 与下一个数组num[i+1] 之间的大小关系： 如果 num[i+1]&gt;num[i] 则可以把num[i+1]添加到下降序列最后， 成为上升序列；而下降序列长度为1（因为连续两个下降方向）。 如果 num[i+1]&lt;num[i] 则可以把num[i+1]添加到上升序列最后， 成为下降序列；而上升序列长度为1（因为连续两个上升方向）。 如果num[i+1]=num[i] 则上升序列和下降序列的长度均变为 1。 然后从两个数组中找到最长的那个子数组。 有了状态表示和状态转移方程，就可以写代码解题了。 示例代码 123456789101112131415161718192021class Solution: def maxTurbulenceSize(self, arr: List[int]) -&gt; int: ret = 0 n = len(arr) dp = [[0, 0] for _ in range(n)] dp[0][0], dp[0][1] = 1, 1 for i in range(1, n): if (arr[i]&lt;arr[i-1]): dp[i][0] = dp[i-1][1]+1 dp[i][1] = 1 elif (arr[i]&gt;arr[i-1]): dp[i][1] = dp[i-1][0]+1 dp[i][0] = 1 else: dp[i][0] = 1 dp[i][1] = 1 for i in range(n): ret = max(ret, dp[i][0]) ret = max(ret, dp[i][1]) return ret","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://maneback.github.io/tags/动态规划/"}]},{"title":"VScode 快捷键","slug":"vscodeshortcut","date":"2021-01-17T13:15:35.000Z","updated":"2021-01-17T13:18:53.583Z","comments":true,"path":"2021/vscodeshortcut/","link":"","permalink":"http://maneback.github.io/2021/vscodeshortcut/","excerpt":"","text":"多行编辑 鼠标+ Alt+Shift 按键选择，此方式只能选择连续竖列的对应位置不可随意插入光标位置，且不可间隔列 Shift+Ctrl 数列选择, 可以在多个地方插入光标。","categories":[{"name":"技术","slug":"技术","permalink":"http://maneback.github.io/categories/技术/"}],"tags":[{"name":"VScode","slug":"VScode","permalink":"http://maneback.github.io/tags/VScode/"}]},{"title":"Hexo 必要的插件","slug":"installed-plugin","date":"2021-01-05T09:53:18.000Z","updated":"2021-01-18T11:54:00.077Z","comments":true,"path":"2021/installed-plugin/","link":"","permalink":"http://maneback.github.io/2021/installed-plugin/","excerpt":"","text":"基础环境及必要插件 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --save ##wentinpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --save ##npm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 在hexo 博客中插入图片。 先安装插件 hexo-asset-image 12npm install -g hexo-cli --savenpm install https://github.com/CodeFalling/hexo-asset-image --save 第一种最简单的方法是使用图床，但是之前折腾过一段时间使用 PicGO +github 图床，但是稳定，后放弃。改用 hexo 自带的资源文件夹。 第二种方法是启用 assert 资源文件夹，但是这个东西很不智能。当你在 markdown 文档引用图片（不管是相对路径还是绝对路径）都能在文档中显示，但是渲染成 HTML 文件时，就会路径出错了。要用这个新的插件 hexo-asset-image 。 在 hexo 博客中正常显示 latex 公式 hexo 竟然对 latex 公式的支持这么不智能。唉，绝了。 更换 renderer。 12npm uninstall hexo-renderer-markednpm install hexo-renderer-pandoc 安装完 hexo-render-pandoc ，它在运行 hexo s 命令时会报错： 1[ERROR][hexo-renderer-pandoc] pandoc exited with code 9: pandoc: Unknown extension: smart 这时需要把 node_modules\\hexo-renderer-pandoc\\index.js 文件中的这个东西 1var args = [ '-f', 'markdown-smart'+extensions, '-t', 'html-smart', math] 改成： 1var args = [ '-f', 'markdown'+extensions, '-t', 'html', math] 参考来源 hexo-renderer-pandoc issues36","categories":[{"name":"Blog","slug":"Blog","permalink":"http://maneback.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://maneback.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://maneback.github.io/tags/hexo/"}]},{"title":"Leetcode -- unique binary search trees II","slug":"unique-binary-search-trees-ii","date":"2020-06-16T03:39:50.000Z","updated":"2021-03-17T11:03:01.098Z","comments":true,"path":"2020/unique-binary-search-trees-ii/","link":"","permalink":"http://maneback.github.io/2020/unique-binary-search-trees-ii/","excerpt":"","text":"题目描述 给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 0&lt;=n&lt;=8 解题思路 对于一个二叉搜索树中的任一个节点来讲，其左子树的所有节点的值都小于该节点，其右子树的所有节点的值都大于该节点。 对于一个递归的问题，我们只考虑每一步应该做什么，顺序是什么，应该返回什么。 在每一步中，我们只考虑构建一棵子树，然后把子树返回给上一节点。 假设某一步中我们以一个区间[start, end] 来构造二叉搜索树，那么对于任意的 i, start&lt;=i&lt;=end， 可以以i为根节点来开始构造二叉搜索树，它的左子树则是以区间[start, i-1]构造的二叉搜索树，它的右子树是以区间[i+1, end] 构造的二叉搜索树，就这样递归地构造即可： 12345def dfs(start, end): for i in range(start, end): node = Treenode(start, i) lc = dfs(start, i-1) rc = dfs(i+1, end) 但是对于区间 [start, i-1] 和[i+1, end]构造的左右子树，可能不止为1， 然而其可以任意地组合，这样，我们用一个数组保存以[start， end]构造的所有子树，然后再将其返回： 1234567891011121314def dfs(start, end): if start&gt;end: return [None, ] res = [] for i in range(start, end): node = Treenode(start, i) lc = dfs(start, i-1) rc = dfs(i+1, end) for l in lc: for r in rc: node.left = l node.right = r res.append(node) return res 这样，我们就完成了代码的书写。 解题代码 123456789101112131415161718def buildTree(n): if n==0: return [] def dfs(start, end): if start&gt;end: return [None, ] res = [] for i in range(start, end): node = Treenode(start, i) lc = dfs(start, i-1) rc = dfs(i+1, end) for l in lc: for r in rc: node.left = l node.right = r res.append(node) return res return dfs(1, n)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"tree","slug":"tree","permalink":"http://maneback.github.io/tags/tree/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://maneback.github.io/tags/dynamic-programming/"}]},{"title":"Leetcode -- binary tree maximum path sum","slug":"binary-tree-maximum-path-sum","date":"2020-06-15T13:04:57.000Z","updated":"2021-03-17T11:03:01.093Z","comments":true,"path":"2020/binary-tree-maximum-path-sum/","link":"","permalink":"http://maneback.github.io/2020/binary-tree-maximum-path-sum/","excerpt":"","text":"题目链接： https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ 题目描述 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 解题思路 首先，这是一道非常标准的树形结构搜索的问题，对于树结构相关的问题，都可以用深度优先搜索或广度优先搜索的方法来解决，此题也不例外。只要考虑好在每个节点上做什么操作、在 child 节点上做什么操作，以及是先序、中序还是后续就行了。 关于这个题，很明显是后序。因为你需要找到当前 node 节点的子节点的路径长，才能确定通过当前 node 节点的路径长。 1234567def dfs(node): if not node: # pass dfs(node.left) dfs(node.right) # do sth to node return #path. 对于这个问题，其路径可以不经过 root 节点，那么对于最长路径中的任意一个节点 n，可选的操作有四种：①从 n 的父节点连接 n 到 n 的左子树；②从 n 的父节点连接 n 到 n 的右子树；③从 n 的左子树连接到 n 连接到 n 的右子树；④最大路径从 n 点结束，包括最上的点和最下的点两种情况。 我们用全局变量 path 表示当前的全局最优解。 对于前两种情况，到目前为止我们只求得了或者说是遍历过了最长路径的部分，因此这一部分要把经过该节点的子路径的长度返回给父节点继续计算。其中除了情况一和二之外，还有一种就是情况四中的最大路径最下从当前节点结束：即它的所有子树的最大路径都是负值。因此我们要针对这三种情况计算局部最优值。 对于情况三，在得到了左右子树的最大路径值后，都能直接计算出该情况的解，因此此时直接将其与全局最优解比较。此外还可能其其中一个子树的最大子路径值为负数，且父节点的最大子路径值也为负数，即最大路径最上从当前节点结束，都要和全局最优解比较。 具体代码如下： 解题代码 123456789101112131415class Solution: def maxPathSum(self, root): self.path = -1000000 def dfs(node): if not node: return dl = dfs(node.left) dr = node.right # local max local_max = max(node.val, node.val+dl, node.val+dr) self.path = max(node.val+dl+dr, local_max, self.path) return local_max dfs(root) return self.path","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"tree","slug":"tree","permalink":"http://maneback.github.io/tags/tree/"},{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://maneback.github.io/tags/BFS-DFS/"}]},{"title":"Leetcode -- subsets","slug":"subset","date":"2020-06-09T00:38:42.000Z","updated":"2021-01-04T13:36:59.329Z","comments":true,"path":"2020/subset/","link":"","permalink":"http://maneback.github.io/2020/subset/","excerpt":"原题链接：https://leetcode-cn.com/problems/subsets/","text":"原题链接：https://leetcode-cn.com/problems/subsets/ 题目描述： 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例： 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解法： 本题是非常经典的回溯法解决的题目。 12345678910111213def subset(nums): def backtrack(first=0, curr=[]): if len(curr)==k: output.append(curr) for i in range(first, n): curr.append(nums[i]) backtrack(i+1, curr) curr.pop() output = [] n = len(nums) for k in range(n+1): backtrack() return output","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"backtrack","slug":"backtrack","permalink":"http://maneback.github.io/tags/backtrack/"}]},{"title":"论文解读|点云深度学习方法--PointNet","slug":"pointnet","date":"2020-05-19T10:49:03.000Z","updated":"2021-03-17T11:03:01.098Z","comments":true,"path":"2020/pointnet/","link":"","permalink":"http://maneback.github.io/2020/pointnet/","excerpt":"PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation [CVPR 2017]","text":"PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation [CVPR 2017] 论文解读系列第①篇 今天带来的是 CVPR 2017 的一篇文章 PointNet。这片文章可以说是深度学习直接处理原始点云数据 (raw point cloud) 的开篇之作。目前在 Google Scholar 上面查到的引用量已经超过了 2000 次。 一、背景 先来看一看点云与深度学习结合的问题。近年来，深度学习方法取得了广泛的关注和应用，在图像、语音、文字等领域都取得了很好的应用成果。而点云是一种新型的 3D 空间的数据表示格式。它一般以一个四维向量 (x, y, z, i) 表示一个点。其中， (x, y, z) 是空间中的三维坐标，而 i 表示的是该点的反射强度。 当 2D 图像输入到深度学习的网络中时，它是规则的数据，每个像素值的位置都可以以一个二维坐标来表示，且它在空间上是连续的表示，即相邻像素就是在图像中相邻的。而点云的表示方法有所不同。它是无序且非结构化的表示，只是一个由点的坐标构成的集合，而相邻点之间并没有这种空间的相邻关系。这就会造成如下面这样的结果： 如上图：一副点云由若干的点构成，但是同一副点云图像其中点的排列顺序可能会不同，当以两者分别输入卷积网络中时，无论对于分类任务还是对于目标检测任务来讲，会带来不同的结果。然而实际上二者表示的是同一个物体或内容。这显然不是我们想要的结果。 卷积网络需要结构化的输入，而点云的输入是非结构化的，这样就会导致卷积网络并不适用于点云数据，基于此，人们想出了两种预处理方式，来使点云成为结构化的输入。 第一种方法是 multi-view 投影的方法。即以点云在多个视角的投影作为输入，用原来的 2D 图像的卷积网络来处理。 第二种方法是 voxelization 的方法，即把空间划分成离散的体素 (3D voxel)， 然后每个点按照坐标位置决定落到那个体素单元中。这样，就可以把原来无序的点云输入规则化。 但是这种预处理的方式肯定会造成一定的信息损失。 基于此问题，本文的作者就提出了 PointNet 神经网络来处理点云数据。设计了一种直接处理点云来提取特征的新型网络，很好地考虑了对于输入点排列顺序的不变性。以及网络对于输入点集小的扰动和数据破坏（丢失）也具有很好的鲁棒性。 二、网络结构 首先来总结一下点云数据的三个特征以及由此带来的问题： Unordered ：点云在采集和存储是都是无序的，因此要求网络必须对一副点云所有可能的输入保持结果不变。 Interaction among points ：点云中每个点都与其周围的若干点表示了一定的空间结果，但是在存储来讲，并不能表示出这种结构。 Invariance under transformation ：点云表示了一定的三维结构，这要求网络的处理结果对于点云的旋转、转换等必须保持结果不变性。 针对以上的问题，本文采取的方法是：在初始阶段，对点云中每个点都单独进行相同的处理，然后再应用一个对称函数(MaxPooling)来解决点集的无序性问题。 PointNet 的网络结构如下： 网络的输入即为一个 nx3 的向量，表示 n 个点的三维坐标。可以用于分类任务与分割任务。对于分类任务，输出结果为 k 个分类类别的得分；对于分割任务，输出结果为 n 个点逐个的所属分割部分的得分。 最重要的三个部分已在图中圈出： 两个小型的 T-Net 网络用于学习一个坐标变换矩阵，并应于该坐标变换矩阵增强输入数据，使得网络对于输入的旋转等操作具有一定的不变性。 MaxPooling 操作，以对称函数解决点云输入的不变性。 Aggregation 操作，将全局特征拼接到每个点的特征后面，用于分类任务。 首先，对于 nx3 的输入数据，先经过一个两层的 MLP ，提取得到每个点的 64 维特征，此外输入数据与特征数据分别经过 input transform 和 feature transform 操作进行增强。这样我们就得到了一个 nx64 的特征，每个点的特征以一个 64 维的向量表示。在此之后，再经过一个三层的 MLP 将 64 维的特征升到 1024 维。 然后经过 maxpooling 操作提取得到一个全局的 1024 维特征。然后输入到分类网络中用以分类。 对于如何解决无序性问题，使得模型能够不受输入的排列顺序的影响。那么作者提出了三种可能的解决方法：(1)是将输入按一个规范顺序排序。这个很显然是不可行的。(2)是将输入作为一个连续的序列来训练一个RNN，并通过所有可能的排序来增加训练数据。一方面，有研究表明在RNN中顺序确实是有影响的，不能被忽略；另一方面，当point clouds 数据集很大的时候，对所有的N!个排列都处理一次也是不现实的。(3)是采用对称函数。 下面来介绍一下对称函数。所谓对称函数，通俗来讲就是参数的输入顺序不会影响函数的结果。如加法、乘法等，都是非常常见且明显的对称函数，可以任意改变参数的顺序。对于 maxpooling 操作来讲，它当然也是对称函数，无论输入的 n 个点的排列顺序如何，在对 nx1024 维的特征应用 maxpooling 操作时，得到的结果永远都是一样的。 这样借用 maxpooling 函数的对称性，我们就可以无视输入的无序性。先对每个点单独地进行相同的操作，然后再应用对称函数提取全局特征就好了。形式上来讲，可以表示为： \\[ f(x_1, x_2,...x_n)=g(h(x_1), h(x_2),...h(x_n)) \\] 函数 \\(f\\) 是作用在点集上的函数，函数 \\(h\\) 是作用在单个点上的函数，而函数 \\(g\\) 是一个作用在经过处理的点 \\(h(x)\\) 上的对称函数，这样我们就可以用函数 \\(g\\) 和 \\(h\\) 来得到关于点集的操作 \\(f\\) 。而相关的理论证明，将会在第四部分给出。 对于分割任务来讲，既要考虑全局的特征，又要考虑全局特征，所以做法便是将 1024 维的全局特征聚合到每一个 64 为的点特征之后，这样得到的特征就既包含了全局的信息，也包含了点的局部信息了，从而用于分割任务。 三、结果 在论文中，作者给出了 PointNet 网络在分类、部分分割与场景语义分割三项任务上的结果。 3.1 分类 在 ModelNet40 数据集上分类的准确率如下： 在这项任务中，与 multi-view 与 voxel 的方法进行了对比。 3.2 部分分割 所谓部分分割，就是对每个点生成一个类别标记： 在 ModelNet40 部分分割结果如下，评价指标为 IoU: 3.3 场景语义分割 场景语义分割任务与部分分割任务类似，也是为每个点分配一个类别标记，判断每个点属于哪个物体。数据集为 Stanford 3D semantic parsing data Set. 在这一项任务中，输入不在是三维向量，而是九维，包括 (三维坐标，RGB值，归一化后的三维坐标)。得到的结果如下： 四、理论分析 在这一章节中，给出一些理论上的分析。 4.1 近似逼近性 首先，给出为什么可以用 \\(g\\) 和 \\(h\\) 来近似逼近函数 \\(f\\)。 对于定义在集合上的连续函数 \\(f\\) , 有如下的性质： \\[ \\begin{align} &amp;\\chi = \\{S:S\\subseteq[0,1]^m and\\; |S|=n \\}\\\\ &amp;f:\\chi \\to \\mathbb{R},\\mbox{ 是一个连续的集合函数。}\\\\ &amp;\\mbox{Hausdorff distance } d_H(.,.) \\mbox{ 定义元素之间的距离。}\\\\ &amp; \\forall\\, \\theta&gt;0, \\exist \\,\\delta&gt;0, for\\;any\\;S_1,S_2\\in\\chi:\\\\ &amp;if\\;\\;d_H(S_1,S_2)&lt;\\delta, then\\;|f(S_1)-f(S_2)|&lt;\\theta \\end{align} \\] 由于连续函数 \\(f\\) 有了这个性质，那么我们就可以定义一个对称函数 \\(g\\) ，是一个\\(\\gamma\\) 和 max的复合函数。使得函数 \\(g\\) 作用于 \\(h(x)\\) 之上的函数值与 \\(f(S)\\) 之间的数值足够小。 换句话说，我们可以用这样一个作用于每一元素的函数 \\(h\\) 以及一个对称函数 \\(MAX\\) 来近似集合函数 \\(f\\) 。 \\[ \\begin{align}&amp;\\forall \\theta&gt;0,\\;\\exist \\mbox{ 一个连续函数 }\\;h\\\\&amp;\\mbox{ 和一个对称函数 }\\;g(x_1,...,x_n)=\\gamma\\circ MAX:\\\\&amp;\\mbox{such that for any }\\; S\\in \\chi :\\\\&amp;\\bigg|f(S)-\\gamma\\bigg(MAX_{x_i\\in S}\\{h(x_i)\\}\\bigg)\\bigg|&lt;\\theta\\\\&amp; (x_1,...,x_n \\mbox{ 是 }S\\mbox{ 中的元素。})\\end{align} \\] 4.2 稳定性分析 第二是全局特征维度的维度K对结果的影响，以及整个网络的鲁棒性分析。 首先令 \\(u\\) 是由一个点集经过 \\(h\\) 计算每个点，再进行最大池化，得到一个 k 维向量的函数，那么 \\(f\\) 可以表示为 \\(\\gamma\\) 和 \\(u\\) 的复合函数。 那么，对于任意一个点集 S，都存在另外两个点集 C 和 N ，使得在任意一个不小于 C 且不大于N 的点集 T，\\(f(S) = f(T)\\)。即对于一个集合 \\(S\\), \\(f(S)\\) 的函数值，只受到这个集合 \\(C\\) 的影响，更多的点对于函数的结果并不起到作用。 b)说明C中点的个数不大于K。这个K就是特征的维度。因为我们在用 \\(u\\) 做最大池化操作时，对于 K 维中的每一个，只会选择来自一个点的特征作为该位的最大值，也就是说 MAXPOOLING 操作只会选择 K 个起作用的点。 因此，maxpooling 时候的特征维度K会影响C，进而影响分类的准确率。 $$ \\[\\begin{align} &amp; 令\\; u: \\chi\\to\\mathbb{R}^K\\\\ &amp;u=MAX_{X_i\\in S}\\{h(x_i)\\}\\;\\;即u由一组点生成一个K维的向量。\\\\ &amp;f=\\gamma\\circ u,则有：\\\\ &amp;(a)\\;\\forall S,\\; \\exist \\mathcal{C}_s \\,\\mathcal{N}_S\\subseteq\\chi,\\, f(S)=f(T)\\;if\\;\\mathcal{C}_s\\subseteq T\\subseteq \\mathcal{N}_S\\\\ &amp;(b)\\; |\\mathcal{C}_S|\\leq K \\end{align}\\] $$ \\[ \\begin{align} &amp;(a)式说明\\;f(S)\\;的函数值由一组关键点\\mathcal{C}_S 决定\\\\ &amp;且添加的噪声点只要不超过\\mathcal{N}_S,对函数值不会产生影响。\\\\ &amp;(b)式说明关键点的个数 |\\mathcal{C}_S|存在上界,\\\\ &amp;不大于K，即最大池化时特征的维数。 \\end{align} \\] \\[ 称 \\mathcal{C}_S 为\\; critical\\; point\\; set,K\\;为\\;bottleneck\\; dimension \\] 上述证明说明了此网络对于输入中一些微小的扰动与离群点具有很好的鲁棒性，并不会很大程度上影响结果。 下面给出了一些点云输入的 $_S $ 和 \\(\\mathcal{C}_N\\) 集合可视化例子。可以看出经过这个网络提取出的 \\(\\mathcal{C}_S\\) 集合，大体上描绘了这个物体的大致轮廓。 下图是 maxpooling 的维度 K 对准确率的影响。横坐标是 K 设置的数值，纵坐标是分类的准确率。每条线是每个输入中点的数量。可以看到随着 K 的增加，准确率有所上升，但是当 K 到达 1000 左右时基本上就不再变了，所以本文中 K 的取值就是选择 1024 ，以达到效率与精确度的最好权衡。 4.3 设计分析 在之前，提到过有三种方法解决无序性问题：排序、RNN、对称函数，现在给出这三种设计方法的效果对比： 可以看到对称函数操作的准确性最高，而在所考虑的三种对称函数中，maxpooling 的准确性又是其中最高的。 此外，我们提到过 T-Net 对齐网络的作用，在这里给出它的实际效果，可以看出它可以在一定程度上提高分类的准确率。","categories":[{"name":"论文解读","slug":"论文解读","permalink":"http://maneback.github.io/categories/论文解读/"}],"tags":[{"name":"点云","slug":"点云","permalink":"http://maneback.github.io/tags/点云/"},{"name":"深度学习","slug":"深度学习","permalink":"http://maneback.github.io/tags/深度学习/"},{"name":"学习","slug":"学习","permalink":"http://maneback.github.io/tags/学习/"}]},{"title":"关于微信的一件小事","slug":"wechat-account","date":"2020-05-06T02:12:58.000Z","updated":"2021-03-17T11:03:01.099Z","comments":true,"path":"2020/wechat-account/","link":"","permalink":"http://maneback.github.io/2020/wechat-account/","excerpt":"","text":"首发于个人公众号不愿意透露姓名的松哥， 文章链接， 文章略有修改。 我开始飘了，都开始写公众号文章了，都开始思考微信公众号的产品逻辑了，都开始分析评论公众号的种种优缺点了。 零 最近，突然发现微信里面开始有了一些“小动作”。 比如文章底部开始有相关推荐，比如看一看里面开始带话题，比如信息流中开始有公众号推荐。 一 稍微思考一下微信的使用时间，基本上可以分为以下两部分：聊天刷朋友圈+公众号文章阅读。只要你的好友也还在用微信，你就不得不保证前者的使用时长。而后者呢，则是由公众号文章的质量决定的。 再看一看近来（其实也不太近了）微信其他的一些更新：公众号改为信息流的形式，增加浮窗的个数，越来越强化看一看的推荐，（还在测试中的？）付费阅读？以及上述的几个小细节。这些功能都是针对后者的优化，也就是为公众号服务的，而不是针对普通用户。 获取讯息是多数人的重要需求。如果公众号的这些创作者不再在微信中创作，就有可能去微博、去知乎、去B站等等，而普通用户这方面在微信花费的时间也会流失。 微信公众号只是平台，而不生产内容。给内容创作者以更好的体验和有效的激励（更多真实的关注和阅读量）、创造更好的生态与创作环境，留下好的创作者，留下好的内容，用户使用时长自然也会增长。而人的时间和精力也是有限的，在微信上“浪费”的时间更多了，留给其他应用的时间也就更少了。 二 微信公众号确实产生了许多高质量的文章，也有很多优质的账号。但是与其他的内容平台还是有许多的不足。比如公众号中禁止插入外部链接（真很难理解这么大的一个互联网公司的这种做法），公众号文章那（几乎等于）没有的分享功能，更不要说公众号这（近乎）残废的留言互动功能。 公众号系统是以账号为中心的，而之外的知乎和微博等，则更多的偏向以内容为中心，比如热榜、热搜的存在等等，这种形式的内容传播，是可以覆盖到其所有用户的。此外，在微博上，内容可以在用户之间任意地转发传播以及曝光；在知乎上，用户更关注的是问题与问题之下的回答与讨论，也就是内容本身，有时用户对于内容的产出者并不是关注太多。 而对于公众号来讲，其内容的传播链条很短，更何况也无法被常用的搜索引擎爬取（有几个人知道在哪里可以搜索公众号的文章呢？）。几乎没有办法借助微信官方的推荐等等，来增加自己的关注量。即使现在微信官方去出面，去强化看一看功能，增加优质内容的推荐曝光，但是这种也同样是基于微信好友关系，那么势必会影响其传播范围。与微博、知乎官方所使用的推荐算法的覆盖范围差远了。 因此在那之前，对于公众号自媒体来讲，增加关注量是一件很困难的事情，他们要在微博、知乎、博客等各种平台留下自己的账号、利用自己在其他地方的影响力来给自己增加关注。用户也只能在其他应用、或是好友分享的某一篇文章、或是公众号主们之间的互推来关注到一个高价值的公众号。 但是也不得不承认，优质公众号的用户粘性极高，你看到的内容完全是你自己的选择。公众号有更多“个人品牌”的属性在里面。对一个公众号产生了认同感，才会去持续关注，追热点蹭热度很难带来持久的关注增长。也正是因为公众号系统以账号为中心，其也特别适合那种专一于特定主题，目标群体明确的账号。点点关注不迷路。 最后 在知乎上，关于微信一些设计与功能的提问与讨论也有很多。但是该用微信的人还是在用，毕竟在这个领域完全没有拿得出手的竞争者。微信的用户数量实在是太庞大了，用户实际的使用场景实在是太多了，它在功能上有很多被人们吐槽的地方。 但是你要明白：微信它本身只是一个即时通讯类的软件，而不是一个什么都包了的软件。你所觉得的一些功能残缺，可能这并不是它当初所设想的使用场景。微信的日活超过十亿，有人用它聊天，有人用它办公，有人用它卖货，也有人用它发广告等等等等。 只要你想明白了这件事情，你就会明白它为什么对某些用户需求无动于衷。同时要考虑它做出某些改进的原因。 另外最近在微博上面也看到了这样一段话： 虽然主语讲的是微博，但是对微信来说也是同理。","categories":[{"name":"公众号文章","slug":"公众号文章","permalink":"http://maneback.github.io/categories/公众号文章/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://maneback.github.io/tags/微信公众号/"}]},{"title":"要买要看的书","slug":"books","date":"2020-03-16T07:15:39.000Z","updated":"2021-01-04T13:36:59.305Z","comments":true,"path":"2020/books/","link":"","permalink":"http://maneback.github.io/2020/books/","excerpt":"","text":"心理、人生、认知、理财 人格障碍的认知行为疗法 谁动了我的奶酪 思考快与慢 就业 利息与货币通论 被讨厌的勇气 程序员必备 C++ Primer Plus 设计模式 编程珠玑 代码整洁之道 数据科学实战 Python3 反爬虫原理与绕过实战","categories":[],"tags":[]},{"title":"Music","slug":"music-test","date":"2020-03-03T13:22:16.000Z","updated":"2021-01-04T13:36:59.319Z","comments":true,"path":"2020/music-test/","link":"","permalink":"http://maneback.github.io/2020/music-test/","excerpt":"","text":"终于找到了在博客中插入音乐的方法了。之前在网易云生成外链的方法不知道怎么就失效了呢。 新的方法使用了 hexo-tag-aplayer 和 MetingJS 。 先来一首最近非常非常喜欢的一个翻唱歌手唱的一首歌： 1. 安装 1npm install --save hexo-tag-aplayer 2.使用 aplayer可以引用本地的音乐文件，但是有时候显然会比较麻烦 1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125; title : 曲目标题 author: 曲目作者 url: 音乐文件 URL 地址 picture_url: (可选) 音乐对应的图片地址 narrow: （可选）播放器袖珍风格 autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能 width:xxx: (可选) 播放器宽度 (默认: 100%) lrc:xxx: （可选）歌词文件 URL 地址 需要开启hexo的文章资源文件夹功能，将图片、音乐文件、歌词文件都放在与文章相对应的资源文件夹中，然后直接引用 3. MetingJS 现在hexo的配置文件_config.yml中设置： 12aplayer: meting:true 接着就可以用\\ 在文章中使用播放器了。 12&lt;!-- 简单示例 (id, server, type) --&gt;&#123;% meting \"60198\" \"netease\" \"playlist\" \"mini:true\" %&#125; 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置","categories":[{"name":"Amazing","slug":"Amazing","permalink":"http://maneback.github.io/categories/Amazing/"}],"tags":[]},{"title":"latex 速查表","slug":"latex","date":"2020-02-18T09:15:00.000Z","updated":"2021-01-04T13:36:59.318Z","comments":true,"path":"2020/latex/","link":"","permalink":"http://maneback.github.io/2020/latex/","excerpt":"","text":"一、 集合操作 \\mid \\(A \\mid B\\) 属于\\in \\(a_i\\in A\\) 不属于\\not\\in \\(a_i\\not\\in A\\) 包含于\\subset \\(A \\subset B\\) 子集 \\subseteq \\(A \\subseteq B\\) 真包含于\\subsetneqq \\(A \\subsetneqq B\\) 包含\\supset \\(A \\supset B\\) 真包含 \\supsetneqq \\(A \\supsetneqq B\\) 交集\\cap \\(A \\cap B\\) 并集 \\cup \\(A \\cup B\\) 实数集合 \\mathbb{R} \\(\\mathbb{R}\\) 空集\\emptyset \\(\\emptyset\\) 二、数学运算 分数 \\frac{}{} \\(\\frac{a}{b}\\) 花体字母\\mathbb{} \\(\\mathbb{ABC}\\) \\nabla \\(\\nabla\\) \\partial \\(\\partial x\\) 不等号\\neq \\(x \\neq 1\\) 角度`\\sin\\!\\frac{\\pi}{3}=\\sin60^\\{operatorname{\\omicron}} \\(\\sin\\!\\frac{\\pi}{3}=\\sin60^{\\operatorname{\\omicron}}\\) 三、逻辑 逻辑与 land \\(A \\land B\\) 逻辑或 lor \\(A \\lor B\\) 逻辑非 \\lnot \\(\\lnot B\\) \\to \\(p\\to q\\) 三、上标、下标及积分等 前置上下标{}_1^2X_3^4 \\({}_1^2X_3^4\\) 向量 \\vec{x} \\(\\vec{x}\\) 无穷 \\infty \\(\\infty\\) 求和 \\sum_{k=1}^n x_k \\(\\sum_{k=1}^n x_k\\) 求积\\prod_{k=1}^n x_k \\(\\prod_{k=1}^n x_k\\) 极限 \\lim_{n \\to \\infty} x_n \\(\\lim_{n \\to \\infty} x_n\\) 积分 \\int_{-N}^{N} e^x \\(\\int_{-N}^{N} e^x\\) 双重积分 \\iint_{D}^{W}\\,dx\\,dy \\(\\iint_{D}^{W}xy\\,dxdy\\) 三重积分\\iiint_{E}^{V}\\,xyz\\,dxdydz \\(\\iiint_{E}^{V}\\,xyz\\,dxdydz\\) 曲线曲面积分\\oint_{C}x^3\\,dx+4y^2\\,dy \\(\\oint_{C}x^3\\,dx+4y^2\\,dy\\) 四、分数、矩阵和多行列式 分数\\frac{1}{2}=0.5 \\(\\frac{1}{2}=0.5\\) 小分数\\tfrac{1}{2}=0.5 \\(\\tfrac{1}{2}=0.5\\) 二项式系数\\dbinom{n}{r}=C_n^r \\(\\dbinom{n}{r}=C_n^r\\) 矩阵\\begin{matrix}x&amp;y \\\\ z&amp;v\\end{matrix} \\[\\begin{matrix}x&amp;y \\\\ z&amp;v\\end{matrix}\\] 矩阵\\begin{vmatrix}x&amp;y \\\\ z&amp;v\\end{vmatrix} \\(\\begin{vmatrix}x&amp;y \\\\ z&amp;v\\end{vmatrix}\\) 矩阵\\begin{Vmatrix}x&amp;y \\\\ z&amp;v\\end{Vmatrix} \\(\\begin{Vmatrix}x&amp;y \\\\ z&amp;v\\end{Vmatrix}\\) 矩阵 1234\\begin&#123;matrix&#125;x &amp; y \\\\z &amp; v\\end&#123;matrix&#125; \\[ \\begin{matrix} x &amp; y \\\\ z &amp; v \\end{matrix} \\] 12345\\begin&#123;bmatrix&#125;0 &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; \\cdots &amp; 0\\end&#123;bmatrix&#125; \\[ \\begin{bmatrix} 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\] 1234\\begin&#123;Bmatrix&#125;1 &amp; 2 \\\\3 &amp; 4\\end&#123;Bmatrix&#125; \\[ \\begin{Bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{Bmatrix} \\] 1234\\begin&#123;pmatrix&#125;a &amp; b \\\\c &amp; d\\end&#123;pmatrix&#125; \\[ \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\] 条件定义 12345f(n)=\\begin&#123;cases&#125;n/2, &amp; \\mbox&#123;if &#125;n \\mbox&#123; is even&#125; \\\\3n+1, &amp; \\mobx&#123;if &#125;n \\mobx&#123; is odd&#125;\\end&#123;cases&#125; \\[ f(n)= \\begin{cases} n/2, &amp; if\\; n\\;is\\; even \\\\ 3n+1, &amp; if\\; n\\; is\\; odd \\end{cases} \\] 1234\\begin&#123;align&#125;f(x)&amp;=(m+n)^2 \\\\&amp;=m^2 + 2mn + n^2\\\\\\end&#123;align&#125; \\[ \\begin{align} f(x)&amp;=(m+n)^2 \\\\ &amp;=m^2 + 2mn + n^2\\\\ \\end{align} \\] 12345\\begin&#123;alignat&#125;&#123;2&#125;f(x) &amp; = (m-n) ^ 2 \\\\f(x) &amp; = (-m+n) ^ 2 \\\\&amp; = m^2-2mn+n^2 \\\\\\end&#123;alignat&#125; \\[ \\begin{alignat}{2} f(x) &amp; = (m-n) ^ 2 \\\\ f(x) &amp; = (-m+n) ^ 2 \\\\ &amp; = m^2-2mn+n^2 \\\\ \\end{alignat} \\] 1234\\begin&#123;array&#125;&#123;lcl&#125;z &amp; = &amp; a\\\\f(x,y,z) &amp; = &amp; x+y+z\\end&#123;array&#125; \\[ \\begin{array}{lcl} z &amp; = &amp; a\\\\ f(x,y,z) &amp; = &amp; x+y+z \\end{array} \\] 12345\\begin&#123;cases&#125;3x + 5y + z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\end&#123;cases&#125; \\[ \\begin{cases} 3x + 5y + z \\\\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{cases} \\] 12345678 \\begin&#123;array&#125;&#123;|c|c||c|&#125; a &amp; b &amp; S \\\\\\hline0&amp;0&amp;1\\\\0&amp;1&amp;1\\\\1&amp;0&amp;1\\\\1&amp;1&amp;0\\\\\\end&#123;array&#125; \\[ \\begin{array}{|c|c|c|} a &amp; b &amp; S \\\\ \\hline 0ooo&amp;0&amp;1\\\\ 0&amp;1&amp;1\\\\ 1&amp;0&amp;1\\\\ 1&amp;1&amp;0\\\\ \\end{array} \\] 五、字体 希腊字母 大写 \\(\\Alpha\\) \\(\\Beta\\) \\(\\Gamma\\) \\(\\Delta\\) \\(\\Epsilon\\) \\(\\Zeta\\) \\(\\Eta\\) \\(\\Theta\\) \\(\\Iota\\) \\(\\Kappa\\) \\Nu \\(\\Lambda\\) \\(\\Mu\\) \\(\\Nu\\) \\(\\Xi\\) \\(\\Omicron\\) \\(\\Pi\\) \\(\\Rho\\) \\(\\Sigma\\) \\(\\Tau\\) \\(\\Upsilon\\) \\\\\\\\\\\\\\ \\(\\Phi\\) \\(\\Chi\\) \\(\\Psi\\) \\(\\Omega\\) 小写 \\(\\alpha\\) \\(\\beta\\) \\(\\gamma\\) \\(\\delta\\) \\(\\epsilon\\) \\(\\zeta\\) \\(\\eta\\) \\(\\theta\\) \\(\\iota\\) \\(\\kappa\\) \\(\\varkappa\\) \\(\\lambda\\) \\(\\mu\\) \\(\\nu\\) \\(\\xi\\) \\(\\omicron\\) \\(\\pi\\) \\(\\rho\\) \\(\\sigma\\) \\(\\tau\\) \\(\\upsilon\\) $$ \\(\\chi\\) \\(\\psi\\) \\(\\omega\\) \\(\\varepsilon\\) \\(\\vartheta\\) $ $ \\(\\varpi\\) \\(\\varrho\\) \\(\\varsigma\\) \\(\\varphi\\) 字体 粗体 1\\mathbb&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; \\[ \\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \\] 只有大写拉丁字母才能正常显示，使用小写字母或数字时会得到其他符号。 1\\boldsymbol&#123;\\Alpha \\alpha \\Beta \\beta&#125; \\[ \\boldsymbol{\\Alpha \\alpha \\Beta \\beta} \\] 粗体的希腊字母，大小写均可 1\\mathbf&#123;012,abc,ABC&#125; \\[ \\mathbf{012,abc,ABC} \\] 拉丁字母和数字的粗体，不能用于希腊字母。 哥特体 123\\mathfrak&#123;abcdefghijklmnopqrstuvwxyz&#125;\\mathfrak&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;\\marhfrak&#123;1234567890&#125; \\[ \\mathfrak{abcdefghijklmnopqrstuvwxyz}\\\\ \\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\\\ \\mathfrak{1234567890} \\] 手写体 1\\mathcal&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; \\[ \\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \\] 注意：手写字体仅对大写拉丁字母有效。 六、括号 其他 加帽子^ \\hat 或者\\widehat \\(\\hat A\\) 上划线 \\overline $ A$ 下划线\\undweline \\(\\underline{A}\\) 加波浪线 \\widetilde \\(\\widetilde A\\) 加点 \\dot{} \\(\\dot A\\) 加两个点 \\ddot \\(\\ddot A\\) 加箭头 \\vec \\(\\vec A\\)","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://maneback.github.io/tags/latex/"}]},{"title":"python内置函数","slug":"python-functions","date":"2020-02-10T11:20:25.000Z","updated":"2021-01-04T13:36:59.327Z","comments":true,"path":"2020/python-functions/","link":"","permalink":"http://maneback.github.io/2020/python-functions/","excerpt":"介绍一些python内置函数的用法 emumerate / join / zip","text":"介绍一些python内置函数的用法 emumerate / join / zip 1. emumerate() 对于一个可迭代/可遍历的对象（如列表、字符串等），可以使用enumerate()同时获得索引值和数值，将得到以下object 1(0, lis[0]), (1, lis[1]), (2, lis[2]) 对于一个列表，既想遍历索引，又想遍历元素时，我们可以这样写： 12345678lis = ['python', 'java', 'cpp', 'html']for index, item in enumerate(lis): print(index, item)####&gt;&gt;&gt;0 python1 java2 cpp3 html enumerrate 还可以接收第二个参数，作为索引的起始值。 12345678lis = ['python', 'java', 'cpp', 'html']for index, item in enumerate(lis, 1): print(index, item)####1 python2 java3 cpp4 html 注意：第二个参数不是修改遍历的起始位置，仍然是遍历所有元素，它只会修改索引的值。 2. join python 的join() 函数可用于将序列中的每个元素，以指定的分隔符连接成一个新的字符串。(很是方便。) PS: 连接符可以是字符串，而不需要是单个字符。 123456sql = ['a', 'b', 'c', 'd']' '.join(sql)'-'.join(sql)','.join(sql)'.'.join(sql) 3. zip zip()函数以可迭代的对象作为参数，将对象中对应位置的元素打包成为一个个元组，再返回有这些元组组成的一个列表。 若各个迭代器的元素的个数不相同，则返回的列表长度与最短的对象相同。 1234567a = [1,2,3]b = [4,5,6]c = [7,8,9]zipped = zip(a, b)# ====&gt;[(1, 4), (2, 5), (3, 6)] 4. 反向迭代 reverse 123l = [1,2,3,4,5,6]for x in reversed(l): print(x) 5. 迭代器 12345678# filter 实现带有筛选功能的迭代器def upper(val): if val&gt;0: return True else: return Falselis = [1,2,3,4,-1,-2,-3,-4,1,2,3,4]g = filter(upper, lis)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://maneback.github.io/tags/python/"}]},{"title":"一台电脑设置多个github账户","slug":"2github","date":"2020-02-10T03:23:55.000Z","updated":"2021-01-04T13:36:59.302Z","comments":true,"path":"2020/2github/","link":"","permalink":"http://maneback.github.io/2020/2github/","excerpt":"","text":"0. 前言 不知是否有人像我一样，搞了两个GitHub账号，一个公开使用，另一个用来自己留着偷偷搞事情，要做到两个本地账户和远程账号都完全隔离，没有联系，也不会混淆使用 反正我是这么搞的，自从之前那个GitHub账号被公布出去之后，就自己搞了个新的没人知道的账号来搞一些见不得人的事情。（其实只是喜欢保密一些事情。） 但是，一台电脑怎么假装出两个GitHub账户呢？ 当初的我以为只要把同一个SSH公钥分别添加到两个GitHub账户就万事大吉了，后来发现我太天真了，并不行。 然后就到处找教程，但是都是错误的，而且错误都是一样的，最后终于七拼八凑整成功了。 1. 方法 首先，当然是生成两个ssh秘钥，对应两个身份。 假设你当初已经用ssh-keygen -t rsa -C “youremail@gmail.com”生成了一对秘钥id_rsa和id_rda， 保存在了~/.ssh文件夹内。 然后，你需要再生成一对个人秘钥： 1ssh-keygen -t rsa -C “private_email@gmail.com” 这时，在执行命令的过程中，要在注意修改文件的命名，因为默认仍然是使用id_rsa的文件名，这样就会把之前的秘钥文件覆盖掉。 假设我们生成了一对新的秘钥private 和private.pub。 然后我们编辑~/.ssh/config文件。如果该文件不存在的话，直接创建一个就好。里面的内容如下： 1234567891011# 公共Host github_publicHostname ssh.github.comIdentityFile ~/.ssh/id_rsaport 22#个人Host github_privateHostname ssh.github.comIdentityFile ~/.ssh/privateport 22 网上大部分教程的配置文件中Hostname都是github.com，配置成这样是不能正常SSH访问的。我也不知道大家为什么都那样写，难道之前的就是这样？ 修改完之后，在git bash运行下列命令，检查是否正常： 12ssh -T git@github_publicssh -T git@github_private 如果都能返回以下信息，就说明配置正常 1Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 同样的方式你就可以配置多个以SSH登录的不同git用户。 当然这种方法也不仅仅限于github的远程仓库。 然后我们还要删除GIT配置的全局用户名和邮件地址，然后在每个项目仓库中按照需求设置不同的user.name和 user.email： 12git config --global --unset user.namegit config --global --unset user.email 然后在添加远程仓库的时候，把github.com 修改成github_public 或者github_private就好了（即上述文件中的HOST选项），如： 12git remote add origin git@github_public:xxx/example.git # 公开内容git remote add origin git@github_private:xxx/example.git # 个人内容 其实，上面的配置信息意思就是，按照不同的Host名称，查找~/.ssh/config文件使用不同的SSH文件连接到GitHub。","categories":[{"name":"技术","slug":"技术","permalink":"http://maneback.github.io/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"http://maneback.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://maneback.github.io/tags/github/"}]},{"title":"python3中列表的操作","slug":"python-list","date":"2020-02-09T09:37:13.000Z","updated":"2021-01-04T13:36:59.327Z","comments":true,"path":"2020/python-list/","link":"","permalink":"http://maneback.github.io/2020/python-list/","excerpt":"","text":"列表(list)是python中的一个基础的数据结构。 创建列表，访问、修改列表中的值 12345list0 = []list1 = [1,2,3,'a','b','c']# 通过index索引值访问列表中的值，更新列表中的值print(list1[0])list1[0] = 'a' +可以用来组合连接列表，*用来重复列表元素，如 1234567len(list1) # result =6[1,2,3] + [4,5,6] # result = [1,2,3,4,5,6]['aa'] * 3 # result = ['aa','aa','aa']3 in [1,2,3] # False'3' in [1,2,3] # Falsefor x in [1,2,3]: print(x) 通过index截取 12345# 包括元素list[l]，不包括元素list[r]list[l:]list[:r] list[-a]list[l:r] 有用的函数方法 1234567891011len(list) #长度max(list) #最大值min(list) #最小值list.append(pp) #在末尾添加新的元素list.count(pp) #计算pp在列表中出现的次数list.index(pp) #返回pp值第一个匹配项的索引位置list.insert(index, pp) # 将元素pp插入到index位置list.pop() #移除列表中的最后一个元素，并返回该元素的值list.remove(pp) #移除列表中pp的第一个匹配项list.reverse() # 反向列表元素list.sort(key=None, reverse=False) # 对列表进行排序","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"python","slug":"python","permalink":"http://maneback.github.io/tags/python/"}]},{"title":"Python中的MapReduce用法","slug":"Map-Reduce-in-python","date":"2019-07-09T12:48:14.000Z","updated":"2021-01-04T13:36:59.303Z","comments":true,"path":"2019/Map-Reduce-in-python/","link":"","permalink":"http://maneback.github.io/2019/Map-Reduce-in-python/","excerpt":"","text":"这一篇主要介绍python3中的Map函数与Reduce的用法。 Map与Reduce函数不止在python中支持，在JavaScript语言中也有对应的Map与Reduce函数，二者在思想与原理上相同，只是对应的语法标准与特定的语言相关。 Map是将一个相同的函数应用于序列或者迭代器的每一个元素上，并返回一个经过函数处理后结果的map对象。若函数包含两个参数，则应应用到两个序列上。 Reduce是将一个函数迭代累积的方式应用到序列或迭代器的所有元素上，并返回一个唯一的结果。函数接收两个参数。 在python3中使用Reduce函数要import一个包 1from functools import reduce 例子： 123456789101112131415161718from functools import recude#1 map一个参数x = [1,2,3,4,5]def add1(x): return x+1list(map(add5, x))#2 map两个参数x = [1,2,3,4,5]y = [1,2,3,4,5]list(map(lambda x,y: x*y, x, y))#3 reducedef add(x, y): return x+yx = [1,2,3,4,5]reduce(add, x) # 15","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"python","slug":"python","permalink":"http://maneback.github.io/tags/python/"}]},{"title":"在github提交中插入emoji表情","slug":"emoji-in-git-commit","date":"2019-06-07T13:02:24.000Z","updated":"2021-01-04T13:36:59.315Z","comments":true,"path":"2019/emoji-in-git-commit/","link":"","permalink":"http://maneback.github.io/2019/emoji-in-git-commit/","excerpt":"","text":"给你的github提交中添加一些emoji表情 git commit只有文字描述太无趣了，考虑来点有趣的，在github提交中加入一些emoji表情。💢 后来才知道，这个玩意，早就有人做出了规范说明，什么情况下，哪个表情用于什么用途，都是有规定的。方法很简单，遵循以下格式 :emoji1: :emoji2: information 额外要求：首字母大写，祈使语气，句末不要加句号 emoji使用指南 emoji emoji代码 使用说明 🎉 庆祝 :tada: 初次提交 ✨火花 :sparkles: 引入新功能 🔖书签 :bookmark: 发行/版本标签 🐛bug :bug: 修复bug 🚑急救车 :ambulance: 重要补丁 🌐地球 :globe_with_meridians: 国际化和本地化 💄口红 :lipstick: 更新UI和样式文件 🚨警灯 :rotating_light: 移除linter警告 🔧扳手 :wrench: 修改配置文件 ➕加号 :heavy_plus_sign: 增加一个依赖 ➖减号 :heavy_minus_sign: 减少一个依赖 ⬆上升箭头 :arrow_up: 升级依赖 ⬇下降箭头 :arrow_down: 降级依赖 ⚡闪电🐎赛马 :zap::racehorses: 性能提升 📈上升趋势图 :chart_with_upwards_trend: 添加分析或跟踪代码 🚀火箭 :rocket: 部署功能 📝备忘录 :memo: 撰写文档 ✅白色复选框 :white_check_mark: 增加测试 🔨锤子 :hammer: 重大重构 🎨调色板 :art: 改进代码结构/代码格式 🔥火焰 :fire: 移除代码或文件 ✏铅笔 :pencil2: 修复typo 🚧施工 :comstruction: 工作进行中 👷工人 :construction_worker: 添加CI构建系统 💚绿心 :green_heart: 修复CI构建问题 🔒锁 :lock: 修复安全问题 🐋鲸鱼 :whales: Docker相关工作 🍎苹果 :apple: 修复macOS下的问题 🐧企鹅 :penguin: 修复Linux下的问题 🏁旗帜 :checked_flag: 修复windows下的问题 PS：我还找到了如何在markdown文档中添加的emoji的方法。 使用搜狗输入法自带的emoji太大的，而且本地图片无法在网页中加载。 我也不知道在网页上会显示多大，会不会调整，但是我找到了一个网站： emoji之家 可以在上面的链接中搜索想要的emoji，然后直接点击复制，在markdown文件中粘贴就好了。😎","categories":[{"name":"Amazing","slug":"Amazing","permalink":"http://maneback.github.io/categories/Amazing/"}],"tags":[{"name":"git","slug":"git","permalink":"http://maneback.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://maneback.github.io/tags/github/"},{"name":"emoji","slug":"emoji","permalink":"http://maneback.github.io/tags/emoji/"}]},{"title":"巴斯夏--看得见的与看不见的","slug":"see-and-not-see","date":"2019-05-14T14:41:49.000Z","updated":"2021-01-04T13:36:59.328Z","comments":true,"path":"2019/see-and-not-see/","link":"","permalink":"http://maneback.github.io/2019/see-and-not-see/","excerpt":"","text":"《看得见的与看不见的》是巴斯夏写于1850年的一篇文章，虽然过去这么久了，但是对于现在的我们仍有教育意义。现将复制原文如下： 原文 在经济领域，一个行动、一种习惯、一项制度或一部法律，可能会产生不止一种效果，而是会带来系列后果。在这些后果中，有些是当时就能看到的，它在原因发生之后立刻就出现了，人们都能注意到它；而有些后果则得过段时间才能表现出来，它们总是不被人注意到，如果我们能够预知它们，我们就很幸运了。 一个好经济学家与一个坏经济学家之间的区别就只有一点：坏经济学家仅仅局限于看到可以看得见的后果，而好经济学家却能同时考虑可以看得见的后果和那些只能推测到的后果。这种区别可太大了，因为一般情况都是，当时的后果看起来很不错，而后续的结果却很糟糕，或者恰恰相反。于是，事情经常就是，坏经济学家总是为了追求一些当下的好处而不管随之而来的巨大的坏处，而好经济学家却宁愿冒当下的小小的不幸而迫求未来的较大的收益。 当然，无论在卫生和道德领域都存在同样的现象。通常，一种当时让人觉得舒坦的好习惯，后来总是带来痛苦，比如，生活放荡、懒隋、挥霍浪费。一个人如果仅仅注意到一种习惯的可以看得见的后果，而没有洞悉那些当时看不到的后果，他就会沉溺其中而不能自拔。他这样做，不仅仅是天生的嗜好，也自以为是经过深思熟虑的。 这说明了人必然要经历一个痛苦的过程。当他还在摇篮中的时候，处于无知之中，因此，他就根据行动的当下的后果调整自己的行动，在他年幼的时候，他也只能看到这种后果。只有在经过较长时间后，他才知道还应该考虑其他后果。有两个截然不同的导师教会他认识到这一点：经验和远见。经验有效而残酷地教育了他。我们的深切感受教导我们了解一个行动的所有后果：火如果烧到我们自己，从这一感受中，我们最终必然认识到，火在燃烧。不过，我还是想尽可能地用一个更温和的导师即远见替代这位过于粗暴的老师。为此，我将研究一下几个经济现象的各种后果，把看得见的后果与看不见的后果进行一番对比。 1、破窗理论 你是否见过这位善良的店主 —— 詹姆斯・“好人” 先生生气的样子？当时，他那粗心的儿子不小心砸破了一扇窗户玻璃，如果你置身于这样的场合，你恐怕会看到这样的情景，围观者，哪怕有三五十个人，都会异口同声如此这般地安慰这位不幸的店主：“不论发生什么不幸的事，天下总有人会得到好处。人人都得过日子呀，如果玻璃老是不破，要玻璃工干什么呀。” 现在，这种千篇一律的安慰已经形成为一种理论，我们将用这个简单的例子来说明这一理论。我们会发现，很不幸，就是这样的理论在指导着我们绝大多数的经济制度。 假定这块玻璃值 6 法郎，你就会说，这个事故给玻璃工带来了 6 法郎的生意 —— 它提供了 6 个法郎的生意 —— 这我承认，我绝不会说这不对。你的话很有道理，这位玻璃工赶来，履行自己的职责，然后拿到 6 个法郎，在手里掂量掂量，而心里则感激那个莽撞的孩子。这些都是我们能够看到的。 但是，另一方面，假如你据此推论，得出结论 —— 人们确实常常得出这样的结论 —— 说打破玻璃是件好事，说这能使资金周转，说由此可以导致整个工业的发展，那就容我大喝一声：绝不会有这种好事！你的理论只看到了能看到的一面，而没有考虑看不到的一面。 看不到的那一面就是，由于我们的这位店主在这件事上花了 6 个法郎，他就不能用这 6 法郎办别的事了。你没有看到的是，如果他不修补这扇窗户，那么，或许就可以换掉自已的旧鞋，或者给自己的书架上再添一本新书。简而言之，如果没有发生这起事故，他就可以用这 6 法郎干别的事。 下面让我们把工业作为一个整体，来看看这一事故对它的影响。现在窗户打破了，玻璃工的生意增加了 6 个法郎，这是我们已经看到的。如果窗户没有破，鞋匠（或别的什么人）就会增加 6 个法郎的营业额，这是我们看不见的。 而如果在看得见的一面之外 —— 这是积极的事实，也考虑一下看不见的一面 —— 这是消极的事实，那么，我们就会明白，不管窗户是打破还是完好，对整个工业，乃至全国的就业，都没有好处。 现在，让我们站在詹姆斯・好人先生的角度考虑一下。第一种情况，如果窗户被打破了，他花了 6 法郎，那么，他从窗户中得到的享受，既不会比从前少，但也不会比从前多。第二种情况。假如窗户没有被打破，他也就可以拿这 6 个法郎去买鞋，于是，他在继续享用窗户的同时，还可以得到一双鞋。而由于詹姆斯・好人先生是社会的一个组成部分，因此，我们必然可以得出结论：综合起来考虑，对享用和劳动进行一下估计，那么，我们已经丧失了被打破的窗户的价值。 作一个概括，我们可以从中得出这么一个出人意料的结论：“有些东西被毫无意义地毁灭了，社会损失了某些价值”。我们必然会同意这么一个令贸易保护主义者毛骨惊然的公理：“破坏、损坏和浪费，并不能增加国民劳动力”，或者更简单地说，“破坏并不是有利可图的”。 《工业观察报》对此会有何看法？或者令人尊敬的查曼斯先生的弟子们，你们对此还有何话说？你们的老师曾经那么精确地计算过，如果烧毁巴黎，那将有那么多房子要重建，会带来多少生意啊。 我很抱歉打扰了人家很有独创性的计算，尤其是因为这种精神已经渗透到我们的立法中。不过我还是请他另算一遍，先把那些能看见的一面放到一边，考虑一下那些看不见的一面。 读者在进行观察时，必须谨记，在我讲的那个小故事中，并非只有当事的两个人，还有第三个人隐藏在幕后，我请他对此予以关注。一方是詹姆斯・好人先生，他代表着消费者，他本来可以有两样享受，但由于一个破坏行为，而只能享受一样。代表另一方出场的是玻璃工，表示生产者，他张开双臂欢迎窗户打碎的事故。第三方则是鞋匠（或者别的行当的商人），他的劳动却由于同一事故而遭受了同样大小的损失。这第三个人一直藏在阴影中，使我们一直没有留意到，但他却是这一问题中一个必不可少的因素。正是他向我们揭示了我们从破坏行动中能得到利润的想法是多么地荒唐。正是他，马上就可以教导我们。以为从限制贸易中能够得到多少好处的想法，其实更荒唐。毕竟，所有的破坏性行为中，再也没有比这更荒唐的了。因此，如果你把所有为贸易限制辩护的论证追根溯源，你所看到的，其实就只是这种老百姓的话：如果没有人打破窗户，玻璃工干什么去呀。 2、军队复员 一个国家跟一个人差不多。如果一个人想让自己舒服一些，他就得弄清付出的代价是否值得。对一个国家来说，获得安全保障可以说是最大的幸福。如果为了获得这种保障，必须动员十万人，花费一亿法郎，那我就无话可说了。这是付出了巨大的代价来换取的一种享受。 对于我想就这个问题发表的看法，请大家不要有误会。 一位议员提出要复员十万军人，这将减轻纳税人一亿法郎的税负。假定有人现在对他的提议作出反应：“这十万人和这一亿法郎是维护我们的安全所不可或缺的，这的确是某种代价。但是如果不付出这些代价，法国就会陷人内乱，或者可能会遭外敌人侵。” 在这里，我不想反驳这种看法，这种看法在不同的场合，可能正确，也可能错误，不过，至少从理论上说，却不算经济学上的胡言乱语。真正的胡言乱语是说，这种代价本身就体现了某种收益，因为它能给有些人带来好处。 如果我没有弄错，提出这一复员议案的人刚从讲台上走下来，就有一位雄辩家冲上去，开始讲起来： 裁撤十万人！你在想什么？他们会成为什么样子？他们靠什么生活，他们从哪儿搞到收入？你难道不知道现在到处都有失业现象吗？所有的职位都有很多人等着想干？难道你想把他们扔进市场，加剧竞争，压低工资水平？如果最后他们不足以维持基本的生存，不得不由国家来供养这十万人，又有什么好？再考虑一下军队所消费的酒、服装和武器，这些，让很多工厂和驻军城镇有生意可做，对于无数供应商来说，这可是飞来的横财啊。想想你的那种想法可能让这么多工厂关门大吉，你就无动于衷吗？ 从这番讲话中我们弄清楚了，他之所以赞同维持十万兵员，并不是因为国家需要这么多人在军队中服役，而是由于经济理由。我下面要驳斥的正是这些说法。 纳税人花上一亿法郎，不光能使十万将士自己过得不错，这一亿法郎也能让他们的供应商过上好日子：这些是看得见的。 但是，来自纳税人口袋的这一亿法郎，就不能用于这些纳税人和他们的供货商的生计了，数额也是一亿法郎。这是看不见的。算一算，想一想，然后你说说，对于全部国民来说，好处在哪儿？ 我本人则会告诉你我们在哪儿蒙受了损失。为了让事情容易理解，下面我不说十万人和一亿法郎，我们就说说一个人和一千法郎吧。 假定这儿有个 A 村庄，征兵官到处转悠，征召到一个人。税务官也同样在村里转了一圈，征到一千法郎的税款。这个人和这笔钱都被押送到东北部的梅斯城，这个人在这里可以过上一年跟以前不一样的生活，什么也不用干。如果你只注意梅斯 —— 是的，你确实已经看了几百遍了 —— 你觉得这样可真不错，有利可图啊。但是，如果你回头再看看 A 村庄，那么，除非你是个瞎子，否则，你就会看到，这个村庄损失了一个劳动力，也损失了可以作为他的劳动报酬的一千法郎，也损失了他细水长流地花这一千法郎所能带来的生意。 乍一看，这些损失似乎己经弥补上了。本来应该在村庄里发生的事现在搬到了梅斯。村庄里的人、钱，仍然好好地在梅斯呢，似乎什么也没有丧失。在那个村庄中，他是一个土里刨食、辛苦劳动的人，是个劳动人民；而在梅斯，他成了位士兵，他的生活整天就是 “向右看齐！”、“向左看齐！” 而已。在两个地方，金钱的使用和循环是一样的。然而在一个地方，有某个人每年三百天都在从事生产性的劳动；而在另一个地方，他每年三百天却是在干没有收益的事。当然，我们这是假设，对于公共安全来说，军队的一部分是必不可少的。 现在，要遣散这些军队了。你跟我说，市场上突然增加了十万工人，会加剧竞争压力，从而抑制了工资水平。这是你所看到的。 不过，还有你没有看到的一面。你没有看到，把十万士兵遣散回家，并不是把一亿法郎给弄没了，而是把它归还给纳税人了。你没有看到的是，用这种办法把十万工人扔进市场的同时，也把一亿法郎投人到市场中用以支付他们的劳动；因而，在增加劳动力供应的同时，劳动力的需求也等量增加了，据此，可以得出结论，你说工资将被压低，仅仅是幻觉而已。你没有看到，在遣散之前和遣散之后，与十万人配套的都有一亿法郎，而惟一的不同之处在于：在遣散之前，国家把一亿法郎给那十万人，他们却什么也不干；而在遣散之后，这一亿法郎却可以让十万人工作。最后一点，你也没有看到，纳税人交出白己的钱，不管是给一位士兵结果什么也得不到，还是给一位工人换取某种产品或服务，在这两种情况下，这些钱周转的比较长远的后果都是相同的，惟一不同的地方就在于，在第二种情况下，这位纳税人能够得到某种东西，而在第一种情况下，他什么也得不到。结论就是，对于国家来说，维持没有用处的军队是净损失。 我在这里批判的这种诡辩，不可能经受住将其推论到极致的考验，而这是所有理论原则的试金石。不妨考虑一下，如果扩大军队规模能够有利于国家，那么，干嘛不征召本国所有的男人都穿上制服呢？ 3、赋税 你是否曾经听什么人说过：“纳税是最好的投资；它们是生命的甘露。想想吧，赋税让多少家庭得以维持生存，然后再想象一下它们对工业的间接影响，它们的好处可真是无穷无尽，就像生活本身一样无边无际。” 为了驳斥这种说法，我不得不重复前面的论证。政治经济学非常清楚，它的论点井不怎么有趣，以至于随便什么人都能说三道四；重复则是最让人高兴的。因此，跟 Basile一样，政治经济学也为自己的应用 “准备” 了好几个谚语，可以肯定，在它看来，教育就是重复。 政府官员花销他们的薪水所享受的好处是可以看得见的，这些钱给他们的供应商带来的好处也是可以看得见的。就你那有限的视野而言，那些话是正确的。但是，竭力想减轻税收负担的纳税人的不幸，你却没有看见。供应他们必需品的那些商人由此而遭受的损失，你就更看不见了，尽管这些事实是明摆着的，完全可以从理智上认识到。 假如一位政府官员自己多花了 100 苏（法国过去的一种货币单位，20 苏等于 1 法郎 —— 译者注），这就意味着，纳税人自己就要少花 100 法郎。政府官员的花费是看得见的，因为这种事情已经发生了，而纳税人那边的情况却是看不见的，因为，唉，他没办法再花那笔钱了。 你把国家比喻成一块炎热干旱的土地，而赋税就是救命的及时雨，的确如此。不过，你也应该问问自己，这场及时雨是从哪儿来的，这场及时雨是不是从潮湿的地方吸上来从而使这个地方也变得干涸了？ 你要应该再进一步问问自己，这块土壤从这场及时雨中得到的宝贵的雨水，是不是比它由于蒸发而损失的水分要多？ 完全可以确定的一点是，当詹姆斯・好人先生掏出 100 苏给税务官时，他什么回报也没有得到。后来，当一位政府官员在消费 100 苏的时候，又把它还给詹姆斯・好人先生，以换取他所需要的同等价值的小麦或者服务。最终的结果是詹姆斯・好人先生损失了 5 个法郎。 政府官员确实 —— 如果你愿意的活，也可以说几乎总是 —— 能够向詹姆斯・好人先生提供等值的服务，补偿他交纳的那笔税款。如果是这样，那么，双方就都没有损失。这仅仅是一种交换关系、因此，我们的论点一点都不涉及官员的那些有用的功能，我想说的是：如果你想创造一个政府职位，那么，就请先证明它的用处何在。向詹姆斯・好人先生证明，他付出那笔钱是物有所值，他能得到它所提供的等值的服务。而除了这些内在的固有的效益之外，不要再像支持创建新的官僚机构的人士那样，说什么这些机构可以为官僚本身、为他的家人、为那些供应他们日常用品的商人带来多大的好处；也不要说这能创造多少就业机会。 如果詹姆斯・好人先生把 100 苏给某位政府官员并得到了真正有用的服务，那么，这种情况就跟他把 300 苏给某位鞋匠从而换到一双鞋一模一样。这是种买卖交换关系，其结果对双方都是公平的。但是，如果詹姆斯・好人先生交出 100 苏给政府官员，却没有得到相应的服务，甚至给自己带来了麻烦，那么，这就相当于他把自己的钱给了个盗贼。说政府官员花费的这 l00 苏会给我们国家的工业生产带来多大的好处，这种说法毫无意义；比起政府官员来说，盗贼也可以用这些钱做更多的事，詹姆斯・好人先生如果没有倒霉地碰上这两位非法的或合法的寄生虫，也完全可以给这笔钱派上更多用场。 因此，我们一定不能仅仅根据看得见的方面就作出判断，而要习惯于根据看不见的方面进行评价。 去年我还在议会财政委员会，因为当时反对党的成员还没有被人从制宪国民大会中全部给轰出来。当时，制宪者们的行为还算很明智。我们曾经听梯也尔先生说：“我毕生都在跟那些保王党人和教会党人作斗争，但自从我们都面临共同的危险以来，我开始了解他们，我们也经常在一起面对面谈话，我发现，他们并不是以前想象中的怪物。” 是的，如果双方不能经常接触，那么，敌意就会被夸大，而仇恨就会越来越强；如果多数派能够允许少数派成员进人各个委员会的圈子，那么，也许双方都会认识到，他们的理念之间的差异并不如想象中的那么大，而最重要的是认识到，他们的意图并不像想象的那样不正当。 这种情况并非不可能，去年我就在财政委员会。每次，我们的同事一说到要把共和国总统、内阁部长、驻外大使的工资固定在一个比较适中的水平上时，就会有人对他说： 为了得到良好的服务，我们必须让某些官员能够置身于某种声望和尊严的气氛中。这是吸引这些人士奉献他们的才智的办法。无数不幸的人都有求于共和国总统，而如果他总是不得不拒绝帮助他们，他就会处于痛苦之中。各部委和驻外使馆某种程度的奢华，正是宪政政府正常运转的一个组成部分，如此等等。 不管这样的说法是否值得商榷，但总是值得严肃对待的。不管他的想法是对是错，这样的说法总是基于公共利益的；而就我本人而言，我可以比我们的很多反对这种说法的人士给出更有说服力的论证，这些反对者不过是被狭隘吝啬和嫉妒心理所驱使罢了。 但真正触动我的经济学家良知的，让我为我的祖国的知识声誉感到羞愧的是，他们从这些论点继续发挥（他们总是忍不住继续发挥一番），最后提出下面这种荒唐的陈词滥调（却总是有人乐于接受）： 除此之外，政府高官的奢华生活也可以促进艺术、工业和就业。国家首脑和他的内阁部长们如果不能举行欢宴盛会，就无法把自己的生活完全融入到政治中去。降低他们的工资，就必然使巴黎的经济成为无源之水，从而也使整个国家的经济陷入萧条。 看在上帝的份上，先生们，您至少得尊重算术吧，别不知羞耻地跑到国民制宪大会上说，一个数字加另一个数字的总和，会由于是用这个加那个还是用那个加这个而有所不同，还怪人家不支持你。 那么，好吧，假设我正准备找个工人来帮我在我的田里挖一条沟，为此我准备出 100 个苏，就在我跟工人快要谈妥的时候，税务官跑来，拿走了我的 100 苏，经过一系列的程序，最后这 100 苏到了内政部长手里。我跟工人的生意没法做了，而部长大人的晚宴上多了一道莱。你是根据什么竟然可以断言，这位官员的支出，增加了全国的经济总量？你难道不明白，这仅仅是一次简单的消费和劳务的转移？一位内阁部长的餐桌上的确更加丰盛了，这没错，但相应地，一位农民的田里的排水却不畅通了，这同样是千真万确的。我承认，巴黎的某位包办宴会者能拿到 100 苏了，但你也得承认，外省的某个挖沟工人也少挣了 5 个法郎。对此我们所能说的就是：官员的餐桌和心满意足的包办宴会者是看得见的，而让雨水淹了的田地和挖沟工人没活可干就是看不见的了。 上帝啊，在政治经济学中要证明 2 加 2 等于 4 竟是这么地艰难！而如果你竟然证明了这一点，有人肯定会大喊起来：“这本来就很简单嘛，谁不明白？你烦不烦啊？” 然而，在他们投票的时候，却仿佛你从来就没有证明过任何东西一样，他们该怎么来还是怎么来。 4、剧院与高雅艺术 —— 国家应该补贴艺术吗？ 关于这一问题，正反双方都能说出一大堆理由。 有些人会说，艺术可以扩大民族的视野，提升民族的精神水平，并使民族的心灵富有诗意，为此，国家应该扶持艺术。这些人说，艺术可以将本民族从物欲的沉迷中解救出来，可以使本民族对优美的东西有一种渴望，因而也可以对她的行为方式、对她的习俗、她的道德甚至还有她的经济产生有益的作用。他们会问，如果没有意大利剧院（Theatre-Italien）和音乐学院，那么，法国的音乐会是什么样子？如果没有法兰西剧院（Theatre-Franais），法国的戏剧艺术会是什么样？如果没有我们的画廊和博物馆，我们的绘画和雕塑艺术会是什么样？人们甚至可能更进一步指出，如果没有对高雅艺术的集中管理（centralization）和补贴，那么，是否能够发展出这种高雅的趣味？这是法国人的心血所取得、并奉献给整个世界的高贵的成就。面对这么高尚的成就，放弃这种补贴，难道不是最轻率的行为吗？这种补贴分摊到每个公民身上，根本就没有多少，而归根到底，艺术的成就可以让我们在整个欧洲人面前觉得自豪和光荣。 这种种理由，我得承认当然是很雄辩的，不过，我们也可以给出很多同样雄辩的驳斥。首先，我们可以说，存在着一个分配性正义（distributive justice）的问题。立法者的权力是否大到可以使他研究艺术家的工资水平问题，从而对艺术家的利润给予补贴？拉马丁曾说过：“如果你取消对剧院的补贴，那么，你在这条路上要走多远？按你的逻辑，你是不是也要关闭大学各个系科、关闭博物馆、研究所和图书室？” 对此，人们可以这样回应：如果你想补贴所有美好而有用的事业，那什么时候才是尽头？按你的逻辑，是不是也应该为农业、为工业、为商业、为教育同样拨出王室专款？而且，你怎么就那么确定，补贴就一定有利于艺术的进步？这是一个远没有答案的问题，而我们亲眼看到，那些繁荣兴隆的剧院恰恰是那些靠自己的努力维持生存的剧院。最后，如果从更深层次进行考虑，我们就会着到，需求和欲望是此消彼长的，要想让全国的财富满足这些需求和欲望，那么，必然是越高级的欲望，占的比例就越小：政府决不能多管闲事干预这一过程，因为不管现在全国的财富有多少，通过税收来刺激奢侈品产业，都不可能不伤害基础产业，从而必然会逆转自然的文明进程。人们也会指出，人为地扰乱需求、趣味、劳动和人口之间的相应比例，将把国家置于一种不稳定而危险的境地，便之丧失稳固的基础。 这是反对国家于预某种秩序的人士提出的一些理由，在这种秩序中，民众相信他们应该满足自己的需求和欲望，因而可以自己决定自己的行动。我坦白承认，我也认为选择和刺激应该来自下面而不是上面，来自民众而不是立法者；而与之相反的理论，在我看来，将导致自由和人的尊严的毁灭。 然而，你知道现在人们是怎么根据错误而不公正的推测而骂经济学家的吗？如果我们反对补贴，人们就指责我们反对要进行补贴的这一艺术活动本身，我们被看成所有这些艺术活动的敌人，原因仅仅是因为我们想让这些艺术活动成为人们的自愿活动，应该自己去寻找恰当的报酬。因此，当我们要求国家不要用税款干预宗教事务时，我们就被人看成是无神论者；如果我们要求国家不要用税款干预教育，那么我们就被人看成是憎恨启蒙；如果我们说国家不应该通过税款人为地虚增某块土地或某个工业部门的价值，我们就成为财产权和劳工的敌人；如果我们认为国家不应该补贴艺术家，在某些人眼里，我们就成了觉得艺术无用的野蛮人。 我决不能同意上面的这些推测。我们决不会荒唐到想取消宗教、教育、财产权、劳工和艺术的地步，尽管我们要求国家保障所有这些人的活动自由发展，但不应该用别人的钱来供养他们；恰恰相反，我们相信，所有这些至关重要的社会活动都应该在自由的气氛中协调地发展，不管是哪一类活动，都不应该成为麻烦、弊端、暴政和混乱的根源，而这种状况今天恰恰所在多有。 我们的论敌则相信，一项活动，如果不给予补贴或者不加以节制，就等于取缔该活动。我们认为恰怡相反。他们所信任的是立法者，而不是普通人。而我们信任的是普通人而不是立法者。 于是，拉马丁先生说了：“根据这项原则，我们恐怕就不得不取消能够给这个国家带来财富和荣誉的公共博览会。” 对拉马丁先生，我的回答是：按照你的观点，不予以补贴就是取缔，因为你是从下面的前提出发的：除非依靠国家，否则，任何东西都不能存在，据此你得出结沦，如果不用税款来支撑，任何事情都办不成。但是我会就你说的事举一个恰恰相反的例子，我要告诉你，迄今为止最大、最壮观的博览会，就是现在伦敦正在筹备的博览会，这个博览会乃是建立在最自由、也最普遍的概念基础上的，我想就是用 “人道主义” 这个词在这里也并不算夸张，而正是这个博览会，政府却一点都没有插手，也没有一点税款补贴。 回头再来看看高雅艺术吧，我想重复一遍，人们可以提出很充分的理由来赞成或反对补贴制度。而读者当然明自，为了与本文的具体目的保持一致，我无须再陈述这些理由，或者在两种立场中间进行选择。 但是拉马丁先生提出的一个论证，却是我不能假装没有看到、坐视不理的，因为他的论证正好就落在我的经济学研究的范围之内。他说：“剧院的经济问题可以用一个词来概括：就业。这种职业的性质就不用多说了，它跟别的任何行业一样，在创造就业机会方面也是很有潜力很管用的。你们都知道，剧院的工资支撑着不少于 8000 名各式各样的人的生活 —— 美工、砖瓦匠、装演、服装道具、建筑师等等，他们都是活生生的生命，他们的产业的产值占我们的首都的 1/4 强，他们应该有资格获得你们的同情！” 你们的同情？翻译过来就是：你们的补贴。 还有呢：“巴黎的赏心乐事为外省各部门提供了就业机会和消费品，富人的奢侈是整个共和国靠复杂的剧院经济为生的 20 万各行各业工人的工资和面包之所在，他们都通过这些高雅的活动获得报酬，而这些高雅的活动使得法国的形象光辉灿烂，正是这些高雅的活动使他们得以维持自己的生计，并给他们的家人和孩子提供生活所必需的东西。你们拨付的这 6 万法郎，正是为了这一目的。”（好啊！好啊！热烈的鼓掌。） 而从我的角度看，我不得不说：糟透了！糟透了！当然，我的这一判断仅仅是针对拉马丁先生的经济观点。 是的，我们现在讨论的这 6 万法郎至少有一部分会到达剧院员工的手中。肯定有不少会在路上就被人截留。如果仔细地进行追究，我们甚至可能会发现，馅饼的大部分都落入了别人的手中。如果竟然有一些碎渣留给他们，实在就是他们的福气！不过现在我倒愿意假设，全部的补贴都能送到美工、装潢、服装道具、发型师等人士的手中。这些是看得见的。 然而，这些补贴是从哪儿来的？这是硬币的另一面，考察这一面跟考察它的正面一样重要。这 6 万法郎是从哪儿蹦出来的？假如某次议会投票没有抢先一步让这笔钱从市政厅流向塞纳河左岸，那么这笔钱会流向什么地方？这则是看不见的。 确实，没有谁会说，议会的投票活动能让这笔钱从投票箱中自己孵出来；没有人敢说这笔钱是对国民财富的一个净增加；也没有人敢说，如果没有这奇迹般的投票，这 6 万法郎就仍然是看不见、摸不着的。我们恐怕必须得承认，议会投票时的多数派惟一能够做到的，就是来决定，从某个地方拿出这笔钱，然后把它派送到别的地方，这笔钱只有从一个地方转移出来才能被送到其要去的地方。 这就是事情的真相。很清楚，纳税人一旦交出了一个法郎后，就再也不能使用那一个法郎了；很清楚，他被剥夺了那一个法郎所能带来的享受，而本来准备满足他这一个法郎的享受的工人，不管他是谁，就都得不到这一个法郎的收入了。 因此，我们千万不要有那种天真幼稚的幻想，以为 5 月 16 日的投票真的凭空增加了国民财富和就业机会。它只不过是重新分配了财富，重新分配了工资，如此而己。 是不是有人会说，它所补贴的那种能给人满足的事物和那种职业，是一种更急需、更道德或者更合理的东西或职业？对此我无话可说。我要说的是：你拿走纳税人的 6 万法郎，提高了歌唱家、发型师、装演工和服装师的收人，那么，庄稼汉、挖沟工、木匠、铁匠的收人就相应减少了同等数量。没有任何东西可以证明前一个阶层就比别的阶层更重要，拉马丁先生也并没有这样说。用他自己的话说，跟其他行业相比，剧院的工作是一样地有效率，一样地有成效，而不是更多。然而，这种说法似乎值得商榷，因为剧院行业没有比别的行业更有效率的最好的证据就是它竟然呼吁别的行业来补贴它！ 不过，对不同职业内在价值和优点的这种比较，并不是本文的目的所在。我在这里竭力要证明的只是，拉马丁先生及那些为他的说法鼓过掌的人士，如已经看到了那些向演员们提供必需品的商人们所获得的收益，那么，他们也应该看到另一面，看到那些供应纳税人必需品的人们所蒙受的收入上的损失。如果他们做不到这一点，他们就难兔被人讥笑为把某种重新分配错当成了某种净收益。如果他们的理论讲究逻辑性，那么，他们就应该要求对所有东西给予补贴；因为在一个法郎或 6 万法郎身上应验的东西，放在 10 亿法郎身上，也不应该失灵吧。 先生们，如果涉及税款的问题，我们可以用某些理由来证明它是有用的，但千万不要用下面这种拙劣的说法：“公共支出能使劳动阶级维持生存。” 这种说法的错误之处在在于它掩盖了个我们必须从根本上了解的事实：即公共支出无非是私人投资的一种替代而已，其结果也许会很有力地支持一位工人替代另一位工人，但却不会让作为一个整体的工人阶级的总体收人增加一丁点。你们的看法很时髦，但十分荒唐，因为你们的推理过程是不正确的。 5、公共工程 当国家确信在某个行业创办一个大企业会为社会带来好处后，就用从民众那儿征收上来的资金创办这样的一家企业，天下再也没有比这更自然的事了。不过，当我听到有人竟然用这样的经济学谬论 ——“除此之外，这种企业还是为工人创造就业机会的一条办法”—— 来为这种事情辩护时，我承认，我立刻就火冒三丈。 国家开通一条公路，建筑一座官殿，修缮一条街道，挖掘一条运河…… 这些工程确实可以为某些工人带来就业机会、这是可以看得见的。但这种做法也剥夺了另一些工人的就业机会，这是不大容易看得见的。 假定正在修筑一条公路有一千名工人日出而作，日落而息，并挣得自己的那份工资；这一点是确定无疑的。如果政府不准备开辟这条道路，如果议会没有投票为其建设拨出资金，这些善良勤劳的工人就干不了这份工作，也拿不到这些的收入；这点也是确定无疑的。 但这就是事情的全部吗？再全面地考虑一下，整个过程中是否还有点别的什么事情我们没有注意到？当迪潘先生以庄严的语言宣布：“议会已经决定……” 的时刻，那几百万法郎难道真的像不可思议的月光一样，自然而然地就洒落进富尔德先生和比诺先生的保险箱中？为了完成这一过程，国家除了花钱之外，难道不得组织人征集这笔资金？难道不得先派税务官到全国各地征税，纳税人个个不都得作出贡献？ 因此，必须要从两个方面来研究这一问题。一方面要注意到，国家要用议会拨付的几百万法郎干某些事情，同时也不能忽视纳税人本来可以用这几百万做什么事情 —— 而现在再也不能干这些事情了。因此，你明白了，公共企业是一枚有两面的硬币、一面画的是一位忙碌工作的工人，这幅图案是看得见的，另一面画的则是一位失业的工人，这幅图案却是看不见的。 把我在本文中批判的诡辩运用到公共工程中，就更为危险，因为这种诡辩就是在为最愚蠢的浪费事业进行辫护。如果一条铁路或一座桥梁真的有用，那么，还可以根据这一事实来论证它所带来的种种好处。而如果这些公共工程并没有多大用处，那些人会怎么做呢？他们一般都会搬出下面的胡言乱语：“我们必须要替工人们创造就业机会。” 从有人先是下令修建战神兵营（the Champ-de-Mars）后来又下令废弃不用这样的事实中，我们就能看出这种意思。据说，伟大的拿破仑在下令挖开一条沟然后又填上之时，也自豪地认为自己在干一件很有博爱精神的事业。他也曾说过，“这样做的结果，有什么意义呢？我们是想让财富流入到劳动阶级中。” 让我们从根子上探讨一下这个问题。货币使我们产生了一种幻觉。以货币的形态要求所有的公民对一项公共工程提供资助，实际上就是要求他们提供真实的物质上的资助，因为，他们每个人所交纳的税款都是通过自己的劳动才挣来的。现在，假如我们把所有公民都召集起来，要求他们为一件有利于所有人的工程贡献自己的一份力量，提供劳役，大家都会理解这件事情，因为他们的报酬就是这项工程所能发挥的作用本身。但是如果把他们召集起来之后，强迫他们修筑一条根本不会有人要走的道路，或者修建一座根本没有人愿意住的房子，惟一的理由是这项工程可以为他们创造出工作来，那也未免太荒唐了，他们当然有正当的理由予以反对：我们宁肯不要这样的工作，我们还不如自己给自己干呢。 如果公民们拿出来的不是劳役，而是货币，事情的性质并没有任何改变。但是，如果公民上交的是劳役，损失要所有的人承担，而如果公民们贡献的是金钱，那些由国家出面雇佣的人就不会损失他们的那一份，而那些已经上交了一笔税款、但没有在这里谋到工作的人，却还得再蒙受更多的损失。 《宪法》中有一条是这么写的： “社会要…… 通过国家、各部委、市政当局所组织实施的、雇佣失业者的适当的公共工程，以帮助和鼓励劳工的发展。” 作为应付严冬的一种临时应急措施，代表纳税人进行的这种干预具有良好的效应。这并没有增加就业数量，也没有提高工资总晕，而是把平时的一部分就业和工资拿出来，在困难时期作为一种慈善事业，施舍给他们，这实际上是一种损失。 而把这作为一种持久性的、普遍的、系统的措施，就完全是只有负面影响的骗人的把戏，是根本不可能坚持实行的，是自相矛盾的；表面上，它似乎创造出了一点点就业机会，并且搞得大张旗鼓，这是可以看得见的；但它却掩盖了一个事实：有更多的就业机会却因此而被排挤掉了，这是看不见的 6、中间人 社会是人们强制或自愿地彼此互相提供的所有服务的总和，强制提供的即公共服务，自愿提供的即私人服务。 第一种是由法律所强加或管制的，一般都不大容易随着需求的变化而调节，它们总是具有超长的生命力，即使已经没有任何用处而完全成了公共害人精，但却仍然大言不惭地自称为公共服务。第二种则是自愿的、也即个人承担责任的领域。在交易之后，每个人都卖出他所拥有的而买进他所希望得到的。我们可以认为，这些服务肯定都是有真正的用处的，这种用处的大小可以用它们的比较价值来准确地衡量。 正是因此，前者就通常都是静态的，而后者则遵循着进步的法则。 尽管公共服务部门过度的发展已经导致了资源的大量浪费，在社会中造成一群病态的寄生虫，然而，令人惊奇的是，很多现代经济思想流派却把这些坏现象归罪于自愿的私人服务部门，他们企图转变这些职业所发挥的功能。 这些思想流派在攻击他们所说的中间人的时候简直是义愤填膺。他们强烈地要求消灭资本家、银行家、投机分子、企业家、商人和小店主，指责他们横插在生产者与消费者之间，向两边都榨取钱财，没有为生产者和消费者增加任何价值。不过，这种中介的职能好像不大容易彻底消灭，于是，改革家们宁愿由国家担负起中间人的角色。 有人关于这点的诡辩就在于，他们大肆宣扬公众为其获得的服务向中间人支付了什么，而刻意掩盖如果取消中间人他们将向国家支付什么。我们又一次遇到了同样的冲突：找们可以亲眼看到的，与我们只能在心智中意识到的，也即看得见的与看不见的。 尤其是在 1847 年和大饥荒时期，社会主义学派成功地普及了它们那些错得离谱的理论。它们明白，即使是这荒唐的宣传，也能够吸引那些正在遭受灾难的人们；饥饿是魔鬼的引路人。 于是，这些动听的词语就有如神助：人对人的剥削，饥荒中的投机行为，垄断，他们的目的没有别的，就是抹黑企业的名声，就是抹煞企业的好处。 他们说：“为什么要把从美国或克里米亚进口食品的任务要交给那些批发商呢？找们国家或各部委或市政当局不能组织一个供应服务机构、建立储备货栈？这些机构可以以成本价出售商品，于是，人们、穷人就不用再向那些自由的、也即自私的、个人主义的、无法无天的商人上贡了。” 人们支付给商人的那些利润，是看得见的而在社会主义制度下，人们支付给国家或其办事机构的贡品，却是看不见的 人们支付给商人的这种所谓的贡品是什么？它的来源是这样的：两个人在竞争的压力下、根据协商后达成的某一价格，充分自由地互相对对方的某种服务给予补偿。 如果巴黎人的胃觉得饿了，而能满足这种欲望的小麦是在俄罗斯的奥德萨，那么，在小麦进到胃里之前，人们的痛苦是不会消失的。有二种办法可以使胃得到满足：饥饿的人自己跑去寻找小麦；他们也可以把这事完全托付给专门从事这门生意的人；第三种办法则是他们甘愿让国家征收一笔税款，然后由政府官员来承担这一任务。 在这三种办法中，哪一种最有优势？ 在所有时代的所有国家中，比较自由、文明、有阅历的人，如果可以自愿选择的话，总是毫不例外地选择第二种。我承认，在我看来，这已经足以证明它的优势了。我的心智不会承认人类会在这么一个显而易见的问题上自己欺骗自己。 不过，我们还是仔细来研究一下这个问题吧。 让 3600 万人都统统跑到奥德萨去搞到他们必需的小麦，显然是不可行的。第一种办法没有任何可行性。消费者不可能事必躬亲；他们不得不转而求助于中间人，不管是政府官员还是商人。 然而，我们得注意到，这第一种办法应该是最自然的办法。从根本上说，谁觉得饿了，那他自己就有责任去搞到自已要吃的小麦。这是一个只关乎他自己的任务，按说，这项任务只能由他自己来完成。假如别人，不管他是谁，为他提供了这项服务，替他完成了自己本该完成的任务，那么，这个人就有权获得补偿。我们就这里所谈论的其实正是这一点：中间人的服务内含着某种获得补偿的权利。 不过，我们必须面对社会主义者所说的寄生虫的问题。我们姑且承认中间人是寄生虫，那么，两种寄生虫 —— 商人或公共服务机构 —— 中，到底哪一个的寄生性少一点？ 商行（我假定它是自由的，否则的话，我的论证就无法进行下去了）是受它自己自私自利的动机驱使的，它研究季节的变化，日复一日地了解农作物的生长环境，接受来自世界各地的报道，预测人们的需求，采取预防措施。它的轮船时刻准备着，它在所有地方都有合伙人，它完全是自私自利的，而正是这些，使它能以尽可能低的价格买进，能有效地利用经济运转过程中的细枝末节，从而能以最小的代价获得最大的结果。时刻忙碌着满足法国人的日常需求的，不仅仅是法国的商人，还有世界所有地方的商人；如果自私自利能驱使他们以最低的成本完成他们的任务，那么，他们之间的竞争也同样能够迫使他们让消费者从他们己经实现的实惠中分享好处。一旦小麦运到，商人就希望能在最短时间内将其售出，以降低自己的风险，实现自己的利润，如果有机会的话，把这一过程再重复一遍。私人企业在价格比较的指引下，会把食品配送到整个世界范围内，而且总是从最紧缺的地方开始，也就是说从人们的需求最殷切的地方开始。因此，我们无法想象，还有别的什么组织能够更好地满足饥饿的人的利益？这么一个美好的组织的，不是出自社会主义者的想象，恰恰是由于下面的事实：它是自由的，也就是说，是自愿的。是的，消费者必须向商人支付他花在陆上运输、跨洋运输、存储、委托等方面的费用，但是在哪种体系下，那些消费小麦的人可以不支付将其运送到自己手里的费用呢？当然，除此之外，消费者还必须为商人的服务买单；但是，中间人的份额，可以通过竟争压缩在最低水平；至于公正问题，如果马赛的商人能够为巴黎的工匠服务，那么，巴黎的工匠怎么会不为马赛的商人服务？ 如果按照社会主义者的方案，在这些交易中由国家取代私人商人，将会出现什么局面？求求你，让我看看这样做能给公众带来什么样的实惠。零售价格会降低？然而想象一下，4 万个市政当局的代表在某一天 —— 在需要小麦的那一天 —— 同时涌到奥德萨，你以为这对价格会产生何种影响？运输费用会降低？然而，运输同样东西所需要的轮船、水手、远洋货轮、仓库会减少吗？或者我们真的可以不为所有这些东西花一分钱？商人的利润会减少？然而，那些市政代表和政府官员到奥德萨难道一无所求吗？他们大老远跑去难道是出于兄弟友爱？他们就不需要生活吗？他们的时间就不值钱吗？你以为这些费用不会达到商人准备获得的 2-3% 这样的利润率的上千倍？ 然后，再想想征收这么多税款来配送这么多食品的难度，想想必然伴随这样的活动而来的那些不公正和陋习，想想政府是否能够担负起这么重大的责任。 那些发明了这些愚蠢想法并在不幸时刻将这些想法灌输进群众的大脑中的社会主义者，大方地给自己冠以 “高瞻远瞩” 的称号，该词的这种用法蕴涵着一种真正的危险，语言的暴政给这个单词及其所蕴涵的判断标准赋予了正当性。“高瞻远瞩” 的意思就是说，这些先生的目光要比常人深远得多；他们惟一的失误就是过于超前于他们的时代；而如果消灭私人企业即他们所谓的寄生虫的时间还不成熟，那出错的就是公众，是他们没有跟上社会主义的脚步。但根据我的意见和知识，与此相反的想法才是正确的，我不知道我们要倒退回什么样的野蛮时代，才能对这一点的认识，找到跟社会主义者的水平相当的理解。 现代社会主义流派不断地反对当今社会中的自由结社。他们没有意识到，自由社会是一个真正的合作体，要比他们从自己丰富的想象中编造的任何形式的合作都要优越得多。 我们用一个例子来说明这一点： 某个人，早上一觉醒来，可以穿上一套衣服，在一块圈起来的土地上，施肥、疏浚、耕耘，种上某种植物，然后在上面牧养一群羊，从这些羊身上剪下羊毛，这些羊毛经过纺纱、编织、染色，然后织成布料；布料经过裁剪、缝纫，做成衣服。这整整一系列的过程需要无数他人的介入，需要利用农牧业、养羊业，需要工厂、煤炭、机器、货运等等。 假如社会不是非常真实的合作体，那么，不管是谁，要想有一套衣服穿，就都不得不自己独立奋斗，也就是说，要自个儿完成上面所说的数不胜数的整套操作过程，从最初开始的挥镐翻地到最后的拿针缝衣。 好在我们就有现成的协作，这是我们这种动物的根本属性，这些操作过程已经被分解到无数劳动者之中了。为了共同的利益，他们再继续往下细分，直到某一个点。在这里，只要消费需求增加，每一单独的专业化的操作过程就可以成为一个新的行业。整个生产过程分解之后。每个人都为总体的社会价值贡献了自己那份价值。如果这不是协作，我倒要请教这是什么。 注意，每个劳动者都不可能自己凭空制造出他所需要的最细小的原材料，因此，他们必然会互相利用对方的服务，为了一个共同的目的而互相协助；每个群体都跟其他群体联系在一起，因此，所有的人都可以被看成是中间人。举个例子，假如在整个生产交换过程中，交通运输变得十分重要，足以雇佣某一个人，下来是纺线，再下来是织布，那么，我们凭什么说头一个人比别人更像寄生虫？是不是没必要存在交通运输了？不是有人在花费时间和心思来完成这一任务吗？他干嘛不把这些时间和心思节省下来让别人来干？是他们会干得比他好，还是仅仅由于他们干的是不同的事情？至于他们的报酬，也即他们在生产交换过程中的份额，难道不是都得遵从同样法则的约束，限定于协商达成的价格这样范围内？这种劳动分工和这些充分自由地决定的制度安排，难道不是有利于共同利益？我们是否因此而需要一位社会主义者，打着计划的旗号跑过来，专制地摧毁我们的自愿性组织，消灭劳动分工，用自己孤零零的努力取代合作工作从而逆转文明的进步？ 我在这里所描述的协作难道就不是协作吗？在这里每个人都可以自由地进人或退出，可以在其中选择自己的位置，可以按自己的意愿作出判断进行交换，自己承担一切责任，而正是自己的自私自利，赋予了他的行动以力量，也是成功的保证。是合作，就要名副其实，那么，所谓的改革家跑过来把他自己的想法和意志强加给我们，比如，说全人类都集中在他周围，那还叫合作吗？ 我们越是深人地考察这些 “高瞻远瞩” 的思想学派，我们就越是深信，归根到底，这些思想完全是建立在无知的基础上的，它们宣称自己永不会出错，并打着这种不会出借的名义要求获得专制的权力。 希望读者原谅我有点离题了。在这个当口，我多说了一些上面的话，也许并不是一点用处都没有，因为圣西门主义、法朗吉的宣传者、伊卡里亚岛的崇拜者的著作，激烈地反对中间人的长篇大论，充斥着报纸，回响在国民公会，严重地威胁着劳动和交换的自由。 7、贸易管制 贸易保护主义先生（这个大名不是我起的，而是迪潘先生的创意）把自己的时间和精力都用在把它的祖国土地上的矿石转化成铁。由于大自然对比利时人更慷慨，他们可以用比贸易保护主义先生更诱人的价格向法国人出售铁。这就意味着，所有的法国人，或者说整个法国，从好心肠的佛兰德斯人那儿购买一定量的铁，只需付出较少的劳动。于是受他们的自私自利的激励，法国人就充分地发挥这种局面的优势，每天都有无数的制钓者、金属加工工匠，车匠、技工、铁匠、犁匠，或者是本人，或者是派中间人，跑到比利时去购买他们所需要的铁。贸易保护主义先生却一点都不喜欢这个样子。 他的第一个想法就是自己赤手空拳进行直接干预，以阻止这种陋习继续蔓延。这当然是收效甚微，因为只有他自己会受到伤害。于是，他对自己说，我要扛起我的马枪，我要在我的腰里别上 4 把手枪，我要在弹夹中装满子弹，我要打开枪上的刺刀，最后他全副武装起来。我要到边界上去，我首先要杀了那些金属加工工匠、制钉匠、铁匠、技工、锁匠，他们竟然只管追求自已的利润，而不管我的死活。我要给他们点颜色看！ 然而就在他要起身的时候，他又有了一个想法，让那战斗激情凉了半截。毕竟，那些跑去买铁的人，我们的那些同胞，也是我的敌人，也很有可能采取自卫行动，最后的结果也许不是我杀掉他们，而是他们可能于掉我。而且，即便是把我的全部仆人都派上阵，恐怕也未必能守住整个边界。还有，我这么大张旗鼓，付出的代价也太大了吧，比我能从中得到的好处还大。 贸易保护主义先生只好长叹一口气，颓然倒下，听之任之，突然，他有了一个很捧的主意。 他记起来了，巴黎有一个伟大的法律工厂。他自问道，法律是什么玩意儿？法律就是这样一种措施，一旦颁布，不管好坏，每个人都得遵守。为了执行这一法律，政府组织起一支公共警察队伍，而为了维持这支所谓的公共警察队伍。国家专门拨出了人力财力。 那么，如果我能让伟大的巴黎工厂搞出一部小小的精密的法律，宣布 “查禁比利时出产的铁”，比利时铁就只能接受这样的结局。政府会派两万人去替代我的那几个仆人，到边界上去对付我痛恨的那些金属加工工匠、锁匠、铁匠、手艺人、技工和犁匠。当然，为了让这 2 万名关税官员保持良好的精神风貌和健康的体魄，就需要每年拨给他们 2500 万法郎，而这笔钱，自然也出自那些铁匠、钉匠、手艺人和犁匠的腰包。经过这样一番组织，就可以达到保护的目标了，而我自己却什么也不用付出；我再也不会显得像掮客那样野蛮了；我可以按我自己喜欢的价格出售铁了，看着我们伟大的人民这么被人不体面地愚弄，我的心里真有一种说不出的快感。他们老是宣称自己是欧洲一切进步的先驱和推进者，这下总算给他们当头一棒。这可真是一个聪明的主意，完全值得一试。 于是，贸易保护主义先生来到法律工厂（也许我会另找个时间来讲讲他在这里所进行的阴暗的、见不得人的勾当，不过今天，我只想谈谈他公开的、大家都看得见的那些活动步骤），他站在那些尊敬的议员先生面前。说出了下面的一番话： 比利时铁在法国的售价是 10 法郎，逼得我不得不也以这个价格出售。我们其实更愿意以 15 法郎的价格出售，但由于这些讨厌的比利时铁，我却不敢这么做。因此，赶紧制造一部法律，规定 “比利时铁不准进入法国”。我立刻就可以把我的售价提高 5 法郎，其结果则如下： 我卖给大家的每 100 千克铁的价格不再是 10 法郎而是 15 法郎，因此，我自己将更快地富裕起来，我可以扩大自己的生意，我将雇佣更多工人。我和我的雇员会花销更大，从而给供应我们的那些人带来更多好处。这些供应商也有一个更大的市场将对整个工业下更多的订单，慢慢地，这种扩张会扩散到整个国家。你将投进我的保险箱中的这 100 苏硬币就像一颗石子扔进湖里，将形成无数个同心圆沿着同一个方向扩散到很远的地方。 法律的制造者们给这一番话迷住了。他们完全沉浸在这样的想法中：仅仅通过立法就可以这么容易地增加国民财富啊。于是他们投票通过了禁止法令。他们说：“干吗还要说什么劳动和储蓄？如果一项法令就可以搞定一切，那么，增加国民财富的这些痛苦的办法还有什么用处？” 的确，法律会具有贸易保护主义先生所预料的所有后果，不过，除此之外，还有其他一些后果。公平地说，他的推理也许并没有错，但却很不完整。为了寻求特权，他指出了能够看得见的那些效应，但却掩藏了那些看不见的效应。他指明了两个人物形象，而实际上在这幅图景中还存在着第三个人物。我们的任务就是补上他遗漏的那些情节，不管是他真的不知道还是故意遗漏的。 是的，通过立法程序落入贸易保护主义先生保险箱的那 5 个法郎对他本人和那些因此而得到就业的人来说。当然是一件大好事。如果是法律下令从月亮上落下这 5 个法郎，当然就不会出现什么坏效应来抵消这些好效应。不幸的是，这奇迹般的 100 苏并不是从月球上掉下来的，而是来自金属加工工匠、针匠、车匠、铁匠、犁匠、建筑工的腰包，一句话，出自詹姆斯・好人先生的口袋。今天，它掏出了这笔钱，却连一毫克的铁都没有得到。于是，我们现在讨论的问题立刻就变了样了，因为非常明显，贸易保护主义先生得到的好处将被詹姆斯・好人光生的损失所抵消，贸易保护主义先生当然可以用这 5 个法郎促进国内工业的发展，而这 5 个法郎如果在詹姆斯・好人先生手里，他也同样能够做到这一点。石子之所以刚好是扔到这个湖里的某个地方，完全是因为法律禁止把它扔到别的湖里。 于是，看不见的东西抵消了看得见的东西；而整个这么一个过程的后果则是某种不公正，而这种不公正却正是法律所导致的，再也没有比这一点更可悲的了。 但这还不是问题的全部。我还要说，有一个第三者还藏在阴影中。我得让他在此显身，而他将能够揭示我们还得再损失 5 个法郎，这样我们才算搞清楚了整个过程中的全部后果。 詹姆斯・好人先生有 15 个法郎，这是他劳动的果实（我们是在追溯他还可以自由行动的那个时候）。他怎么使用这 15 个法郎？他用 10 个法郎买了一顶女帽，他用这顶帽子来换取（或者由他的中间人替他换取）100 千克比利时出产的铁。他手里还有 5 个法郎。他不会把它们扔到河里去，而会用它们支付某位匠人或者别的什么来交换可以满足自己需要的某些东西 —— 比如，用它跟某位出版商换取一本波舒哀【21】所著的《通史》。 因此，他对国内工业的贡献是 15 个法郎，即： 支付给巴黎的女帽制造和贩卖商的 10 个法郎 支付给出版商的 5 个法郎 至于詹姆斯・好人先生，他用他的 15 个法郎得到了两样能够满足他需要的东西，即： （1）100 千克的铁 （2）一本书 现在却颁布了法令。 詹姆斯・好人先生会怎么样呢？国内工业会怎么样呢？ 詹姆斯・好人先生把这 15 个法郎一古脑儿全部给了贸易保护主义先生，换取他的 100 千克铁，然后，他除了可以使用这些铁之外，就一个子儿都没有了。他丧失了那本书或者别的任何一个与此价值相当的东西带来的享受。他也损失了那 5 个法郎。你都赞成这种说法吧，你不能不同意这种说法，你不能不承认，贸易限制抬高了价格，消费者则损失了这 5 个法郎的差额， 然而，有人却说，国内工业得到厂这个差额。 不，它没有得到这个差额；因为，颁布法令后，这笔钱带来的促进作用是一样的，都是 15 个法郎。 由于颁布了法令，詹姆斯・好人先生的 15 个法郎只能全都交给冶铁商，而在法令颁布之前，这笔钱却可以分成两份，分别给女帽制造贩卖商和书商。 而从道德的立场看，贸易保护主义先生个人在边界上所能动用的力量，和这项法令为他的利益所发挥的力量，是截然不同的。有些人竟然认为，抢掠只要变成合法的，就不再是不 道德的了、就我本人而言，我无法想象比这更令人惊心的事了。但是也许有一点事情是确定的，那就是其经济后果总是不会有什么两样。 你可以从随便什么角度来研究这个问题，但是如果你冷静地考察这问题，你就会发现，从合法或非法的抢掠中是得不到任何好处的。我们并不想否认，这可能为贸易保护主义先生或他的行业或者如果你愿意的话也可以说为国内工业，带来了 5 个法郎的好处，但我们也可以肯定，这种行为也导致了两层损失：一是詹姆斯・好人先生，以前他买那些铁只需要 10 个法郎，现在却需要支付 15 个法郎；另一个蒙受损失的是国内工业，它不再能够得到那 5 个法郎的差额。你自己选择一下，我们所承认的那些好处能够补偿哪个损失、你没有选择的那一项就必然是一个净损失。 道德：使用暴力并不是生产，而是破坏。天哪，如果使用暴力也算生产，那么，法国就该比现在富裕得多啊。 8、机器 “我们诅咒机器！年复一年，这些机器日益强大的动力使成百万的工人陷人贫困之中，机器夺走了工人们的工作机会，剥夺了他们的工作，就是剥夺了他们的工资，而剥夺了他们的工资，就剥夺了他们的面包！我们诅咒机器！” 这是来自无知的成见的呼声。这种呼声回响在我们的报纸上。 然而，咒骂机器，就是咒骂人的心智。 令我迷惑的是，竟然还真有人信服这样一种理论！ 因为，归根到底，如果这些说法是可信的，那么，其严格的逻辑后果是什么？必然是：只有那些愚昧的、精神处于静止状态的民族，上帝没有赋予他们思考、观察、发明、创造，用最小的代价获取最大的成果的那些天赋的可怜的民族，才有可能获得安乐、财富、幸福。相反，那些努力寻找和探索铁、火、风力、电力、磁力和化学、力学法则 —— 一句话，即探索自然的力量 —— 及自身所蕴藏的力量的民族，则必然只能得到衣不蔽体，屋不遮雨，陷入贫穷和停滞，这可真是应了卢梭的一句话：“不管是谁，只要一思考，就成了堕落的动物。” 但这还不是全部。如果这种理论是正确的，那么，人们所思考和发明创造的一切，事实上是从头到脚一切的一切，人的每时每刻的存在本身，人们努力想让自然的力量为我所用，以小搏大，尽量减少自己的体力劳动或服务于他们的那些人的体力劳动，用尽可能少的劳动量获得最大限度的能满足自己需求的东西，所有这些努力，就都是该咒骂的；我们必然要得出结论：就是因为这种渴望进步的聪明才智似乎在折磨着这个世界上的每个人，所以，整个人类都正在走向堕落。 因此，我们应该能够从统计学上肯定，兰开斯特【23】的居民必然会为了不使用机器，而跑到爱尔兰去，那里的人们还不知道使用机器；因此，按照那种理论，在历史上，应该是野蛮的阴影笼罩文明的新纪元，而文明必然在无知和野蛮的时代才能繁荣。 显然，在这种理论中存在着很多自相矛盾之处，有些可以说令人震惊，并警示我们，这个问题掩盖了对解决该问题非常重要的因素，对此尚无人充分地予以揭示。 所有的秘密都在于，在看得见的东西后面，还有看不见的东西。我下面就是要揭开这看不见的东西。我的论证无非是前面已经讲过很多遍的东西的重复，因为这里的问题其实没有什么两样。 人具有一种天性，如果不受暴力阻挠，他们就希望进行交换，也就是说，交换某种东西，获得能满足自己需求的同等价值的东西，以节省自己的劳动，不管这种东西出自能干的外国制造商之手，还是出自能干的机器制造商之手。在这两种情况下。反对人的这种天性的理论上的理由都是一样的。不管在哪种情祝下，人们都指责他们显然是减少了工人的工作机会。然而，其实际的效果并不是使工作机会减少，相反，它们能够解放人的劳动，使之从事其他工作。 正因如此，面对外国人和机器的竞争，都设置了同样的障碍 —— 同样的暴力。立法者禁止外国产品的竞争，也不许机器进行竞争。让这些人士压抑所有人的天性、取消他们的自由的，还能有什么理由呢？当然，在很多国家，立法者只禁止一种形态的竞争而对另一种形态的竞争只是口头上抱怨抱怨而已。这只能证明，在这些国家，立法者还不够持之以恒。 这不应该让我们觉得奇怪。在错误的道路上，总是会出现这种不能贯彻到底的事，假如不是如此的话，那人类岂不是早就完蛋了。我们从来没有看到过、也希望永远不要看到，把 某个错误的原则贯彻到底。我曾经在其他地方说过：荒谬的东西必然是前后不一的。我愿意再加上一句：前后不一也正是其荒谬性的证据。 我们还是接着来谈机器问题吧，我不用费太多口舌。 詹姆斯・好人先生有两个法郎。可以让两个工人挣走。 但是现在，假定他发明了一套滑轮装置，使同样的工作只需要原来一半的时间就可以干完。于是，他的需求得到了同样的满足，但却节省了一个法郎，少雇佣了一个工人。 他没有雇佣某一位工人：这是可以看得见的。 仅仅看到这一点的人就说了：“对文明来说，这是多么不幸的一件事啊！你看看，自由对于平等来说，可真是致命的威胁啊。人的心智搞出了个新玩意儿，立刻就有一位工人永远地陷人到贫困的深渊了。也许詹姆斯・好人先生还可以继续雇两个人给他干活，但他却不可能再给他们每人 10 个苏了，因为这两个工人会互相竞争，最后只能以更低的价格来出卖他们的劳务。就这样，富人越来越富而穷人却越来越穷了。我们必须改造我们的社会。” 这可真是个很杰出的结论，也是一个应该给予坚实前提的结论。 幸运的是，这里的前提和结论都是错误的，因为在可以看得见的那一半现象的背后，还有另一半看不见的东西。 人们没有看到的就是，詹姆斯・好人先生节省下来的那一个法郎和节省下来的这笔钱必然会带来的效应。 由于利用了白己的发明创造，詹姆斯・好人先生为了实现自己的需求，就不用再花费两个法郎而只用花一个法郎，他手里还留下一个法郎。此时，如果市场上有一个想出卖自己的劳动的工人无事可做，那么，在另一个地方，也必然有个资本家在为他手里的一个法郎寻找出路。这两个因素会相遇，然后就结合在一起。 很显然，此时，劳动的供应和需求之间的关系，工资的供应和需求之间关系，都没有任何改变。 现在，发明出来的新技术和那个获得了第一个法郎的工人将一起完成以前由两个工人干的活。 另一个工人则会获得另一个法郎，干一份新的工作。 那么，这个世界因此会有哪些改变呢？整个国家的满足程度提高了；换句话说，新发明是种凭空得来的好处，整个人类都可以获得一种不用付出任何代价的好处。 从上面给出的这一论证中，有人也可能会得出下面的结论：“正是资本家，拿走了从机器的发明中所获得的全部好处，而劳动阶级，最初要暂时地承受机器带来的痛苦，但却从中得不到好处，因为，根据你上面说的那番道理，机器的发明不过使劳动阶级在全国各个产业中的比例有所调整，这个过程中确实没有减少工作机会，但也没有增加工作机会呀。” 在这一篇文章中不可能回答所有的疑问.。本文的惟一目的是驳斥一种无知的偏见，这种偏见非常危险而又广为流传。我希望证明，新机器的发明，在创造出一定数量的工人可以得到的工作职位的同时，也必然会创造出可以支付他们的工资的资金。这些工人和这些钱最终会结合在一起，从而生产出在发明之前根本不能想象的东西；由此得出结论，发明创造的最终结果，就是人们的满足程度增加了，增加的数量就等于节省下来的劳动的数量。 那么，谁获取了这部分超额的满足人们需求的东西？ 是的，首先是资本家获取了它，是发明家、是最早成功地使用这台机器的人获取了它，这是对他们的天才和勇气的奖赏。在这里，我们已经看到了，他实现了生产成本的节约，节省下来的钱，不管他怎么花（反正他总要花出去），总是可以提供就业机会，其数量就等于机器节约出来的就业岗位。 但是很快，竞争就会迫使他降低他的产品的售价，直到不再能够占有节约的那些成本为止。 这时候，发明家就不再能够占有发明创造的好处了；占有这些好处的将是这种产品的购买者，消费者，公众，其中也包括工人 —— 一句话，是整个人类。 这就是看不见的：节约下来的那部分钱，会由所有消费者获取，从而形成了一笔资金，这笔资金可以转化为工资，用来雇佣那些被机器淘汰的工人。 最初（回到前面的例子），詹姆斯・好人先生要支付两个工人的工资才能得到一件产品。由于他的发明创造，现在他只需要为体力劳动支出一个法郎。 如果他以同样的价格出售这件产品，那么，在制造这件产品的过程中就要少雇佣一个工人，这是看得见的；但是，詹姆斯・好人先生节省下来的那个法郎又可以多雇佣一个工人，这是人们看不见的。 随着整个事态的自然演变。詹姆斯好人先生渐渐地就得把这件产品的价格降低一法郎，直到他不再能够比别人省钱；这时候，他就不再能够腾出一个法郎为整个国家创造生产新产品的工作岗位。但是总有某个人，或者是整个人类取代了他，得到了这笔节省下来的钱。不管是谁购买这件产品，就都可以少花一个法郎，节省一个法郎，他必然把节省下来的一个法郎转变为工资基金。这同样也是看不见的。 人们还提出了解答这一问题的另一条思路，好像蛮有道理。 有人说：“机器压缩了生产成本，降低了产品价格。价格降低必然会刺激消费增加，而这必然又会促进生产增加，最后，就会使用跟发明创造之前同样数量的工人 —— 或者更多工人。” 为了支持这种论点，他们引用印刷术、纺纱机、印刷机的例子。 这种说法是不科学的。 从这种说法中，我们必然会得出结论，如果我们正在探讨的这种产品的消费保持平稳或基本上保持不变，那么，机器就会对就业造成损害。事情当然不是这样的。 假定在某个国家，所有的人都戴帽子。如果使用了机器，使帽子的价格下降了一半，这未必会使帽子的销售量也增加一倍。 是不是可以这样说，如果真是那样，那么，全国劳动力中就有一部分无事可做？如果根据无知的推理过程，我们的回答就是：是；但如果根据我的理沦，回答就是：否。因为，即使在这个国家，不会有人去多买一顶帽子，但整个国家用来作为工资的资金总量却并没有发生变化；我们看到，所有消费者所节省下来的钱如果不是都流入帽子加工业，那就会转变为由于机器的出现而多余出来的整个劳动力的工资，从而推动所有工业取得新发展。 这才是社会的现实。我以前看的报纸都要卖 80 个法郎，现在却只卖 48 个法郎。节省下来的那 32 个法郎归了订户。我们不能肯定，至少不敢说这 32 个法郎必然会继续流人新闻行业；但我们可以肯定，事情也必然是，这些钱如果不流向这个地方，就要流向另一个地方。一个法郎可能用来买更多的报纸，另一个法郎可能买更多的食品，第三个法郎可能买来更好的衣服，第四个法郎可以买来更好的家具。 因此，各行各业都是紧密相联的。它们构成一个巨大的网络。在这个网络中，所有的线都通过不为人知的方式联接在一起。一个行业中的节约会有利于所有行业。重要的是清楚地认识到：永远，永远不要以就业和工资为借口来干扰经济。 9、信用 所有时代，尤其是在最近几年，人们一直在梦想着通过使信用普遍化而实现财富的普遍化。 我敢肯定，可以不夸张地说，自从二月革命以来，巴黎炮制了不下一万本小册子来贩卖这种解决社会问题的方案。可惜，这种解决方案完全是建立在一种错觉的基础上的，假如某种错觉竟然可以算是什么东西的基础的话。这些人先是混淆了产品与硬通货，然后又混淆了硬通货和纸币；他们就是从这两点混淆出发的，却假装自己了解到了事实真相。 在探讨这一问题的时候，绝对有必要忘记货币、硬币、钞票和其他人们用于交换产品的那些媒介，我们只需仅仅关注产品本身，这才是贷款的真正本质所在。因为，一个农民为了买犁而借进 50 法郎时，实际上他所借的并不是 50 法郎，而是那犁具。如果一个商人准备借 2 万法郎买一栋房子，那么，他欠人家的并不是 2 万法郎，而是那栋房子。 货币之所以出现，仅仅是为了便利各方之间的安排。 彼得可能并不愿意把自己的犁借给别人使，但詹姆斯却很乐意借出自己的钱。这时候威廉该怎么办？他会从詹姆斯那儿借钱，然后用这笔钱去从彼得那儿买犁。 事实上，没有人会为了钱本身而去借钱，我们借钱总是为了要得到某种产品。 今天，没有一个国家能够把超出现存产品、不存在的东西，从一个人手里转移到另一个人手里。 不管硬通货和纸币的数量有多少，借方所能拿到的东西，总不可能超出贷方所能提供的犁、房子、工具、必需品或原材料的总量。 因为我们必须牢记，每一个借方都必然意味着存在一位贷方，而每一笔借款后面总得有一笔贷款。 如果我们承认这一点，那么，信用机构有什么作用呢？他们可以使借、贷双方更容易地彼此寻找到对方，并比较容易地彼此理解。而他们不可能做到的事就是同时增加借进贷出的东西的总量。 然而，信贷机构为了实现社会改革家们的目标却恰恰在做这样的事，因为这些先生们所渴望的不是别的，正是要让所有想得到犁、房子、工具、供应、原材料的人都得偿所愿。 那么，他们是如何想象自己能够做到这一点的呢？ 通过由国家对贷款提供担保。 我们还是深人地探讨一下这个问题吧，因为在这里，也有一些东西是看得见的，有一些东西是看不见的。我们要努力地观察到两个方面 假定这个世界上只有一张犁，而有两个农民都需要它。 彼得是全法国惟一的一张犁的所有者，约翰和詹姆斯都想借用它。约翰用他的诚实、他的财产和他的名誉来做担保。我们可以信任他，他很有信用。詹姆斯则不是那么让人信任， 至少看起来不是那么可信，最后的结果，自然是彼得把犁借给约翰。 然而现在，在社会主义精神的鼓舞下，国家干预进来。对彼得说：“把你的犁借给詹姆斯，我们将向你提供偿付的担保，这个担保要比约翰的担保值钱得多，因为，他只是一个自己对自己承担责任的个人，而我们，尽管确实是拿不出一件实打实的东西，但却掌握着所有纳税人的财富；如果必要的话，我们会用他们的钱来偿还詹姆斯欠你的本金和利息的。” 于是，彼得把他的犁借给了詹姆斯；这是我们能够看得见的。 于是，社会主义者就欢呼起来，说，“你看，我们的方案是多么的成功啊。正是依赖国家的干预，贫穷的詹姆斯才有了一张犁。他不用再自己动手翻地了，他现在就可以创造自己 的财富了。这对他本人有利，也有利于整个国家。” 啊，不，先生们，这并不是国家之福，因为这里，有些东西你们没有看到。 没有看到的一面就是：这张犁之所以到了詹姆斯手中，就是因为它没有能够借给约翰。詹姆斯是不用再翻地了，他可以用犁耕地了，但你们没有看到的是：约翰却不得不动手翻地。而不能用犁耕地了。 因此，你以为是额外增加了贷款，其实不过是贷款的重新分配而已。 你还没有看到，这种重新分配制造了两个严重的不公正：对约翰不公正，本来是他应该得到的，他可以用自己的诚信和自己的实力赢得的信用，却眼睁睁地被剥夺了；对纳税人也不公正，他们不得不承担起偿付跟他们没有任何关系的贷款的责任。 那么，政府就不能向约翰提供与詹姆斯同样的机会吗？但是，由于只有一张犁在那个地方，那么，就不可能同时借给两个人。于是，他们的论证就又返回到宣称：由于国家的干预，可以借到的东西会多于能够出借的东西，因为，犁在这儿只是用来表示可以利用的资本的总量的。 确实，我是把整个过程简化到最简单的形态来论述的。但是用同样的试金石来检验最复杂的政府现代机构。你肯定会相信，它们所能做到的也只能是重新分配信贷，而不可能增加 信贷数量。在特定的国家的特定时刻，可以利用的资本的总量总是一定的，它们总是要投放到某个地方。国家向可能会破产的债务人提供担保，当然可以增加借款人的数量，从而提高利率（这些成本则要全体纳税人承担），但它不可能增加贷方的数量，也不可能增加贷款的总价值。 不过，我祈求上帝保佑大家不要误解我的意思。我是说，法律不应该人为地鼓励借贷，但我井没有说法律应该人为地阻挠借贷活动。如果在我们的制度中或者在任何别的地方，有什么东西妨碍着信用的扩散和运用，那就应该由法律将其消除，没有什么比这更好更公正的了。但是，社会改革家如果真想名副其实，在改革的同时维护自由，就应该求助于法律。 10、阿尔及利亚 有 4 位雄辩家都在国民公会上声嘶力竭地讲着，先是一起大喊，然后又是一个接一个地喊。他们都说些什么？说的确实都是些很美好的东西，说的是法国的实力和伟大，说的是我们广阔的殖民地灿烂的前景，说的是重新配置我们的过剩人口的好处。等等，这些雄辩的杰作，总是装点着这样一样诱人的结沦： 拨款 5000 万法郎（有的人说得多一些，有的人要得少一些），在阿尔及利亚修建港口和公路，从而使我们能够把殖民者运进那里，为他们建造房屋，为他们平整出土地。这样，我们就可以从法国工人的肩上卸掉一些负担，促进非洲的就业，增加马赛的贸易，所有人都可以从中受益。 是的，在国家花费这 5000 万法郎的时候，如果我们只考虑这些钱将流向哪儿，而不考虑它们是从何而来的；如果我们只考虑它们离开税务官的保险箱后所带来的好处，而不管征收这些税款所带来的损害，或者不考虑这些钱由于进了政府的保险箱而使纳税人自己无法受益，那么，确实，所有人都在受益。而且，可以说，如果这样考虑问题，那么，所有事情都是有利的。建在北非伊斯兰教区的房屋是看得见的，建在北非沿岸的港口是看得见的。这里所创造的就业岗位也是看得见的；法国的劳动力在某种程度上会有所减少是看得见的，马赛的商业活动会繁荣起来，也是看得见的。 然而，有某些东西是这些人士没有看到的，这就是：政府花了这 5000 万法郎，纳税人自己就不能再花这笔钱了，从公共开支所带来的一切好处中，我们必然可以推论出妨碍私人开支的全部坏处 —— 起码在我们还没有过分到竟然说詹姆斯・好人先生根本就不在乎他辛辛苦苦挣来、但却被税务官拿走的那 5 个法郎；而这乃是一个荒唐的说法，因为他之所以不辞辛劳地去挣那 5 个法郎，就是因为他希望可以用这些钱获取某些满足自己欲望的东西。他本来可以雇人给自己的花园扎上篱笆，现在却办不到了；这是看不见的。他本来可以雇人给自已的田里施肥，现在也办不到了，这是看不见的。他本来可以增添一些设备，现在也不行了，这是看不见的。他本来可以吃得更好一点，穿的更漂亮一些；他本来可以让自己的儿了接受更好的教育；他本来可以多给女儿一些嫁妆…… 这些，现在他都做不到了，这些是看不见的。他本来可以加人互助会，现在没有办法了。这是看不见的。一方面，他被剥夺了一些必需品的享受，他办事要依赖的东西眼睁睁地就没有了；另一方面，他的那笔钱本来可以使他所在村子里的雇工、木匠、铁匠、裁缝、教师有更多的活儿可干，而现在这些工作机会却不复存在了，这些都是看不见的。 我们的国民会好好地考虑阿尔及利亚未来的繁荣景象，当然，我们承认这一点；但也得让他们同时考虑考虑法国必然要蒙受的损失。人们向我展示了马赛商业繁荣的前景，然而，假如这种繁荣是税款催出来的，那我倒宁愿指出，国内其他地区的商业将遭受的损害有多大。他们说：“每运送位殖民人口到北非伊斯兰地区，就可以减轻留在法国的人们所面临的人口压力。” 对此，我的答复是：“问题是，在我们把这位殖民者运送到阿尔及利亚的同时，我们是不是也得运送比他在法国维持生存所需要的东西多二三倍的资本？” 我惟一的目的就是希望使读者们明白，不管是什么样的公共开支，在其表面的好处的背后，都存在着更加难以洞悉的坏处。我一直在尽自己最大的努力使读者养成一种习惯，在看到看得见的一面的同时，也能洞察看不见的一面，对二者进行全面的权衡。 当有人提出增加公共开支的时候，我们必须仔细地考察它给我们自身带来的好处，而不仅仅考虑其在增加就业机会方面带来的所谓的正面效应，因为这方面的效应无非是一种幻觉。公共开支在这方面能够做到的，由私人来投资可以做得更好，因此，就业机会问题根本就与此不相干。 评估投入到阿尔及利亚的公共开支的内在价值，并不在本文的讨论范围之内。但我还是忍不住要作一个一般性的考察。因为人们从来没有对通过税收而进行的公共支出带来的正面经济效应作出过正确的评价。为什么？我提出下面的理由。 首光，公正总是会因此而蒙受损害。因为詹姆斯・好人先生辛辛苦苦地挣来 100 个苏，是想用来满足自己的需求，现在却将这笔钱征收走，他肯定会生气，至少会说，税务官把他的一些享受拿走，给了另一个人。于是，那些征税的人当然得给人家一些好听的理由吧。我们看到，国家总是会讲出这么一个令人生厌的理由：“用这一百个苏，我会让某些人有活可干。” 詹姆斯・好人先生（只要他脑子清楚）必然会回答：“天啊！我本来是可以用这 100 个苏让别人为我干活的！” 国家曾经提出过上面的论点，有人曾赤裸裸地提出过这种看法，则公共财政官员与可怜的詹姆斯先生之间的辩论就非常简单了。如果国家对他说：“我要从你这儿拿走 100 个苏，用来雇佣警察，他可以满足保障你的安全的需要，也可以雇人修筑你每天都要走过的马路，也可以雇佣文官，他可以负责保护你的财产权和自由权利，也可以供养军队，以保卫我们的边界。” 对此，詹姆斯・好人先生恐怕无话可说，我的多虑也是大错特错。但是，如果国家这样对他说：“我从你这儿拿走 100 个苏，是想拿出一个苏作为奖赏，如果你好好地耕种自己的田地。或者教你的儿子学习你不想让他学习的东西，或者让某位内阁部长在他的晚宴上增加第 101 道菜，我就奖给你一个苏。我也可能拿这 100 个苏在阿尔及利亚修建一座小别墅，不用说也可能拿更多钱去维持某位在那里的殖民者的生活，或者用一笔钱供养一位士兵保护这位殖民者，再用一笔钱供养一名将军来控制这些士兵，如此等等”。那么，我想詹姆斯先生肯定会大叫起来：“这套司法体系简直就是丛林法则的翻版！” 如果国家预见到了这些反对的理由，它会怎么办呢？它就会胡搅蛮缠，它会提出某种对讨论问题没有助益的令人生厌的论点。它大谈什么这 100 个苏可以创造多少个就业机会；它会说有多少个厨师和零售商因满足部长大人们的需求而获益；它跟我们大讲这 5 个法郎可以养活一名殖民者、一位士兵或一位将军；总而言之，它讲给我们的，都是那些看得见的东西。而假如詹姆斯・好人先生不知道下一步就该探讨那些看不见的一面，就必然会被愚弄。正是考虑到这一点，我才要高声教给他这种观察方法，并且来来回回地重复。 公共支出只能重新配置就业岗位而不可能增加工作岗位，从这一事实中我们必然得出结论，这种支出的质量是低劣的，必须严辞拒绝。重新配置就业岗位就意味着使工人的位置发生变化，扰乱控制着人口在整个地球上分布的自然法则。如果这 5000 万法郎留给纳税人，由于他们分散在全国范围内，所以这笔钱可以促进全法国 4 万个市镇的就业；如果能这样，这笔钱就是一个纽带，把每个人都跟他的祖国联系到一起；它可以在尽可能多的工人中间和所有可以想象出的行业中配置。而现在，假如国家拿走国民们的这 5000 万法郎，将其集中起来，花到一个地方，必然会吸引其他地方相应数量的工人迁移到这个地方来，而一旦这些钱花完，这些工人就会流离失所，形成流动人口，失去原来的社会地位，那时，我敢说，这些工人的处境就很艰难了。然而，现在的情况却是（这里我又回到本文的主题了）：这种狂热的举动、也即把所有的钱都投向一个小地方，吸引了每个人的注意力，这些是看得见的；人们拍手叫好，人们惊叹于其过程的美好和轻而易举，还要求重复这种过程，扩大实施的范围。看不见的则是在法国的其他地方，却再也创造不出同样数量的工作岗位了。而且是可能更有用的岗位。 11、节俭与奢侈 看得见的一面遮蔽了看不见的一面，这一点，并不仅仅表现在公共支出问题上。由于无视政治经济学的智慧，这种看得见和看不见的现象形成了一种错误的道德标准，导致人们把他们的道德利益和物质利益看成是对立的。还有什么比这更令人沮丧或更令人悲伤的了？请看：天底下所有的父亲，无不教导自己的孩子遵守秩序，持家有道，讲究实惠，力求节俭，适度消费。天底下所有的宗教无不痛斥摆阔气和奢侈无度。这些都很好，很有益。然而，另一方面，还有一些比这些格言更流行的说法： “聚藏钱财会使民族的血脉枯竭。” “大人物的奢侈可以使小人物生活得更舒服。” “纨绔子弟毁了自己但却富了国家。” “穷人的面包，就是用富人的浪费做成的” 在这些话语中，道德观和经济观之间当然存在着不可调和的矛盾。有多少杰出的人物在指出了这种矛盾之后，竟然可以作出一副若无其事的样子！对此，我实在是无法理解。因为在我看来，再也没有比在自己的内心中看到这两种趋势彼此冲突更令人痛苦的了。不是由于这一端，就是由于那一端，反正人类总是得堕落！如果讲究节俭，人类就将陷入可怕的短缺状态；而如果挥霍浪费，人类便会跌人道德破产的深渊！ 幸运的是，这些广为流行的格言对节俭和奢侈的看法是错误的，它们只考虑了短期的、可以看得见的后果，而没有考虑到那些看不见的、比较长远的效应。我们下面就对这种不完整的看法做一些矫正。 蒙多尔和他的兄弟阿里斯特平分了父亲的遗产，每人每年有 5 万法郎的收人。蒙多尔的生活就是现在最时髦的，花钱大方慷慨，挥霍无度。他一年之内就几次更换家具，每月就换一辆新马车，人们都在想着搞出新奇好玩的东西，好尽快将他那些钱榨干净。总之，他让巴尔扎克大仲马小说中生活奢糜的主人公也相形失色。 这样的人却被人奉若神明，倍受赞誉！“给我们讲讲蒙多尔的事吧！蒙多尔万岁！他可真是劳动阶级的大恩人，他是民族的善良天使。他确实是沉迷于奢华无度的生活，他的马车确实给行人溅了一身的泥水，他本人的尊严和人类的尊严确实多多少少蒙受了损害…… 但这又有什么呢？即使他确实不是靠白己的勤劳使自己成为对社会有用的人，他是通过自己的财富造福于社会了。他让钱周转起来了，他的院中商人们络绎不绝，每个商人都满意而归。人们不是说金币是圆的，本来就应该转起来嘛。” 阿里斯特的生活方式则跟他的兄弟截然不同：如果说他不是个自我中心主义者（egoist），那至少也算个人主义者；因为他花钱的时候很理智，只追求一些比较适度的、合理的享受，总是考虑自己孩了的未来，简而言之，他节俭度日。 现在，我想让你听听大伙儿是怎么说他的！ “这个富人、这个守财奴这样生活对社会有什么好处？当然，毫无疑问，他的简朴生活很感人，动人心弦，而且，他是仁慈的，善良的，大方的，但是他也太会算计了。他没有挥霍掉自己的全部收人。他的房子没有一年到头都光彩照人，也不是门庭若市。那么，你想木匠、车匠、马商和糖果商人能对他有什么好印象吗？” 这些评判对道德伦理是有害的。之所以得出这种看法，是因为人们只看到了一件事：纨绔子弟的挥霍，而没有看到另一件事实：比较节俭的兄弟的花销，其实是同样多，甚至更多。 不过造物主所安排的社会秩序是如此的美好有序。跟万事万物一样，在这种秩序中。政治经济学与伦理，绝不是互相冲突的，相反，是彼此和谐一致的，因而，阿里斯特的智慧不 仅更珍贵，而且比起荒唐的蒙多尔来，甚至能带来更多好处。 我说能带来更多好处，井不仅仅是指为阿里斯特本人带来更多好处，甚至也不仅仅是对整个社会带来更多好处，也包括能给当下的工人、对当代的产业，带来更多好处。 为了证明这一点，我们必须在心智中观照人的行动所带来的那些肉眼所看不见的隐蔽的后果。 是的，蒙多尔挥霍的效应是所有人都能看得见的：每个人都能看见他各种各样的马车，比如四轮双座有篷马车，双排座开合式顶篷四轮马车，四轮敞篷轻便马车；人们也都能看见他房中天花板上精细的绘画；看见他名贵的地毯；看见他那富丽堂皇的豪宅。每个人都知道，他在赛马中鸳驭着纯种马。他在巴黎豪宅中举行的宴会足以使林荫道上的行人心醉神迷， 人们争相传诵说，“有一个很慷慨的家伙，他一点都不吝惜自己的钱，他很可能在他的钱袋子上开了个眼。” 从工人角度看，阿里斯特的收人怎么有益于工人，却不大容易看得清楚。但是，如果我们认真地探究，就可以完全肯定地说，他的所有收人，直至最后一个子儿，都会用来雇佣工人，其作用跟蒙多尔的收人一模一样。惟一的一个区别是：蒙多尔荒唐的挥霍必然使其口袋迅速瘪下去，最后总有没钱的那一天；而阿里斯特明智的花钱方式却会是使他雇佣工人的数 量一年一年地增加。 如果这一点的确有道理，那么，公众的利益自然就跟伦理道德和谐一致了。 阿里斯特每年为他本人和家人的生活花去 2 万法郎。如果这还不足以使他觉得幸福，那他就不会被称之为明智了。他有感于穷人所承受的不幸，觉得有一种道德上的义务，多少也要救济一下他们，于是，每年拿出一万法郎从事慈善活动。他在商人、制造商、农民中总有一些朋友，他们可能会暂时陷人财政困境中，他了解到他们的处境，决定拉他们一把，当然要考虑周到，并且帮忙要帮到点子上，在这方面每年又花去一万法郎。最后，他也不会忘记，自己的女儿需要有副好嫁妆，自己的儿子要有个好前程，于是他告诫自己每年必须为此而储蓄、投资一万法郎。 因此，下面就是他的收人的用途： （1）个人花销 2 万法郎 （2）慈善事业 1 万法郎 （3）帮助朋友 1 万法郎 （4）储蓄 1 万法郎 如果我们仔细地考察一下这些支出项目。那么，就会明白所有的钱同样都投人支持了国家的工业，一个子儿也没剩。 （1）个人花销。对于工匠和店主来说，这些钱的效应跟蒙多尔花同样数量的钱的效应完全相同。这一点不言而喻，我们不用更多地讨论。 （2）慈善活动。他为此目的而捐献出的一万法郎跟别的同样数量的钱一样扶持了工业。这些钱会流人面包师、屠户、裁缝、家具商手中，只是用那些钱换来的面包、肉、衣服，并不是要直接地满足阿里斯特的需求，而是会满足那些得到他的捐献的人们的需求。而一个消费者替换另一个消费者，对于整个工业并没有任何影响。同样 100 苏，是由阿里斯特本人直接消费，还是他请一位穷人去消费，结果是完全相同的 （3）帮助朋友。阿里斯特把钱借给某个朋友，或者不图回报，而是用这笔钱为朋友举办葬礼，其经济结果跟我们的说法也没有矛盾。他的朋友会用这些钱购买商品或者偿还自己的债务。在前一种情况下，这些钱会促进工业发展。谁敢说蒙多尔用一万法郎购买一匹纯种马给牧业带来的好处，要大于阿里斯特或他的朋友用一万法郎购买布料所带来的好处？如果这笔钱用来偿还一笔债务，其结果是将出现第三个人，债权人，他将拿到这一万法郎，但是他也必然会用这笔钱在他的企业、工厂中干某些事情，或者开发利用某些自然资源。他的出现只不过是在阿里斯特和工人之间又多了一道中介而已。人名变了，但钱总得花出去，因而照样会促进工业发展。 （4）储蓄。还有一万法郎储蓄起来了。正是这一点，从表面上看，从促进艺术、工业发展和创造就业机会的角度看，蒙多尔似乎要比阿里斯特表现得好一些，尽管阿里斯特在道德上似乎要比蒙多尔优越一点点。 如果伟大的自然诸法则之间确实存在着这种矛盾，那么，我不可能不陷入实实在在的肉体的痛苦之中。如果人类沦落到只能在两者之间进行选择，要么是自己的利益蒙受损害。要么是自己的良心遭受折磨，那么，我们恐怕就要对人类的前景绝望了。所幸事实并非如此。要想看清阿里斯特的生活方式在具有道德上的优越性的同时，也具有经济上的好处，我们只需明白下面这个令我们欣慰的公理即可，而表面上看起来自相矛盾的公理是颠扑不破的：储蓄也是支出。 阿里斯特怎么储蓄他那一万法郎？是不是在自家的花园中挖一个坑把那 20 万苏硬币埋起来？不，当然不是。他还想增加自己的资产和收人呢。因此，他会用这笔不用的钱来购买一块地、一栋房子，购买政府债券、购进一家工业企业，他也可能把它委托给一个经纪人或是某位银行家打理。这些钱的用处不管是这里假设的哪一种，你都得承认，这笔钱也会通过买家、卖家的中介，最后促进工业发展，其效果跟他的兄弟用它来换取家具、珠宝、良驹没有两样。 因为当阿里斯特用他那一万法郎购买一块土地或一笔债券，他之所以这么做，是因为他觉得，他不用消费这笔钱。这一点似乎让你觉得他没有尽到促进工业发展的责任。然而，出售这块土地或者债券的人，最后也必然会以某种方式花掉他得到的那一万法郎，不会有任何例外。 因此，不管怎样，钱总是会花出去的，不管是阿里斯特本人花，还是别人代替他来花。 因此，从劳动阶级的立场和扶持工业的角度看，阿里斯特的行为和蒙多尔的行为之间只有一个区别：蒙多尔的支出是由他本人直接花费的，并且只为满足自己的欲望；这是看得见的。而阿里斯特的行为中，有一部分钱是通过中介渠道花费的。经过了一些曲折；这是看不见的。然而，实际上，对那些受他们消费活动影响的人来说，看不见的行为的效应与看得见的行为的效应是完全相等的。能够证明这一点的就是，在这两种情况下，钱都在周转，留在明智的哥哥的保险箱里的钱并不比留在挥霍的弟弟保险箱里的钱更多。 因此，说节俭会对工业带来实际的损害，是错误的。就促进工业而言，节俭和奢侈的最终效果是一样的。 然而，我们觉得，这些钱如果不是用于及时行乐，而是细水长流，那么，对工业的好处会更多，此话怎讲？ 10 年过去了。蒙多尔、他的财产、他的广为传诵的轶闻，如今安在哉？这一切早已经烟消云散了，蒙多尔已经玩完了，他早就不能每年为经济注人 5 万法郎了。相反，他可能早就开始靠公众供养了。不管现在他怎么样，反正他不再是店主的乐趣所在了；他不再被当成是艺术和工业的促进者了，他对工人也不再有任何用处了；他对他的子孙也毫无用处，他把他们抛置在悲惨生活之中。 同样是在 10 年之后，阿里斯特却不仅继续将其收人投人货币周转中，而且，每年贡献出的钱还在增加。他为国家的财富加砖添瓦。也就是说，他增加了用于工资的资金数量；而由于对工人的需求取决于这些资金的数量多少，因而他为劳功阶级提供了越来越多的报酬。而到他去世的时候，他留给孩子的，将是这些进步和文明的成果。 节俭从道德上要优越于奢侈。这是无可争辩的。令人欣慰的是，从经济的角度看，节俭也同样是优越的，不管是谁，只要他不是仅仅考察事物的直接效应，而是深入探究其深层效应，就必然会承认这一点。 12、就业的权利与保证获取利润的权利 “兄弟们，匀出你的一些钱让我有活可干” 这是就业的权利，是初级的或者说是初级水平的社会主义。 “兄弟们，匀出你的一些钱让我有钱可赚。” 这是保证获取利润的权利，是比较精致的，或者说是中级水平的社会主义。 这两者都是靠看得见的那些效应来维持其生命力，而那些看不见的效应自会令它们丧失合法性。 可以看得见的是，靠向社会搜刮钱财，的确创造出了这些工作机会和利润；而看不见的则是，如果这些钱留在纳税人自己手中，也同样能够创造出这么多工作机会和利润。 在 1848 年，就业的权利曾经在一段时间显示了其双重面孔。这就足以把它毁在公众舆论手中。 一副面孔被称之为：国立工厂；另一副面孔则是：加税 45 分。 每天，有上百万人从赛纳河两岸涌入国立工厂工作。这是这枚硬币美好的一面。 然而，这枚硬币还有另一面。为了从保险箱中拿走那几百万法郎，首先得有人挣出那数百万法郎。于是，就业权利的那些创办者们最后都不得不转而向纳税人伸手。 于是，农民们说了：“我必须交纳 45 分。因此，我就会失去一件衣服；我不能再给我的田里施肥了，我不能再雇人修缮我的房子了。” 于是，等人雇佣的手艺人们说了：“由于我们的老板没法添置新衣服了，所以，裁缝的活儿就少了；由于他无法再给自己的田地施肥了，所以帮工的事也少了；由于他没有钱修缮房子了，所以木匠和砖瓦匠的工作也少了。” 因此，事实已经清楚地证明了，你不可能从一桩买卖中两次获利；也证明了，由政府掏钱创造工作岗位，其代价就是纳税人不能再掏钱创造就业岗位了，这就是就业权利的最终结局。大家都看到了，它既是一种不公平，也是一种幻想。 然而，获取利润的权利无非是就业权利的一种扩展而已，却仍然很有生命力，仍然大行其道。 贸易保护主义者让社会所扮演的角色是不是多少有些可耻？ 贸易保护主义者对社会说：“你必须给我提供工作岗位，更有甚者，你必须给我提供有利可图的工作岗位。我曾经愚蠢地选择进入这个行业，结果，我现在亏损了 10%。如果你对大家征收 20 法郎的税金的时候，给我来个免税，那我就从亏损转为赢利了。现在，实现赢利就成了一种权利，你有义务满足我的这种权利。” 社会听信了他的这一番诡辩，在对全社会都征税的时候，却让他例外。社会没有认识到，那个行业的亏损被它勾销，并不等于它不是亏损了，因为其他人被迫承担起了那个亏损一一我倒是觉得，这个社会也只配承担别人强加给它的这些负担。 因此，从我上面讨论的很多问题中我们看到了，不了解政治经济学就会使我们在面对某一现象的直接效应时昏了头；而了解政治经济学之后，就能够全面地考虑各种各样的效应， 既包括直接效应，也包括远期的效应。 我本来还可以找出一大堆问题进行一番同样的分析，不过，我还是决定不这么做了，因为道理都是一样的，论证起来都是千篇一律，我希望把夏多布里昂谈论历史的一段话用到政治经济学上，作为本文的结语： 历史总是有两种后果：一种是当下的，几乎同时就可以认识到的；另一种则是比较遥远的，最初觉察不到的。这两种后果经常是互相抵触的，前者出自我们短视的智慧，而后者则需要我们具有目光长远的智慧。幸运的结果总是合乎人性的结果。在人的后面站着上帝。有人尽管竭力地拒绝获得至上的智慧，不相信这种智慧的力量；或者玩弄概念，把普通人称之为天意的东西称为 “环境的力量” 或者是 “理性”；但是，看看那些已经完成的事情的结局，你就会发现，如果一件事情不在一开始就建立在道德与公正的基础上，则其结果必然会是南辕北撤，适得其反。（夏多布里昂，《墓外回忆录》）","categories":[{"name":"Blog","slug":"Blog","permalink":"http://maneback.github.io/categories/Blog/"}],"tags":[]},{"title":"套路贷简史","slug":"taoludaijianshi","date":"2019-05-06T13:25:53.000Z","updated":"2021-01-04T13:36:59.330Z","comments":true,"path":"2019/taoludaijianshi/","link":"","permalink":"http://maneback.github.io/2019/taoludaijianshi/","excerpt":"","text":"0 写下这篇文章时，我的心情是复杂的。 我知道这篇文章能有耐心读下来的人不多，因为很长，很硬。 这不符合娱乐至死年代的快餐文。 我也知道这篇文章可能也活不太久，我写过的团贷与P2P的消亡简史，很多人都看过，但没多久就消失了，因为得罪的利益方太多了。 但是我依旧想写，想告诉大家这段网上搜不到的套路贷历史。 这篇文章我并不在意多少人能全文读完，只想当有人搜索套路贷的时候，他可以知道，这个世界上曾经发生过这段充满着人性矛与盾争斗的历史。 这段历史不应被忘却，不然未来，只会是历史的一再重演。 1 2007年，国内第一家网贷公司成立，开启了网贷的时代。 但那个时候同样也是国内线下贷款公司迅猛发展的年代。 在那个年代，银行还是高高在上的存在，信用卡和贷款准入门槛极高。 除了小部分特别优质的群体，大多数人都无法享受到大额的信用贷款。 但贷款是永恒的刚需，银行不借，自有民间资本。 这给了很多线下贷款公司机会，他们是国内最早一批玩儿套路贷的群体。 他们用月息3%到10%的利息在放贷，并且发明了使用服务费来做砍头息的玩法。 假使一笔50000元的贷款，服务费一般10到20个点，到手45000到40000元，然后按照50000元为基数算利息，等额本息还钱。 假使你借了1年期的50000元，到手只有40000元，一年下来，你可能要还10W元以上。 如果你不还，等待你的将是无止境的催收。 很多线下贷款公司，沿用了银行的风控政策，只是宽松一些。 所以多数时候借款人都是有稳定工作的体面人，他们最害怕贷款公司派人到单位和家里去闹，只能拼命凑钱还债，肥了催收。 那个时候，线下催收极为猖獗，由于这种贷款的金额高，利息高，所以往往也值得线下催收。 但在催收过程中，暴力，流血频频发生，这些都是带血的钱。 有几家现在看起来风光的美股上市互金公司，早年就是靠这个起家的。 毕竟高利贷是人类最古老的生意之一。 而资本的原始积累，必然是血腥的。 2 2010年开始，消费分期开始兴起。 人们一夜之间发现手机，数码产品，乃至电瓶车，都可以分期了。 很多正规公司都推出了分期服务，主要针对的就是工厂打工的社会蓝领，他们有消费需求，也有信用，也有稳定收入（工厂工资），只不过银行不乐意放给他们款。 而在此时，另一种套路贷开始兴起，打着商品分期的名义做。 蓝领，就是他们的核心目标。 蓝领们多数从家乡来到城市打工，看到了自己以前没有看到的景象，消费欲望强烈，同时渴望融入城市。 于此同时，他们的文化水平一般，对于费率的算法搞不清楚。 这种套路贷，针对的就是他们的消费欲望以及糊涂。 消费分期本质上是不给钱的，只是分期产品，然后每月还产品的钱。 给产品总不如给钱刺激，所以很多公司开始打着商品分期的名义在给现金，方法是先商品分期，然后低价回购商品，这里的低价就是贷款金额，而还款还是按照商品全款还。 这是一种变相的砍头息，高的可以做到50%砍头息，一台手机可以做几百人的生意。 而很多蓝领兄弟为了多一些现金消费，多一些灯红酒绿的日子，甘愿借这些钱。 银行不借给他们，大型信用贷款公司也不借给蓝领，所以他们只能被剥削着拿这些现金。 蓝领虽然有相对稳定的收入，但是50%的砍头息依然是要命的，他们必然还不上。 在这个期间，飞单和接盘开始兴起，这些套路贷公司开始把他们飞单给其他套路贷，让他们去借别的公司的钱还自己，于是在一轮一轮的债权转换后，蓝领们背上了一辈子都还不上的贷款。 记得吗，那个年代线下催收还是非常流行的，很多换不上钱的蓝领最后总会遭遇一些奇怪的意外，这是真正的带血的印子钱。 虽然后面由于实在太过分，大量坏账用线下催收也催不回，大量套路贷公司跑路，但是飞单和接盘的玩法，流传了下来。 这两大玩法，是永远架在借款人头上的达摩克利斯之剑。 3 2014年开始，针对蓝领的消费分期套路贷已逐渐退出了历史舞台。 但高利贷舞台上怎么会缺少见钱眼开的舞者？ 这一次被套路贷盯上的，是大学生。 大学生，实在是高利贷的优质群体。 大学生人傻，算不清高利贷的利息，并且对社会套路和身边人的防范心过低，天真。 大学生钱多，虽然自身生活费有限，但背后还有不会见死不救的父母，有钱。 大学生好推广，在需要搞定几个学生干部，在校园随时可以拉一批人推广，还可以以做兼职和实习名义搞。 大学生欲望大，正是血气方刚爱攀比虚荣心旺盛的年纪，看到身边的同学都用的好的，自己也想要。 大学生容易催收，因为年轻，要面子，所以一旦威胁告知学校老师同学，往往就会就范，另外很多学生对贷款本身也不够了解，容易被欺骗威胁。 这一切要素聚集，学生贷失控了。 在那个年代，每个大学校园里都是各家学生贷的广告，通知栏，寝室门，书桌，厕所，食堂，广告无处不在。 而最致命的广告，来自学生本身，很多学生成为了学生贷的校园推广大使。 这些人为了一些提成，拼了命的帮学生贷拉人头，不惜利用同学关系和道德绑架，甚至他们为了完成任务骗自己的同学资料来申请学生贷款。 我说过大学生脸皮薄，而且容易轻信同学，很多人都是被同学骗的。 甚至有一些学生专门骗身边人贷款下来自己花。 当时爆发了很多问题，恋人之间互相骗，学长骗学弟学妹，室友骗室友，为了钱，人人都可以是恶鬼。 而这些套路贷们，不仅用超出常人的利息收割学生，同时也在搞着别的把戏。 利滚利，砍头息，借新还旧，骗资料，假下款，推荐更多贷款机构，这些都是基础操作。 很多学生被催收逼的跳楼，很多家庭被利滚利的几十万拖垮，这些高利贷，该死。 而威逼利诱女学生去做一些特殊服务，更是案例不少。 在高利贷眼中，学生没钱不要紧，年轻的肉体，本身就是钱。 当时甚至有套路贷公司专门依靠套路来逼女学生下海，为当地夜总会提供货源，还能收一些服务费提成。 短暂的狂欢后，是监管的介入，各大高校禁止校园贷，学生贷公司更被严厉打击。 但潘多拉的盒子已经被打开，又怎会轻易合上？ 金钱面前，人已不是人。 4 2015年，学生贷短暂被遏制后，借条类产品又火了起来。 当时最活跃的产品是某某宝，他们搞地推，只要填写资料留下身份证信息，就直接现场发钱，并且拉人头还给钱。 很多人的绝密资料，为了去换回区区几十元，就卖了。 而且他们还拉来了更多的人，这批被卖掉的资料，后面不知道被用来做了多少见不得光的事情。 地推配合互联网高利贷，无往不利。 虽然某某宝本身不做贷款，但其为放印子钱的高利贷们提供了有用的工具。 借条的本质是一个平台，平台一边是出借人，一边是借款人。出借人可以自由设置结款条件，费率，借款人如果逾期后，平台还会提供催收服务。 发现了没有，这种无限制的产品天生就是为黑恶势力放高利贷而生的。 我说了，借款是永恒的刚需。 一时之间，那些因为学生贷撤退而债务崩溃的年轻人们，纷纷涌入各大借条类产品。 而这些放印子钱的借款人，玩出了新的花样。 除却标准的砍头息，利滚利，卖人头之外，他们开始搞一种叫做裸条的东西。 讲白了就是，想借钱，除了要付高额的砍头息和利息外，还要拍摄几张手持身份证的全裸照片或者视频。 出借人甚至会依据借款人的相貌来评估放贷额度。 这些年轻人用裸照换回来的钱，是多少？ 最多也就2000块，到手800块，一个礼拜后还2500，不然全网公开裸照。 裸条在短时间兴起，也在短时间结束，公安大量抓捕这些放裸条的黑恶势力，裸条虽然转入地下，但很多玩法思路，在下一代产品中有所体现。 在金钱面前，人不是人。 5 2016年，互联网小额高利贷，登上了历史舞台。 这是流毒至今的产品，公安早已将其定性为黑恶势力。 那个时候的产品，叫现金贷，又叫发薪日贷（Payday Loan）。 在欧美国家，发薪日贷非常发达，说白了就是1个月期限的高利贷款，这个月借，下个月发工资的时候还，由于欧美很多公司是半月或者以周为间隔发钱的，所以PDL的期限是1周到1个月，费率一般是30%到50%。 即使在欧美，这也是臭名昭著的产品，并且只接受线下申请。 而当时国内互联网发展极其迅猛，互联网的高效率和技术驱动，配合PDL的剥削本质，带来的是质变的飞跃。 当时的国内，这类普遍产品是1000到3000元，1到3个月，月费率6%到15%的普通小额高利贷，又叫现金贷。 当时贷款针对的主要是正常的蓝领或者小白领或者大学生，学生贷接着PDL的出现死灰复燃了。 因为互联网驱动下的高利贷公司可以放全国人的在线贷款，所以脱出了之前某一片区的限制，在2016年，这个市场还是一片蓝海，也是现金贷的第一波红利。 当时做的好的公司，一个月的净收益，是放贷总额的10%。 而且还可以利滚利，真实收益还要翻倍，这是真正的吸血。 资本嗜血，而技术成为帮凶。 6 可惜好景不长。 因为现金贷本身小额短期高费率的特点，正常人是不会借的，正常人会去找贷款公司去借1000元1个月利息15%的贷款吗？ 尤其是在2016到2017年，银行的准入门槛已经很松了。 这种对用户极为不友好的吸血产品，同样也是对用户阶层的一次逆向筛选。 会借这种钱的，大多是用于虚荣消费，或者赌债，或者不良嗜好的低收入群体和大学生，要么就是经济和信用已经崩盘的人。 这些人的特点是不仅收入低，并且对于资金管理和利息敏感度低。 当最烂的群体碰上最高效的互联网高利贷，多头负债就会非常普遍。 2016年7月，我对行业做过一次多头负债排查，现金贷人群的平均贷款数量为3家；2017年1月，这个数字是15家；2017年7月，这个数字是，22家。 到了2017年9月，这个数字是，32家。 借款人的多头负债正严重恶化，很多人已经实质性破产了，因为收入连每月的利息都覆盖不了，要是被哪家拒绝下款，立刻负债链就会爆炸。 但奇迹的是，没有爆炸。 因为各大公司，都发现了现金贷的暴利。 而自己原有的生意，和高利贷比，简直是过家家的玩具。 于是千军万马转高利贷，巅峰时有将近300家上市公司以各种形式参与了高利贷，更别提各个中小公司，互联网公司了。 他们的野蛮涌入，给那些原本要爆仓的底层人民续上了命，也给那些坏账即将爆发的公司，接了盘。 高利贷公司之间也有接盘的概念，就像野狗饿极了也会互相吞噬，这是自然规律。 很多表面高大上的互金公司，本质上就是一条条野狗。 7 野狗互舔的过程中，互联网高利贷也沿用了前辈们的套路，还开发出了新方法。 这个套路叫做【刻意逾期】。 众所周知，互联网高利贷的费率非常高，而逾期后的滞纳金更是搞的吓人。 为了能赚取更多的利润，当时非常多的贷款公司专门在还款上动手脚，故意让借款人没法在还款日还款，只有在逾期几天后，还款功能才会正常，以此来收取高额的滞纳金。 如果不从，则催收轰炸通讯录，问候全家。 渐渐地，由于利润实在丰厚，很多头部公司也开始玩儿【刻意逾期】的套路。 就在所有高利贷公司都在庆贺自己找到了印钞机时，危机来临。 转折点发生在2017年底，某头部高利贷公司（之前也是头部学生贷公司）美股上市。 当时他们的利润非常恐怖，市值甚至达到了百亿美金。 在面对公众质疑其放高利贷时，其老板亲自回应道：【不催收，就当做慈善】，这在整个行业乃至全国，引起轩然大波。 高利贷公司竟猖狂至此？ 监管开始出手，这家公司股价开始崩塌，与其一起崩塌的，还有整个网络现金贷行业。 这个时间节点是，2017年11月。 贷款，本身是有周期性的，一般到了年底，各家公司都在缩量，因为第一次还款日会在过年期间，这个时候催款很困难，并且很多借款人过年回家后，年后可能会换个地方打工。 年底缩量配合监管出手，整个行业都开始了逃亡。 所有公司都在拼命催款，并且坚决不再放款，而借款人们发现国家在打击，统统不还款，要死了不还。 大家都是一条链上的蚂蚱，要炸一起炸。 很多公司的坏账率一度飚到90%。 史称网络高利贷第一次大崩盘。 8 但高利贷这个生意，只要有钱赚，永远不缺不怕死的。 2018年3月，现金贷死灰复燃。 经过了第一次崩盘后的高利贷公司，痛定思痛，想清楚了一件事情。 自己放出去的钱，本质上不是放给穷人的，而是放给下一家接盘高利贷公司的，他们才是接盘侠。 所以聪明的做法是，贷款期限缩短，降低金额，收砍头息。 只要自己资金周转足够快，最后借款人财务奔溃时，谁跑快，谁赚得多，谁讲道理，谁死。 在经济学上，这叫劣币驱逐良币，在社会学上，这叫比烂。 我更想叫他们狗咬狗。 然后这样一款产品就诞生了，1000元借款，到手只有只有700元，7天后要还1100元。 10秒下款，是人就放。 自此，高科技与套路贷的完美结合，新的产品诞生了。 史称714高炮。 714高炮的收益模型中，年化利率可以做到1000%以上，净利润可以做到每月40%以上。 然后一场击鼓传花的游戏就开始了，各家公司的债权在那些底层群众的身上流转，跑得慢的就是死。 那些大公司，看到714这么赚钱，想到现金贷的甜头，又过来舔了，这次一起来的，还有上一波现金贷浪潮中各大公司的中高层管理者，他们纷纷下海，打算在714中捞一波。 然后比第一波现金贷浪潮更大的浪潮来了，我管这个叫野狗年代，因为这些公司都是野狗，爬在底层人民身上无尽的贪婪吸血。 714浪潮中，大家发明了一个击鼓传花的套路。 就是贷款人逾期时，不恐吓催收，而是指导他们去其他同行手里借钱还给自己，然后继续下款，反正有砍头息在，自己横竖都是赚。 借款人被作为标的物，在各家公司间卖来卖去。 在这个过程中，一个典型的高利贷借款人，身上背负的714高炮，已有大几十甚至上百家，永远也还不清了。 大家都心照不宣地赚钱，在疯狂收砍头息，在拼命磨牙吮血。 18年一整年，大量的社会事件爆发，高利贷的各种负面新闻就没有断过。 9 2019年3月15日，315晚会曝光了714高炮，而公安也重拳出击将之定义为非法，是重点打击对象。 新的一轮大逃杀开始了。 这一次，饱受高利贷摧残的借款人变得前所未有的精明，大家看到了315定调，咬死了就是不还钱，怎么样都不还钱，反正违法，反正法律不支持，就是不还。 史称网络高利贷第二次崩盘。 714高炮溃败之后，是不是整个市场就一片清净，高利贷再无踪迹呢？ 不会的，未来，只是历史的一再重演。 55超级高炮，出现了。 就是1000元，5天，50%的砍头息。 1000元，到手500元，5天后要还1200元。 即使坏账高达80%，也不会赔钱。 新的套路再次出现，一个高利贷资金方，注册几十家高利贷公司，同一个APP代码套几十个不同的壳，这些公司从1号到55号来算，专门做55超级高炮。 小A走投无路，借了1号公司的贷款，付了50%砍头息，肯定还不上； 这时，1号公司的催收，回去指引他到2号公司借款还债，2号公司也是他们的55高炮，这样小A又被收了50%的砍头息，剩下的钱去还1号公司。 只要控制得当，小A会在这些公司里被无限循环下去，只需要1000块，就可以套路小A无数个500块的砍头息，并且把小A的债券做的特别特别大，最终背上10W的债都是轻轻松松的，当债权做大后，把小A的一切信息包含债权，卖给专门收购债权的线下催收公司，这些公司把很多人的债权集合到一起，形成大额的债权，然后用暴力恐吓的手段来要债。 前段时间杭州某高利贷壳公司的老板被抓，旗下有1300多个高利贷的壳。 而他本身只是某个大公司的代言人，之一。 高利贷是把用户当傻瓜；714是把用户当提款机；55高炮，是把用户当成一块肉，是可以榨出血水后渣子喂狗的肉。 10 随着55高炮的出现，以及风头过后的平静。 大量高利贷公司又开始了放款，整个市场上三方数据的调用量又开始逐渐恢复。 被高利贷剥削的人们，负债越来越严重，这又是一个击鼓传花的游戏。 游戏规则是，谁放款的费率高，期限短，砍头息多，谁才能赚到钱。 借款人本身只是待宰的猪。 高利贷公司的屠刀早已挥下，砍头息，暴力催收，生命威胁，各种乱象频发，大家都急着榨干他们的最后一滴血，趁热吃。 而催收乱象，已经到了过分的地步。 催收公司的手段自然就比较血腥，电话轰炸和语言威胁只是基础，很多催收公司甚至将借款人的照片P到黄图上进行散播威胁，还有的直接伪造律师函，甚至还有伪造公安通缉证明的。 甚至业内出现到借款人被逼到精神崩溃跳楼，警方赶到时，电话响起，接起来又是催收员的骂声。 为了钱，他们敢于践踏一切。 高利贷的第三次大繁荣开始了。 但第三次大溃败，也随之而来。 这一次监管做的非常聪明。 核心打击目标除了东躲西藏换主体的高利贷公司外，还有为高利贷提供系统的三方公司以及为高利贷提供催收服务的外包公司，既然挖矿的不好抓，卖水的总归跑不了。 近几个月，公安不停在抓各类高利贷系统公司以及进行非法暴力催收的公司，效果非常棒。 每端掉一家高利贷系统供应商，就会有一批高利贷死掉，因为他们所有数据都在系统中，服务器被干掉后，直接导致无法回款。 而那些暴力催收的公司被打掉后，这些高利贷更是失去了最后的风险兜底。 很多高利贷公司老板的钱，也是从民间借贷搞来的，很多回款失败的高利贷老板，也在面临资金方的追杀。 吃下去的血馒头，总有吐出来的那天。 吃人者必被人吃。 11 这篇文章写到这里，我突然很难过。 我知道即使监管继续加强，随着技术的进步，高利贷将会继续下沉，继续进化，形式更加先进，打法更加隐蔽，费率继续暴涨，继续吸人血，既然可以做5天50%的贷款，为什么就不能做1天50%的贷款呢？ 我当年从银行离职加入互联网，就是为了践行人人都能有信用的理想。 那时的我们想用技术改变这个世界，为真正有需要的人放款。 那时我们觉得金融可以让世界更好一点。 一开始我们卓有进展，但后来，一切都变了。 我们走的太快，太快了。 当钱来的太快时，一切欲望就失去了枷锁。 我们曾经为了最新的技术和最好的风控策略举杯。 但现在我们碰杯，都是梦碎的声音。 我们引以为傲的技术和策略，成了高利贷的帮凶。 我知道某些人只要有钱赚，谁管这钱是不是带血的？ 我知道在某些人眼里，钱才是这个世界唯一的正道，朝闻道，夕死可矣。 我知道在某些人嘴里，普通老百姓都只是韭菜，或老或新而已。 我知道很多表面高大上的金融精英，背地里什么礼义廉耻都不要，什么吸血抽髓的把戏都出来了，就是为了从同胞身上榨取最后一滴血。 我知道高利贷不死，高利贷永生。 我管不了别人，我只能管我自己。 后来我离开了这个行业，因为我无法容忍自己的能力被用在吸血上。 而我们曾经同行的那批人，绝大多数都沉浸在嗜血的利润中无法自拔，还有一些已经进去了，一劳永逸的财务自由。 或许我能做的不多，因为只要利益存在，资本就可以践踏一切。 但我还能写，能把这些阴暗的勾当摆在阳光下，被更多人看到，不管是助力监管还是让更多人避免上当，只要对公众有益，就够了。 资本的力量下，我们或许都是蝼蚁。 但蝼蚁，也有自己的尊严。","categories":[{"name":"Amazing","slug":"Amazing","permalink":"http://maneback.github.io/categories/Amazing/"}],"tags":[{"name":"文章","slug":"文章","permalink":"http://maneback.github.io/tags/文章/"}]},{"title":"python异常处理","slug":"python-exception","date":"2019-05-04T02:59:22.000Z","updated":"2021-01-04T13:36:59.327Z","comments":true,"path":"2019/python-exception/","link":"","permalink":"http://maneback.github.io/2019/python-exception/","excerpt":"","text":"异常处理 python中使用try ... except来处理异常 try 语句的工作方式如下： 首先执行try子句中的语句。 若没有异常发送，则忽略except子句中的语句，程序正常运行。 若在try中发生了异常，那么try中的剩余部分将会忽略。如果发生的异常类型与某个except中指明的相符合，那么执行对应except中的语句 如果异常没有与任何的except匹配，那么传递给上层的try中。 一个try语句可以包含多个except, 但是至多只有一个会被执行。 一个except子句可以同时处理多个异常，这些异常放在括号里组成一个元组，例如： 12except (RuntimeError, TypeError, NameError): pass 最后的一个except可以忽略异常的名称，当做通配符使用，可以使用这种方法打印一个错误信息，然后再次把异常抛出。 12345678910111213import systry: f = open('my.txt') l = f.readline() i = int(l.strip())except OSError as e: print(\"OS error &#123;&#125;\".format(e))except ValueError: print(\"Could not convert data to an integer.\")except: print(\"Unexcepted error: \", sys.exc_info()[0]) raise try except 语句还有一个可选的else语句，放在所有的except之后。这个子句将在try没有发生任何异常的情况下执行。 12345678for arg in sys.argv[1:]: try: f = open(arg, 'r') except IOError: print('cannot open this file:', arg) else: print('&#123;&#125; has &#123;&#125; lines'.format(arg, len(f.readlines()))) f.close() 使用else语句比把所有的语句放在try子句里面要好，这样可以避免一些意想不到的、而且except子句没有捕获的异常。 抛出异常 你可以使用raise语句来抛出一个指定的异常。即运行到这句话的时候，就会发生异常。 raise的参数必须是一个异常的实例或者是异常的类。 12345try: raise NameError('Hello World')except NameError: print('An excepton occurred!') raise 用户自定义异常类 用户自定义的异常，继承自Exception类。 123456789class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value)try: raise MyError(4*4)except MyError as e: # 这是一个异常的实例，用于访问异常的属性 print('My exception occurred, value: ', e.value) 定义清理行为 try语句中还有一个可选的finally语句，定义了无论在是否发生异常的情况下都会执行的清理行为。 无论try语句中是否有异常，finally子句都会执行。 如果一个异常在try子句中被抛出，但是没有任何的except把它截住，那么这个异常将会在finally语句执行后被抛出。 123456789101112131415161718192021222324def divide(x, y): try: result = x/y except ZeroDivisionError: print('dividion by zero') else: print('result is ', result) finally: print(\"executing finally clause\") [in 1] divide(2, 1)[out 1]result is 2.0executing finally clause[in 2] divide(2, 0)[out 2]division by zero!executing finally clause[in 3]divide(\"2\", \"1\")[out 3]executing finally clauseTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in ? File \"&lt;stdin&gt;\", line 3, in divideTypeError: unsupported operand type(s) for /: 'str' and 'str'","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"python","slug":"python","permalink":"http://maneback.github.io/tags/python/"}]},{"title":"Next主题个性化--hexo","slug":"hexo-next","date":"2019-03-02T05:54:05.000Z","updated":"2021-01-04T13:36:59.317Z","comments":true,"path":"2019/hexo-next/","link":"","permalink":"http://maneback.github.io/2019/hexo-next/","excerpt":"","text":"人类的本质就是真香，之前非常硌路地不用Next主题，不过还是跟随了大潮，换上了这一件热门主题。在网上看到的关于next主题的个性化配置的教程也挺多的，功能也十分强大。所以我选择了这个主题是因为功能真的很强大，很多实用的功能只要修改配置文件就可以使用了，而且已经有了很多可以选择的现成的工具。 1. 评论功能 通过查看next的配置文件，我们发现next支持的可用评论平台有很多，但是我选择的是Valine，看了一下，其他的好多都需要注册才能评论，但是我不想要这种，因为需要注册的话，就显得过于繁琐了，我只是发表一下观点，要我注册干啥。所以找了一个不需要注册即可评论的评论系统。既可以匿名，又可以在评论的时候设置昵称等信息。 valine是一款基于leancloud的快速、简洁、高效地无后台的评论系统。 配置过程 首先，注册leancloud 获取APP ID 和APP KEY，应用名称自己起一个，选择免费的开发版。 1553782179250 创建好后，进入应用，选择设置-&gt;应用key，复制App ID 和App Key。 在Next主题的配置文件中搜索valine，将enable 设置为true，将App ID 和App Key复制到相应位置。同时还可以开启其他功能，如邮件通知，评论计数等，按需操作 123456789101112valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: YOUR-APPID appkey: YOUR-APPKEY notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: what do you want to say # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page 然后，在leancloud设置–&gt;安全中心，将你的博客的网址填写到Web安全域名中就可以了。 我不知道为什么，这个评论系统并不能在本地预览，但是部署到github.io 之后就能正常显示了。 这样在leancloud的后台，你就可以查看留言了。选择存储–&gt;Comment 查看留言信息，还可以删除留言。 配置项 可以看到在Next配置文件中，Valine有很多配置项可用。下面分别讲解一下。 PS：我才发现，原来这个评论系统还可以支持MarkDown语法耶，真的是出乎我的意料。 2. 阅读量统计 3. 友情链接","categories":[{"name":"Blog","slug":"Blog","permalink":"http://maneback.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://maneback.github.io/tags/hexo/"}]},{"title":"HTML表单","slug":"HTMLform","date":"2018-11-21T11:52:54.000Z","updated":"2021-01-04T13:36:59.303Z","comments":true,"path":"2018/HTMLform/","link":"","permalink":"http://maneback.github.io/2018/HTMLform/","excerpt":"","text":"HTML表单 HTML表单用于收集不同类型的用户输入 &lt;form&gt;元素定义HTML表单，表单中包含多个不同类型的表单元素，input、复选框、单选按钮、提交按钮等等。 如下是一个简易的表单示例： 123456&lt;form&gt; First name:&lt;br&gt; &lt;input type=\"text\" name=\"firstname\"&gt; Last name:&lt;br&gt; &lt;input type=\"text\" name=\"lastname\"&gt;&lt;/form&gt; 表单属性 action属性 action属性定义了在提交表单时执行的动作，向服务器提交表单的通常做法是使用提交按钮，通常，表单会被提交到web服务器上的代码处理，如： 1&lt;form action=\"action_page.php\"&gt; 注：如果忽略action属性，则action属性会被设置成当前页面。 ### method属性 method属性规定在提交表单时使用的HTTP方法，GET或者POST，默认设置为GET。 12&lt;form action=\"action_page.php\" method=\"get\"&gt;&lt;/form&gt;&lt;form action=\"action_page.php\" method=\"post\"&gt; 要分清get和post的使用条件。 ### 其他属性 1&lt;form accept-charset=\"\" action=\"\" autocomplete=\"\" enctype=\"\" method=\"\" name=\"\" novalidate=\"\" target=\"\"&gt; target规定action属性中地址的目标（默认为_self）， 可选_blank, _parent, _self, _top。 HTML表单元素 &lt;input&gt; 元素 input是最重要的表单元素，它可以根据type属性的赋值具有多种形态。 ## &lt;select&gt;元素 定义下拉列表 123456&lt;select name=\"cars\"&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;option value=\"benze\" &gt;Benze&lt;/option&gt; &lt;option value=\"BMW\"&gt;BMW&lt;/option&gt; &lt;option value=\"Porsche\" selected&gt;Porsche&lt;/option&gt;&lt;/select&gt; &lt;textarea&gt;元素 每个输入字段必须设置一个name属性","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://maneback.github.io/tags/HTML/"}]},{"title":"yaml","slug":"yaml","date":"2018-11-10T15:11:35.000Z","updated":"2021-01-04T13:36:59.337Z","comments":true,"path":"2018/yaml/","link":"","permalink":"http://maneback.github.io/2018/yaml/","excerpt":"YAML Ain’t a Markup Language.","text":"YAML Ain’t a Markup Language. 0. 简介 Yaml是用来编写配置文件的，对比同样是用来编写配置文件的JSON，Yaml非常简洁和强大，也远比JSON方便。 YAML的定义即为“YAML Ain’t a Markup Language.”的递归缩写。YAML是以数据为设计语言的重点的，而不是像XML以标记为重点。也正是这种设计理念，使它成为了一种可读性高，易于表达数据序列的编程语言。 1. 语法规则 YAML的语法规则非常简单，只要记住以下四条： YAML是大小写敏感的 YAML使用缩进来表示层级关系 YAML只允许使用空格缩进，禁止使用Tab键 缩进的空格数目没有限制，只要保持相同层级的元素对齐即可。 YAML支持的数据结构有以下四种。 对象： 即一个键值对的集合，用冒号表示 数组： 一组按次序排列的值 纯量： 单个的、不可再分的值，即String， Int 等类型的数值。 还要注意的一点是，冒号后面一定要加一个空格。 YAML的数据类型非常灵活，如： 键值对的值既可以是 纯量 类型，又可以是 数组类型 ，甚至是 对象； 同样，数组中的每一个元素也都可以是 纯量 或者 对象 下面将分别介绍着三种数据结构。 2. 对象 对象是一组键值对，使用冒号来表示 注意冒号后面一定要加空格。 1name: jason 3. 数组 数组由- 标识，一系列元素构成一个数组 123- yellow- blue- green 4. 复合结构 正如我前面所说的，数组的每一个元素都可以是一个键值对，对象的value 也可以是一个数组 12345678color: - yellow - blue - greenwebsite: baidu: baidu.com google: google.com apple: apple.com 它表示的数据结构： 12345678&#123; color: [yellow, blue, green], website:&#123; baidu: baidu.com, google: google.com, apple: apple.com &#125;&#125; 5. 纯量 纯量是最基本的。不可再分的值。以下数据类型都属于纯量 1234567- 字符串- 布尔值- 整数- 浮点数- Null- 时间- 日期 6. 字符串 字符串是最常见的一种数据类型。 字符串默认不使用引号表示。 1str: this_is_a_string 如果字符串之中包含了空格或者特殊字符，就需要引号 1str: 'he says: no' 单引号和双引号都可以使用，但是 双引号不会对特殊字符转义。 如果单引号之中还有单引号，必须使用两个单引号转义 123s1: 'this is a\\n string' # 'this is a\\\\n string\"s2: \"this is a\\n string\" # \"this is a\\n string\"s3: \"labor''s day\" # labor\\'s day 字符串还可以写成多行，从第二行开始， 必须有一个单空格缩进， 换行符将会被转成空格 1234str: this is a string # this is a string 多行字符串还可以使用| 保留换行， 也可以使用&gt; 折叠换行 12345678this : | FOO BARthat: &gt; FOO BAR# &#123;this: FOO\\nBAR&#125;# &#123;that: FOOBAR&#125;","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[]},{"title":"一些简单的git操作命令","slug":"git","date":"2018-11-02T13:57:03.000Z","updated":"2021-01-04T13:36:59.317Z","comments":true,"path":"2018/git/","link":"","permalink":"http://maneback.github.io/2018/git/","excerpt":"记录一些常用的Git命令","text":"记录一些常用的Git命令 git 设置用户名和邮箱 12git config --global user.name \"yourname\"git config --global user.email \"youremail\" git 查看用户名和邮箱 12git config user.namegit config user.email git添加远程仓库 12git remote add origin git@github.com:xiaosonggao/xiaosogngao.github.io.gitgit push -u origin master 删除远程分支 1git push origin :dev #: 表示删除origin上的远程分支dev commit 报错： fatal: LF would be replacesd by CRLF in &lt;some file&gt; 解决办法： 12git config --global core.autocrlf falsegit config --global core.safecrlf false git tag 使用 1234567891011# 列出所有标签git tag # 打标签git tag 1.0.1#切换到标签git checkout &lt;tagname&gt;#删除标签git tag -d 1.0.1 通常，git push 操作不会将标签对象提交到git服务器，我们需要进行显示的操作 123git push origin 1.0.1# 提交所有本地标签git push origin -tags git版本回退 12git reset --hard head^git reset --hard xxxx 拉取远程仓库强制覆盖本地内容 123git fetch --allgit reset --hard origin/mastergit pull","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"git","slug":"git","permalink":"http://maneback.github.io/tags/git/"}]},{"title":"Leetcode -- Reordered pow of 2","slug":"reorder-pow-of-2","date":"2018-08-10T01:54:41.000Z","updated":"2021-01-04T13:36:59.328Z","comments":true,"path":"2018/reorder-pow-of-2/","link":"","permalink":"http://maneback.github.io/2018/reorder-pow-of-2/","excerpt":"原题链接：https://leetcode.com/problems/reordered-power-of-2/description/","text":"原题链接：https://leetcode.com/problems/reordered-power-of-2/description/ 题目大意： 任意给要一个正整数n，可以随意调换每个数字的位置，看能不能得到2的幂。 n的范围1&lt;n&lt;10^9 解题思路 任意调换位置都可以，那也就是说明，n的每位数字所处的位置的权重都是不重要的，只要把n逐位分解，得到的1~9每个数字的个数与某个2的幂相同的话，那就可以通过调换位置得到该2的幂。 比如2的10次幂1024，它是由1个数字1 , 1个数字0， 1个数字2， 和1个数字4 组成的，只要n包含这四个数字各1个，就肯定能得到1024。也就是说我们要计数每个数字的个数。 由于1&lt;n&lt;10^9, 那么的话，n中最多有9个数字相同。我们可以直接用一个十位整数，每一位对应表示0~9的个数，若n与2的次幂转换之后的数字相同，则能够转换。 同样，由于n的取值范围，2的次幂最多有32个，可以枚举计算。 解题代码 12345678910111213141516171819class Solution&#123;public: bool reorderedPowerOf2(int n)&#123; int cc = counter(n); for(int i = 0; i &lt;=32; i++)&#123; if(cc == counter(1&lt;&lt;i))&#123; return true; &#125; &#125; return false; &#125; int counter(int n)&#123; int res = 0; while(n &gt; 0)&#123; res += pow(10, n%10); n = n/10; &#125; &#125;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"}]},{"title":"Leetcode  --  Maximum product subarray","slug":"max-product-subarray","date":"2018-07-14T04:14:32.000Z","updated":"2021-01-04T13:36:59.319Z","comments":true,"path":"2018/max-product-subarray/","link":"","permalink":"http://maneback.github.io/2018/max-product-subarray/","excerpt":"原题链接：https://leetcode.com/problems/maximum-product-subarray/description/","text":"原题链接：https://leetcode.com/problems/maximum-product-subarray/description/ 题目描述：求一个给定数组的子数组的最大乘积 这是一个非常经典的动态规划题目，同样可以归为“局部最优解和全局最优解法”。与Maxium subarray 思想类似，但是又有所不同。 回想Maxium subarray， 基本思想是遍历数组，同时维护两个变量，一个是全局最优解，即到当前位置元素的最优解；一个是局部最优解，即必须会包含当前元素的最优解。然后将之前的全局最优解与一定包含当前元素的局部最优解比较，看是否需要更改全局最优解。 同样此题目仍然是采用这种思路，但是由于乘法与加法存在的不同，我们还需要维护局部最小值。 1234567891011121314151617public int maxProduct(int[] A)&#123; if(A == NULL || A.length == 0) return 0; if(A.length == 1) return A[0]; int max_local = A[0]; int min_local = A[0]; int global = A[0]; for(int i = 1; i &lt; A.length; i++)&#123; int max_copy = max_local; //这个还要用 max_local = max(max(A[i]*max_local, A[i]), A[i]*min_local); min_local = min(min(A[i]*min_local, A[i]), A[i]*max_local); global = max(global, max_local); &#125; return global;&#125; 每次局部最优解是一定要包括当前元素的，但是全局最优解可能是当前的局部最优解，或者是之前的全局最优解。 最优解或者包含当前元素，或者不包含当前元素。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://maneback.github.io/tags/动态规划/"}]},{"title":"卡塔兰数","slug":"catalan","date":"2018-07-14T02:12:33.000Z","updated":"2021-01-04T13:36:59.305Z","comments":true,"path":"2018/catalan/","link":"","permalink":"http://maneback.github.io/2018/catalan/","excerpt":"卡塔兰数是一个神奇的数字","text":"卡塔兰数是一个神奇的数字 1.卡塔兰数的定义 一般项公式：\\(C_{n} = \\frac{1}{n+1}*\\binom{2n}{n}\\) 卡塔兰数的另一种表现形式为： \\(C_{n} = \\binom{2n}{n}- \\binom{2n}{n+1}\\) ，所以Cn 是一个自然数。 递推公式： \\(C_{0} = 1, C_{n+1} = \\sum_{i=0}^{n}C_{i}C_{n-i}\\) \\(C_{0}=1, C_{n+1} = \\frac{2(2n+1)}{n+2} C_{n}\\) 性质： 所有的奇卡塔兰数\\(C_{n}\\)都满足\\(n=2^{k} -1\\)， 其他的卡塔兰数都是偶数。 2.卡塔兰数的应用： 组合数学中有非常多的组合结构可以用卡塔兰数来计数。 \\(C~n~\\) 表示长度为2n的dyck word的个数。 dyck word是一个有n个X和n个Y 构成的字符串，且所有的前缀子串皆满足X的个数大于Y的个数。 将上例中的X换成左括号，Y换成右括号，表示所有包含n组括号的合法运算式的个数 \\(C~n~\\) 表示有n个节点组成不同的二叉树的方案个数。 \\(C~n~\\) 表示有2n+1个节点组成不同构满二叉树的方案数。 \\(C~n~\\) 表示对{1,2…n}依序进出栈的置换个数。 Leetcode题目链接：Leetcode 96","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://maneback.github.io/categories/knowledge/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"math","slug":"math","permalink":"http://maneback.github.io/tags/math/"}]},{"title":"一些小想法","slug":"str2bin","date":"2018-07-13T03:14:33.000Z","updated":"2021-01-04T13:36:59.329Z","comments":true,"path":"2018/str2bin/","link":"","permalink":"http://maneback.github.io/2018/str2bin/","excerpt":"","text":"1. 如何将一个0、1组成的字符串转换成二进制数； 如果能够确定仅是由0和1组成，可以使用下面的方法： 123456789101112//这个函数是模拟了二进制数字从右到左的形成过程，很骚。int str2bin(string str)&#123; int len = string.length(); int sum = 0; for(int i = 0; i &lt; len; i++)&#123; if(str[i] == 1) sum+=1; sum&lt;&lt;=1; &#125; sum&gt;&gt;=1; return sum；&#125; 2. C++中定义空串 12string s1 = NULL;//这个没有分配空间string s2 = \"\"; //这个分配了空间 3. 定义一个m*n的二维vector 12vector&lt;int&gt; nums(m)//指定长度vector&lt;vector&lt;int&gt; &gt; nums(m, vector&lt;int&gt;(n));//指定长度","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[]},{"title":"大庆油田","slug":"oil-deposit","date":"2018-04-13T03:12:57.000Z","updated":"2021-01-04T13:36:59.320Z","comments":true,"path":"2018/oil-deposit/","link":"","permalink":"http://maneback.github.io/2018/oil-deposit/","excerpt":"题目描述： 在给定的n*m图中，有几个@ 的块。块符合以下条件：其中任意的@均互相连接或者间接连通，两个@ 直接相邻或者对角相邻均视为连通。","text":"题目描述： 在给定的n*m图中，有几个@ 的块。块符合以下条件：其中任意的@均互相连接或者间接连通，两个@ 直接相邻或者对角相邻均视为连通。 我们可以这样解决这个问题，对整个图设置一个标志位，且该标记仅仅对地图上为@的点有效。按照顺序依次遍历地图上所以的位置。 若便利到@且该点未被标记，则所以与其直接相邻或者间接相邻的@点与其组合成一个块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;char maze[101][101];bool mark[101][101];int n, m;int go[][2] = &#123; 0, -1, 0, 1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1&#125;;void DFS(int x, int y)&#123; for(int i = 0; i &lt; 8; i++)&#123; int nx = x + go[i][0]; int ny = y + go[i][1]; if(nx&lt;1 || nx&gt;n || ny&lt;1 || ny&gt;m) coutinue; if(maze[nx][ny] == '*') continue; ark[nx][ny] = true; DFS(nx, ny); &#125; return;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; if(m == 0 &amp;&amp; n == 0) break; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin&gt;&gt;maze[i][j]; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; mark[i][j] = false; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(mark[i][j] == true) continue; if(maze[i][j] == '*') continue; DFS(i, j); ans++; &#125; &#125; cout&lt;&lt;ans; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://maneback.github.io/tags/BFS-DFS/"},{"name":"递归","slug":"递归","permalink":"http://maneback.github.io/tags/递归/"}]},{"title":"素数环","slug":"prime-ring","date":"2018-04-13T02:45:12.000Z","updated":"2021-01-04T13:36:59.327Z","comments":true,"path":"2018/prime-ring/","link":"","permalink":"http://maneback.github.io/2018/prime-ring/","excerpt":"题目描述： 题目的大意是给定1到n的数字中，将数字一次填入环中，使得环中任意两个相邻的数字的和为素数。","text":"题目描述： 题目的大意是给定1到n的数字中，将数字一次填入环中，使得环中任意两个相邻的数字的和为素数。 而且对于给定的n， 按照字典序由小到大输出所有符合条件的解。（同时第一个数恒定为1）。 为了解决该问题，我们采用回溯法枚举每一个值。 当第一个数为1确定时，尝试放入第二个数，使其与1的和为素数，放入后再尝试第三个数，使其与第二个数的和为素数。直到所有的数全放入换种，且最后一个与数与1的和也为素数，那么这个方案即为一个答案。 若在过程中，发现当前无论防止任何之前未放置过的数都不能满足条件，那么回溯改变上一个数，直到产生需要的答案，或者不再存在更多的解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int ans[20]; //保存环中每一个被放入的数bool hash[20]; //标记之前已经放入环中的数int n;int prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41&#125;;bool judge(int x)&#123; for(int i = 0; i &lt; 13; i++)&#123; if(prime[i] == x) return true; &#125; return false;&#125;void check()&#123; //ans[n]+ans[1] 不是素数，不是解。 if(judge(ans[n]+ans[1]) == false) return; for(int i = 1; i &lt;= n; i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;//num表示已经放入环中的数字void DFS(int num)&#123; if(num &gt; 1)&#123; if(judge(ans[num]+ans[num-1]) == false) return; &#125; if(num == n)&#123; check(); return; &#125; for(int i = 2; i &lt;= n; i++)&#123; if(hash[i] == false)&#123; hash[i] = true; ans[num] == i; DFS(num+1); hash[i] = false; //返回后清除标记 &#125; &#125;&#125; int main()&#123; int case = 0; while(cin&gt;&gt;n)&#123; case++; for(int i = 0; i &lt;= n; i++) hash[i] = false; ans[1] = 1; cout&lt;&lt;\"case \"&lt;&lt;case&lt;&lt;\":\"&lt;&lt;endl; hash[1] = true; DFS(1); cout&lt;&lt;endl; &#125; return 0;&#125; # 这是递归函数的第一个应用，回溯法枚举。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://maneback.github.io/tags/BFS-DFS/"},{"name":"递归","slug":"递归","permalink":"http://maneback.github.io/tags/递归/"}]},{"title":"胜利大逃亡","slug":"taowang","date":"2018-04-13T01:34:47.000Z","updated":"2021-01-04T13:36:59.330Z","comments":true,"path":"2018/taowang/","link":"","permalink":"http://maneback.github.io/2018/taowang/","excerpt":"广度优先搜索例子","text":"广度优先搜索例子 题目描述： 从一个A*B*C的三维城堡逃出去，从(0,0,0) 位置逃至(A-1, B-1, C-1) 已知魔王将在T时刻回来，且每分钟只能走到相邻的六个坐标中的一个，现在给你城堡的地图，问能否在魔王回来之前离开城堡？ 输入 A, B, C, T 后面的数据代表迷宫的布局， 0代表路， 1代表墙。 若能逃出去，则输出至少需要多少时间；否则输出-1。 题目解答： 我们用以下的结构体来保存每一个状态： 1234struct N&#123; int x, y, z; int t;&#125;; 其次，为了实现各个状态按照被查找到的顺序依次转移扩展，我们需要使用一个队列。将每一扩展得到的新状态放到队列中。 最后，为防止对无效状态的搜索，需要设置一个标记数组mark[a][b][c] ,当已经得达到包括坐标(x, y, z) 的状态之后，将mark[x][y][z] 标记为true， 下次再到达这个坐标之后，不再处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;bool mark[50][50][50];int maze[50][50][50];struct N&#123; int x, y, z; int t;&#125;;queue&lt;N&gt; Q;int go[][3] = &#123; 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1&#125;;int BFS(int a, int b, int c)&#123; while(!Q.empty())&#123; N cur = Q.top(); Q.pop(); for(int i = 0; i &lt; 6; i++)&#123; int nx = cur.x + go[i][0]; int ny = cur.y + go[i][1]; int nz = cur.z + go[i][2]; if(nx&gt;=a || nx&lt;0 || ny&gt;=b || ny&lt;0 || nz&gt;=c || nz&lt;0) continue; if(maze[nx][ny][nz] == 1) continue; //qiang if(mark[nx][ny][nz] == true) continue; N.tmp; tmp.x = nx; tmp.y = ny; tmp.z = nz; tmp.t = cur.t+1; Q.push(tmp); mark[nx][ny][nz] = true; if(nx==a-1 &amp;&amp; ny==b-1 &amp;&amp; nz==c-1) return tmp.t; &#125; &#125; return -1;&#125;int main()&#123; int test; int A, B, C, T; while(test--)&#123; cin&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;T; for(int i = 0; i &lt; A; i++)&#123; for(int j = 0; j &lt; B; j++)&#123; for(int k = 0; k &lt; C; k++)&#123; cin&gt;&gt; maze[i][j][k]; &#125; &#125; &#125; for(int i = 0; i &lt; A; i++)&#123; for(int j = 0; j &lt; B; j++)&#123; for(int k = 0; k &lt; C; k++)&#123; mark[i][j][k] = false; &#125; &#125; &#125; while(!Q.empty()) Q.pop(); //把上次的队列清空； mark[0][0][0] = true; N tmp; tmp.x = 0; tmp.y = 0; tmp.z = 0; tmp.t = 0; Q.push(tmp); int r = BFS(0, 0, 0); if(r&gt;=0 &amp;&amp; r&lt;=t) return t; else return -1; &#125;&#125; 注： 这个是使用队列来实现BFS 的。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://maneback.github.io/tags/BFS-DFS/"}]},{"title":"Leetcode -- Maximum Subarray","slug":"max-subarray","date":"2018-04-07T06:02:12.000Z","updated":"2021-01-04T13:36:59.319Z","comments":true,"path":"2018/max-subarray/","link":"","permalink":"http://maneback.github.io/2018/max-subarray/","excerpt":"原题链接：https://leetcode.com/problems/maximum-subarray/description/","text":"原题链接：https://leetcode.com/problems/maximum-subarray/description/ 题目描述： 求一个给定数组的的子数组的最大和。 这是一道非常经典的动态规划题目，可以归为“局部最优解和全局最优解法”。 基本思路：遍历数组，同时维护两个变量，一个是全局最优解，即到当前元素位置的最优解；一个是局部最优解，即必须包含当前元素的最优解。 接下来是动态规划的递推式： 12curmax[i] = max(A[i], curmax[i-1]+A[i])resmax[i] = max(resmax[i-1], curmax[i]) 局部最优解curmax 一定要包含当前元素，或者只包含当前元素。 获得了考虑了当前元素的局部最优解，那么全局最优解就或者是之前的全局最优，或者变为了现在的当前最优。 如果全局最优不包括当前元素，那么就会被维护在之前的全局最优里面；如果包含当前元素，那么就是局部最优。 注意到curmax和resmax只需要用到一次，因此可以不设置数组，直接用变量替代。 代码： 12345678910111213141516int max(int a, int b)&#123; return a&gt;b? a: b;&#125;int solution(vextor&lt;int&gt;&amp; nums)&#123; int n = nums.size(); int curmax = nums[0]; int resmax = nums[0]; for(int i = 1; i &lt; n; i++)&#123; curmax = max(nums[i], curmax+nums[i]); resmax = max(resmax, curmax); &#125; return resmax;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://maneback.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://maneback.github.io/tags/动态规划/"}]},{"title":"素数问题","slug":"prime-number","date":"2018-03-31T08:28:44.000Z","updated":"2021-01-04T13:36:59.326Z","comments":true,"path":"2018/prime-number/","link":"","permalink":"http://maneback.github.io/2018/prime-number/","excerpt":"素数相关问题：判断素数、输出前几个素数、输出(1~n范围内的所有素数)","text":"素数相关问题：判断素数、输出前几个素数、输出(1~n范围内的所有素数) 素数 一、判断素数 上界只到sqrt(n)， 且先将sqrt(n)计算出来赋值给变量，不要放到for循环里面，防止在循环中多次计算耗费过多时间。 所有有关于素数的计算都要从i=2开始循环 12345678bool is_prime(int n)&#123; int bound = sqrt(n)+1; for(int i = 2; i &lt; bound; i++)&#123; if (n%i == 0) return false; &#125; return true; &#125; 二、显示前五十个素数 显示前五十个素数，每十个数一行 1234567891011121314151617bool is_prime(int n)&#123; int bound = sqrt(n)+1; for(int i = 2; i &lt; n; i++)&#123; if(n%i == 0) return false; &#125; return true;&#125;int res[60];int index = 0;int start = 2;while(true)&#123; if(index == 50) break; if(is_prime(start++))&#123; res[index++] = start; &#125;&#125;cout&lt;&lt;res[]; 三、 素数筛法 若将(1~n)范围内的数使用上面的方法挨个判断，则太耗费时间。因此可以采用素数筛法。 基本思想 一个不是素数的整数一定存在某个比它小的素数作为它的因数。 因此从2开始，标记每个数的倍数，若到该标记k的时候，k还没有被标记，则说明它没有比它小的因数，k为素数。已知k为素数之后，继续标记k的倍数。而且nk(n&lt;k)已经作为n的倍数被标记过了，所有直接从**k*k** 开始标记。 若到标记k时k已经被标记，则说明k不是素数，且k的倍数肯定已经被标记了，直接跳过，看k+1 123456789101112131415161718192021#include &lt;iostream&gt;#define n 100000int flag[n];;int prime[n];using namespace std;void init()&#123; //initialize the mark = false; int index = 0; for(int i = 0; i &lt; n; i++) mark[i] = false; for(int i = 2; i &lt;= n; i++)&#123; if(mark[i] == true)//mark is true [i] is not a prime continue; //else i is a prime, storage it. prime[index++] = i; for(int j = i*i; i &lt; n; i++)&#123; mark[i] = true; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[]},{"title":"最大公约数与最小公倍数","slug":"gcd-lcm","date":"2018-03-31T08:24:14.000Z","updated":"2021-01-04T13:36:59.317Z","comments":true,"path":"2018/gcd-lcm/","link":"","permalink":"http://maneback.github.io/2018/gcd-lcm/","excerpt":"","text":"最大公约数与最小公倍数 最大公约数 两个整数a,b a&gt;b&gt;0。a和b的最大公约数就等于b，a%b的最大公约数。因此辗转相除，直到a%b==0，那么此时b的值就等于原来a，b两个数的最大公约数。 最小公倍数 两个正整数a、b的最小公倍数就等于a和b的乘积除以a、b的最大公约数。 (a*b/gcd(a,b)) 算法描述 1234567891011#include &lt;iostream&gt;using namespace std;int gcd(int a, int b)&#123; if(b == 0) return a; else return gcd(b, a%b);&#125;int lcm(int a, int b)&#123; return a*b/gcd(a,b)&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[]},{"title":"图论算法(四)最小生成树Prim算法","slug":"prim","date":"2018-03-31T08:16:24.000Z","updated":"2021-01-04T13:36:59.326Z","comments":true,"path":"2018/prim/","link":"","permalink":"http://maneback.github.io/2018/prim/","excerpt":"","text":"Prim 算法是从点的角度考虑构建最小生成树。 大致思想是：设图G的顶点集合为U， 首先选取任意的顶点a为起始点，将该点加入到集合V中，再从集合U-V中找到另一个顶点b，使得b到V中的任意一个顶点的距离最短，此时，将b也加入到集合V，以此类推，知道所有的顶点都已经加入到集合V当中，就构建出了一棵最小生成树(MST)。 因为有N的顶点，所以树就应该有N-1条边，每次向集合V中加入一个顶点，就意味着找到了MST的一条边。 ###设置两个数据结构： - lowcost[i]: 表示以i为重点的边的最小权值，当lowcost[i]为0，说明最小权值为0，该顶点已经加入到了MST。 - mst[i]: 表示对应的lowcost[i]的起点，即&lt;mst[i],i&gt;是MST当中的一条边，当mst[i] = 0 就表示起点加入MST. 另：图的邻接矩阵 ：w[N][N] ##样例代码： 12345678910111213141516171819202122232425262728293031323334353637383940#define N 100#define MAXCOST 10000int graph[N][N]int prim(int graph[][N], int n)&#123; int lowcost[N]; int mst[N]; //初始化lowcost 和 mst 数组 for(int i = 2; i &lt;= n; i++)&#123; lowcost[i] = graph[1][i]; mst[i] = 1; &#125; mst[1] = 0; // v1 in V int sum = 0; for(int i = 0; i &lt; n-1; i++)&#123; int mincost = MAXCOST; int findp = 0; for(int j = 2; j &lt;= n; j++)&#123; if(lowcost[j] &lt; mincost &amp;&amp; lowcost[j] != 0)&#123; mincost = lowcost[j]; findp = j; &#125; &#125; sum += mincost; lowcost[findp] = 0; for(int j = 2; j &lt;= n; j++)&#123; if(graph[findp][j] &lt; lowcost[j]) &#123; lowcost[j] = graph[findp][j]; mst[j] = findp; &#125; &#125; &#125; return sum; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://maneback.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://maneback.github.io/tags/最小生成树/"}]},{"title":"图论算法(三) 最小生成树kruskal算法","slug":"kruskal","date":"2018-03-31T08:08:08.000Z","updated":"2021-01-04T13:36:59.318Z","comments":true,"path":"2018/kruskal/","link":"","permalink":"http://maneback.github.io/2018/kruskal/","excerpt":"Kruskal算法是一种用贪心算法的思想来寻找最小生成树的算法。在图中存在相同权值的边是也有效。","text":"Kruskal算法是一种用贪心算法的思想来寻找最小生成树的算法。在图中存在相同权值的边是也有效。 描述 初始时所有的节点属于孤立的集合 按照边权值递增顺序遍历所有 边，若遍历到的边两个顶点属于不同的集合，则且定位最小生成树上的一条边，并将两个顶点集合合并。 遍历完所有边 之后，原图上所有节点属于同一个集合则被选取的边和节点构成一个最小生成树；否则图不连通，最小生成树不存在。 在kruskal算法中，图是按照边来存储的，三元组（顶点+权值） 我们要遍历所有的边，因为可能不连通，那么选取n-1 的循环则一直无法退出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#inlcude &lt;iostream&gt;#include &lt;algorithm&gt;#define N 108using namespace std;int pre[N];int find_root(int x)&#123; int r = x; while(pre[r] != r) r = pre[r]; int i = x, j; while( i!= r)&#123; j = pre[i]; pre[i] = r; i = pre[j]; &#125; return r;&#125;struct Edge&#123; int a, b; int cost; bool operator &lt; (const Edge&amp; A) const&#123; return cost&lt;A.cost; &#125;&#125;v[6000];int main()&#123; int n; cin&gt;&gt;n; while(1)&#123; if(n == 0) break; for(int i = 1; i &lt;=n*(n-1)/2; i++)&#123; cin&gt;&gt;v[i].a&gt;&gt;v[i].b&gt;&gt;v[i].cost; &#125; sort(v+1; v+1+n*(n-1)/2); int ans = 0; for(int i = 1; i &lt;= n*(n-1)/2; i++)&#123; int ra = find_root(v[i].a); int rb = find_root(v[i].b); if(a!= b)&#123; pre[ra] = rb; ans+=v[i].cost; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; cin&gt;&gt;n &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://maneback.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://maneback.github.io/tags/最小生成树/"}]},{"title":"图论算法(二) 最短路径Floyd算法","slug":"floyd","date":"2018-03-31T07:10:37.000Z","updated":"2021-01-04T13:36:59.316Z","comments":true,"path":"2018/floyd/","link":"","permalink":"http://maneback.github.io/2018/floyd/","excerpt":"","text":"Floyd 算法是解决任意两点之间的最短路径的一种算法，可以正确处理有向图或者负权图（但是不能有负权回路） 图的邻接矩阵G[i][j] 如果要两个顶点a和b之间的距离变短，就只能引入第三个顶点k，并通过顶点k中转得到路径a-&gt;k-&gt;b，才能缩短a到b的距离。 有时可能经过两个，三个顶点会变得更短，那么将这个问题一般化之后： **** 1. 当任意两点之间不允许通过第三个点时，最短路径矩阵P就初始为图的邻接矩阵G。 2. 如果此时只允许通过编号为1的顶点，求任意两个顶点之间的最短路径：（其实顶点1只是一个一般化的顶点，只是为了在后面的迭代循环中容易表示，所以选择1为第一个顶点） 只需要判断P[i][j] 与P[i][1]+P[1][j]的大小即可。 代码如下： 12345678//对于任意两点经过1的距离都进行比较for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(P[i][1]+P[1][j] &lt; P[i][j]) P[i][j] = P[i][1]+P[1][j]; &#125; &#125; 那么，还有可能经过1和2两个顶点之后，比只允许经过顶点1的路径还要短，则在经过1的基础上，在用经过2来更新矩阵P 123456789101112131415//顶点1for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(P[i][1]+P[1][j] &lt; P[i][j]) P[i][j] = P[i][1]+P[1][j]; &#125;&#125;//顶点2 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(P[i][2]+P[2][j] &lt; P[i][j]) P[i][j] = P[i][2]+P[2][j]; &#125; &#125; 更一般化，我们允许每一对顶点都可以经过任何顶点，即再嵌套一层循环 k代表允许中间经过的顶点。 12345678for(int k = 1; k &lt;= n; k++)&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(P[i][k]+P[k][j] &lt; P[i][j]) P[i][j] = P[i][k]+P[k][j]; &#125; &#125; &#125; 关于不能将循环变量k放在最里面的解释： 如果将k循环放在最里面，则过早的把i到j的最短路径确定下来了，之后存在更短的路径之后，矩阵P也不会再继续更新了。 关于两个顶点之间不存在直接通路的情况，可以用一个不会达到的权值表示无穷大的距离。在比较之前先判断i到k之间和k到j之间是否存在通路。 更新为： 123456789#define NOWAY 10000 //最长路径不会超过这个for(int k = 1; k &lt;= n; k++)&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(P[i][k] &lt; NOWAY &amp;&amp; P[k][j] &lt; NOWAY &amp;&amp;P[i][k]+P[k][j] &lt; P[i][j]) P[i][j] = P[i][k]+P[k][j]; &#125; &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://maneback.github.io/tags/图论/"},{"name":"最短路径","slug":"最短路径","permalink":"http://maneback.github.io/tags/最短路径/"}]},{"title":"图论算法(一) 最短路径dijistra算法","slug":"dijistra","date":"2018-03-31T07:04:31.000Z","updated":"2021-01-04T13:36:59.315Z","comments":true,"path":"2018/dijistra/","link":"","permalink":"http://maneback.github.io/2018/dijistra/","excerpt":"dijkstra算法是典型的用来解决最短路径的算法，用来求解从起始点到其他所有点的最短路径。该算法采用贪心的思想，每次都查找与该点距离最近的点，但是不能用来解决存在负权边的图。","text":"dijkstra算法是典型的用来解决最短路径的算法，用来求解从起始点到其他所有点的最短路径。该算法采用贪心的思想，每次都查找与该点距离最近的点，但是不能用来解决存在负权边的图。 ###数据结构： - 无向图邻接矩阵w[][] - 辅助向量near[] - 标记访问向量 visited[] ###算法原理： 1 引入辅助向量 near[], 每个分量near[i]表示当前找到的到i节点的最短路径长度，找到这些最短路径中最短的那个。 2 每次更新向量near[]，若从起点v经过中间点k到顶点w的路径长度小于near[w]，则将near[w]修改。 3 重复迭代粗过程 4 维护一个定点集合S，表示已经找到了从起点v到该点的最短路径。 ###算法过程 1. 先取一个顶点v为起点，初始化near[]， near[i]的值等于起点v到第i个顶点的距离w[v][i]，如果两者之间不存在路径，则初始化为无穷大。 2. 将visited[v]标记为1，表示该点已经访问过。 3. 寻找与v相邻最近的点k， 其中near[k]为最小值 4. 将visited[k]标记为1 5. 更新near[]，如果near[i]+w[k][j]&lt;near[j]，判断是直接连接v与j比较近，还是经过上次的最短路径点k到达j比较近。 6 重复上述过程，知道找到了所有的点。 ###代码实现 1234567891011121314151617181920212223242526272829303132333435363738#define N 20 //顶点个数#define NOPATH 1000 //没有路径相连int w[N][N]; //图的邻接矩阵int dist[N];int near[N];int visited[N];void dijkstar(int n, int v)&#123; for(int i = 0; i &lt; N; i ++)&#123; near[i] = NOPATH; visited[i] = 0; &#125; for(int i = 0; i &lt; n; i++)&#123; near[i] = w[v][i]; &#125; //循环找到n-1个最短路 for(int j = 1; j &lt; n; j++)&#123; int minpath = near[0]; int k = 0; //找到最短路径和最近点 for(int i = 1; i &lt; n; i++)&#123; if(near[i] &lt; minpath) minpath = near[i]; k = i; &#125; dist[k] = minpath; visited[k] = 1; for(int i = 0; i &lt; n; i++)&#123; if(!visited[i] &amp;&amp; minpath + w[k][i] &lt; near[i])&#123; near[i] = minpath + w[k][i]; &#125; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://maneback.github.io/tags/图论/"},{"name":"最短路径","slug":"最短路径","permalink":"http://maneback.github.io/tags/最短路径/"}]},{"title":"并查集","slug":"bingchaji","date":"2018-03-31T06:21:13.000Z","updated":"2021-01-04T13:36:59.304Z","comments":true,"path":"2018/bingchaji/","link":"","permalink":"http://maneback.github.io/2018/bingchaji/","excerpt":"并查集主要用来解决动态连通性问题。","text":"并查集主要用来解决动态连通性问题。 比如：随意给两个点，问是否联通，或者问图有几个联通分支，即被分为了几个块，畅通工程需要修几条路等等。 并查集有一个整数型的数组和两个函数组成。 数组 pre[ ] 记录了每个节点的前导节点是什么； find() 是查找根节点 join() 是合并两个元素所在的集合 需要实现的操作有：判断两个元素是否属于一个集合、合并两个集合 注意：每次查找之后进行路径压缩，将整棵树上的所有节点的前导节点都改为这棵树的根r，提高下次查找时候的查找效率。 123456//路径压缩, 将这一集合所以的pre都改为rwhile(i != r)&#123; j = pre[i]; pre[i] = r; i = j;&#125; 代码如下 12345678910111213141516171819202122232425262728293031#define N 1000int pre[N];//初始化for(int i = 0; i &lt; N; i++)&#123; pre[i] = i;&#125;int find(int x)&#123; //找x所在树的根节点 int r = x; while(r != pre[r]) r = pre[r]; int i = x, j; //路径压缩, 将这一集合所以的pre都改为r while(i != r)&#123; j = pre[i]; pre[i] = r; i = j; &#125; return r;&#125;int join(int x, int y)&#123; int rx = find(x); int ry = find(y); if(rx != ry)&#123; pre[rx] = ry; //将x的根节点接到y上面 &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://maneback.github.io/categories/Algorithm/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://maneback.github.io/tags/并查集/"},{"name":"图论","slug":"图论","permalink":"http://maneback.github.io/tags/图论/"}]},{"title":"GitHub博客搭建(三) Hexo配置与发布","slug":"hexo-guide-3","date":"2018-03-31T03:31:02.000Z","updated":"2021-01-04T13:36:59.317Z","comments":true,"path":"2018/hexo-guide-3/","link":"","permalink":"http://maneback.github.io/2018/hexo-guide-3/","excerpt":"","text":"一、Hexo文件夹 在GitHub/hexo 路径下安装完本地博客后，文件夹中的内容如下： 12345678|-- _config.yml|-- package.json|-- scaffolds|-- scripts|-- source |-- _drafts |-- _posts|-- themes 网站配置文件 _config.yml 是博客的配置文件，主要修改的部分有： site部分 12345678#sitetitle: Hexosubtitle:description:keywords:author: John Doelanguage:timezone: title 与subtitle 是网站的标题和副标题，这个是肯定要修改的。其他的language 和timezone 是语言和时区，按需更改，保持默认也可以。language 可以设置成zh-CN 。 在URL部分，有以下一项设置： 1parmalink: /:year/:month/:day/:title/ 可以修改为： 1parmalink: /:year:month:day/:title/ 这样，就可以避免生成的文件产生多层嵌套，或者也可以以月为单位来组织文件夹。 Deployment 部分 这部分是用于发布的，只若发布到GitHub上面，则按照以下的格式设置即可 1234deploy: type: git repo: #&lt;name.github.io&gt;仓库的ssh地址 branch: master 这样，就可以直接使用hexo d 命令发布到GitHub上面了。 theme部分 theme是设置网站的主题，Hexo有很多精美的主题，可以在Themes|Hexo 上面查看。首先要将你想要使用的Theme下载下来，然后将这个地方改成那个主题的名字即可。 ！注意： 在每个设置项的冒号后面都有一个空格， 若忘记加空格则会在后面的过程中报错。截止目前为止，我所遇到的报错都是因为空格问题。(PS: 回头来看，原来是因为YAML文件的语法要求空格) Theme 在theme/ 下面存放的是主题，可以在Themes|Hexo 上面查看，选择自己喜欢的主题，然后用git下载下来。需要注意的是一定要保持配置文件中theme选项的名字要与theme中主题文件夹的命名保持一致。 我所使用的主题是Manpassant，以它为例，在Git Bash中切换到GitHub/Hexo/ 路径下，输入以下命令 12345git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant##使用此主题需要的插件npm install hexo-renderer-pug --savenpm install hexo-renderer-sass --save 有时候，有些主题还需要下载其他的插件，按照GitHub网页上面的提示安装就好。 安装成功之后，再把配置文件里面的主题项修改了就可以了。 好多人都推荐的主题：NexT， 可是我没有用这个2333。自己查资料解决就好。 PS:真香警告： 我还是换回了最多人使用人见人爱的NEXT主题。 source/ 此文件夹里面保存的是创建的博客的原始Markdown文件，创建之后在这里编辑修改就好。或者也可以在这里直接新建.md文件。不同类型的文件保存在不同的文件夹中。 public/ 当执行过hexo g 命令后，就会新生成一个publib/ 文件夹，这里保存的是由Markdown文件生成的静态页面，分为不同的文件夹和页面。 二、发布 在public/ 文件夹中建立git仓库，然后与远端的&lt;yourname&gt;.github.io.git仓库连到一起，就可以同访问&lt;yourname&gt;.githubio 成功访问网站了。这样，每次更新博客之后，都可以推送到远端来查看了。 继续阅读： Hexo写作 参考 Themes|Hexo","categories":[{"name":"Blog","slug":"Blog","permalink":"http://maneback.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://maneback.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"http://maneback.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://maneback.github.io/tags/hexo/"}]},{"title":"GitHub博客搭建(一) Hexo介绍","slug":"Hexo-guide-1","date":"2018-03-30T14:28:12.000Z","updated":"2021-01-04T13:36:59.303Z","comments":true,"path":"2018/Hexo-guide-1/","link":"","permalink":"http://maneback.github.io/2018/Hexo-guide-1/","excerpt":"","text":"0. 废话 作为一个计算机专业的学生，最近突然萌生了自己搭建博客网站的想法，遂开始到处查找资料，最终利用GitHub Page和Hexo，历时两天，经历无数次摸索和失败之后，终于成功了。于是将自己的学习过程整理了出来。 1. 什么是Hexo？ Hexo是一个快速、简洁且高效的博客框架，可以用Markdown来解析文章，利用精美的主题来生成静态网页。也就是说，你可以用Markdown来写作，然后由它来帮你生成网页。 在我看来，由它生成的博客页面要比其他大多数现有的博客网站要精美得多，而且再搭配GitHub Page ，非常适合用来建个人博客（当然，也可以放到自己的域名的网站上），而且这过程中也锻炼了对Git和GitHub的理解。 2. 准备工作 安装Git 作为一个想要自建博客的人，理应知道Git和GitHub是什么。 下载Git并安装，并注册GitHub账号。(详细过程略过，不在我们的讨论范围内。) 安装Node.js Node.JS 注意： 新版已经会自动npm配置Path环境变量，否则需要自己配置。 1C:\\Program Files\\nodejs\\node_modules\\npm 将其加入到Path 环境变量中，路径是在你电脑中的安装路径。 创建GitHub仓库： 首先申请一个GitHub账号，然后新建一个仓库，名称格式为： &lt;yourname&gt;.github.io 必须符合命名格式，才能生成页面，当一切都配置成功之后，就可以通过以下地址访问自己的博客 https://&lt;yourname&gt;.github.io ​ 3. 安装Hexo 首先，创建一个目录，如我将它起名为GitHub ，然后在Git Shell 中切换到该目录下，输入以下命令； 12npm install hexo-cli -gnpm install hexo --save 如果命令无法继续运行，可以切换npm源： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 命令运行结束，Hexo就安装成功了。 继续阅读： Hexo搭建和使用 延伸 Git 教程 Git教程-廖雪峰的官方网站 Git documentation Markdown教程 献给写作者的 Markdown 新手指南 - 简书 我的Markdown教程 我使用的markdown编辑器：typora ，** Atom 下载链接： https://typora.io/ https://atom.io/ 参考 Hexo文档 使用GitHub和Hexo搭建免费静态Blog","categories":[{"name":"Blog","slug":"Blog","permalink":"http://maneback.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://maneback.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"http://maneback.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://maneback.github.io/tags/hexo/"}]},{"title":"GitHub博客搭建(二) Hexo搭建与使用","slug":"hexo-guide-2","date":"2018-03-29T14:28:12.000Z","updated":"2021-01-04T13:36:59.317Z","comments":true,"path":"2018/hexo-guide-2/","link":"","permalink":"http://maneback.github.io/2018/hexo-guide-2/","excerpt":"PS: 在我学习安装过程中，遇到了两条不同的思路： （一）首先建立仓库，然后clone到本地，再在里面创建hexo博客。 （二）先在本地创建hexo博客，然后将它与GitHub上面的仓库连接起来。","text":"PS: 在我学习安装过程中，遇到了两条不同的思路： （一）首先建立仓库，然后clone到本地，再在里面创建hexo博客。 （二）先在本地创建hexo博客，然后将它与GitHub上面的仓库连接起来。 1.初始化配置 我们假设要将博客放在/GitHub 目录下， 在Git Shell 下，切换到/GitHub路径，执行以下指令，初始化本地博客： 123hexo init &lt;folder&gt; #folder 中将创建需要的文件cd &lt;folder&gt;npm install 假设所执行的命令为 hexo init hexo ， 生成的文件夹为：GitHub/hexo 执行之后，就在本地创建好了hexo博客 安装Hexo插件 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --save ##wentinpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --save ##npm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 2. Hexo主要命令 创建新的博客 123hexo new [layout] &lt;title&gt;# 等价于：hexo n [layout] &lt;title&gt; layout不同则产生的博客类型和默认路径也不同 layout path userage post source/_post 一篇博客 page source 一个页面 draft source/_draft 草稿 默认类型为post ， 此命令会在对应的文件夹生成title.md文件，然后就可以编辑此文件，用下面的命令生成静态页面。 生成静态页面 123hexo generate#等价于hexo g 执行此命令后，就会产生public/ 文件夹，所有生成的内容都会保存在这里。 在本地查看运行结果 执行以下命令，然后在浏览器打开localhost:4000 查看效果。 同时安装插件之后，还可以不用关闭服务，就可以随时查看修改下效果。 123hexo server#等价于hexo s 选项 描述 -p , -port 重设端口 -s, -static 只使用静态文件 -l, -log 启动日记记录，使用覆盖格式记录 发布 123hexo deploy#等价于hexo d 清除内容 1hexo clean 用于清除缓存文件和已经生成的静态文件(public/)，如果发现对站点的更改没有生效，可能需要执行该命令。 继续阅读： Hexo配置与发布 参考 指令|Hexo 使用GitHub和Hexo搭建免费静态Blog","categories":[{"name":"Blog","slug":"Blog","permalink":"http://maneback.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://maneback.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"http://maneback.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://maneback.github.io/tags/hexo/"}]}]}